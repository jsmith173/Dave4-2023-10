package Model.APPS.BUCK_VC_FIX_FQ.v4_1_4;

/*
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 following conditions are met:
                                                                             
 Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 disclaimer.
  
 Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided with the distribution.
  
 Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 products derived from this software without specific prior written permission.
                                                                             
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                             
 To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes with
 Infineon Technologies AG: dave@infineon.com. */

/*************** Revision History **********************************************
 Version        Date          Description
 
   4.0.0       08-Oct-2015   Initial version for DAVEv4
   4.0.1       14-Oct-2015   1.Help document is updated <br>
                             2.Dead code removed in BUCK_VC_FIX_FQ_lPWM_CCU8_Start() API and
                               BUCK_VC_FIX_FQ_lPWM_CCU8_Stop() API<br>
                             3.Corrected the enumeration for setting GPIO pin level.<br>  
   4.0.3       15-Oct-2015   1.Typo in BUCK_VC_FIX_FQ_lClearOverloadProtectionVariables() API is corrected. <br>      
                             2.HRPWM Compare 2 configuration in HRPWM APP is made read only.<br> 
                             3.Min/Max range for over limit and under limit configurations are corrected in UI.<br>
                             4.Help document is updated.<br>
                             5.Number of samples for overload protection is set as 8 for XMC1x device. <br>
                             6.Voltage gain constant calculation is corrected when Vin is not measured. <br>
                             7.Default Max duty cycle is modified. <br>
   4.0.5       16-Oct-2015   1.Over limit & Under limit values are corrected. <br>
   4.0.7       16-Oct-2015   1.Help document is updated. <br>     
                             2.Default Soft start value is updated to 5000. <br>
   4.0.9       28-Oct-2015   1.Help document is updated. <br>
                             2.Updated default values in UI. <br>
   4.0.11      20-Nov-2015   1.APP uses CONTROL_LIB APP in place of POWER_CONV_LIB APP. <br>
                             2.PWM_CCU4 APP support is removed. <br>
                             3.Dynamic scaling algorithm implemented for XMC1x device.<br>
                             4.Control Settings tab UI is modified. <br>
                             5.APP handle structure is modified. <br>
   4.0.12      11-Jan-2016   1.Bug fixes. <br>
   4.0.14      18-Jan-2016   1.Bug fixes. <br>
   4.0.16      19-Jan-2016   1.Bugs fixed in BUCK_VC_FIX_FQ_Start() & BUCK_VC_FIX_FQ_Stop() APIs. <br>                                  
   4.0.18      20-Jan-2016   1.Control loop code is updated. <br>
   4.0.20      23-Jan-2016   1.PI compensator support is removed.<br>
                             2.Vout reference voltage is now in steps of ADC voltage.<br>
                             3.Help documentation is updated <br>
   4.1.2       03-Feb-2016   1.Check is added to detect invalid strings in UI. <br>
   4.1.4       11-May-2020   Modified check for minimum XMCLib version. <BR>
 *******************************************************************************/
import ifx.davex.app.manifest.*
import java.util.regex.Matcher

class  BUCK_VC_FIX_FQ extends BUCK_VC_FIX_FQ_GUI {

    /* Note  : Following App properties are mandatory and important */
    /* Begin : App property section */
    
    /**
     * App version
     * Format: a string with three digit separated by a dot.
     */
    def version                 = '4.1.4'
    
    /**
     * App categories declaration. gcombo_controller_type
     * It is list of strings. Subcategories are separated by slash.
     * No limits on number of categories and subcategories depth.
     */
    def categoriesDescription   = ["Power Conversion"]

    /** 
     * Minimum DAVE version required for this app.
     * 
     * It is string with three digit separated by a dot.
     */
    def minDaveVersion          = '4.0.0'
    
    /** 
     * Keywords used by search feature in Apps selection view
     * 
     * It is a list of string.
     */
    def keywords                = ["Buck voltage control", "BUCK_VC_FIX_FQ", "Power Conversion", "all","HRPWM"]
    
    /** 
     * softwareIDs is used to declare which devices are compatible with this app.
     * It is a map with key a string containing a pattern that shall match the SW id of
     * the device and as value the minimal version of the app.
     * 
     * 
     */
    def softwareIDs             = [
                                  //XMC44
                                  "XMC4.4.*.*.*":"1.0.0",
                                  //"XMC42
                                  "XMC4.2.*.*.*":"1.0.0",                              
                                  //"XMC41
                                  "XMC4.1.*.*.*":"1.0.0",
                                  //"XMC13
                                  "XMC1.3.*.*.*":"1.0.0", 
                                  //"XMC14
                                  "XMC1.4.(02|04).*.*":"1.0.0",
                                  ]
 
    /**
     * Singleton property:
     * When it is true the app can be instantiated only once.
     */
    def singleton               = false
    
    /**
     * initProvider property
     * It shall be true to add a call to <AppName>_Init()
     */
    def initProvider            = true
    
    /**
     * Deprecated APP
     * Set it to true to indicate that the app shall be not used for new projects.
     */
    def deprecated              = false
    
    /**
     * Sharable property.
     * It shall be true to allows multiple apps to require the same instance of this app.
     */
    def sharable                = false

    /**
     *  App function description.
     */
    def description             = "APP can be used to control different configurations of a buck converter in voltage mode using fixed frequency."
    
    // End   : App property section
    
    
    // Begin : User app property section
    
    /*The MCU pin resource group for ADC*/
    MVirtualResourceGroup hwres_chan_a_pin
    MVirtualResourceGroup hwres_chan_b_pin
    MVirtualResourceGroup hwres_chan_c_pin
    MVirtualResourceGroup hwres_chan_d_pin
    MVirtualResourceGroup hwres_chan_e_pin
    MVirtualResourceGroup hwres_chan_f_pin
    MVirtualResourceGroup hwres_chan_g_pin
    /*The MCU pin resource group of ADC is stored in the array*/
    RArray<MVirtualResourceGroup>  rarray_hwres_adcchan            = RArray(7);
    
    /*The result register resource group is stored in array*/
    RArray<MVirtualResourceGroup>  rarray_hwres_result             = RArray(7);
    
    MVirtualResourceGroup hwres_nvicnode
    
    MRequiredApp appres_queue_a
    MRequiredApp appres_queue_b
    MRequiredApp appres_queue_c
    MRequiredApp appres_queue_d
    MRequiredApp appres_queue_e
    MRequiredApp appres_queue_f
    MRequiredApp appres_queue_g
    /*The ADC queue app is stored in the array when queue is used*/
    RArray<MRequiredApp> rarray_appres_scan                        = RArray(7);
    
    MRequiredApp appres_scan_a
    MRequiredApp appres_scan_b
    MRequiredApp appres_scan_c
    MRequiredApp appres_scan_d
    MRequiredApp appres_scan_e
    MRequiredApp appres_scan_f
    MRequiredApp appres_scan_g
    /*The ADC scan APP is stored in the array when scan is used*/
    RArray<MRequiredApp> rarray_appres_queue                       = RArray(7);
    
    MRequiredApp appres_hrpwm_1
    MRequiredApp appres_hrpwm_2
    MRequiredApp appres_hrpwm_3
    MRequiredApp appres_hrpwm_4
    /*The HRPWM APP is stored in the array when HRPWM is used*/
    RArray<MRequiredApp> rarray_appres_hrpwm                       = RArray(4);
    
    MRequiredApp appres_pwm_ccu8_1
    MRequiredApp appres_pwm_ccu8_2
    MRequiredApp appres_pwm_ccu8_3
    MRequiredApp appres_pwm_ccu8_4
    /*The PWM_CCU8 APP is stored in the array when PWM_CCU8 is used*/
    RArray<MRequiredApp> rarray_appres_pwm_ccu8                    = RArray(4);
    
    MRequiredApp appres_power_con_library
    
    MRequiredApp appres_cpu_4x
    MRequiredApp appres_cpu_1x
    MRequiredApp appres_systimer
    
    /* Signals for ADC pin*/
    MVirtualSignal vs_buck_vc_fix_fq_adcch1_io
    MVirtualSignal vs_buck_vc_fix_fq_adcch2_io
    MVirtualSignal vs_buck_vc_fix_fq_adcch3_io
    MVirtualSignal vs_buck_vc_fix_fq_adcch4_io
    MVirtualSignal vs_buck_vc_fix_fq_adcch5_io
    MVirtualSignal vs_buck_vc_fix_fq_adcch6_io
    MVirtualSignal vs_buck_vc_fix_fq_adcch7_io
    
    /*Signals for ADC channel*/
    MVirtualSignal vs_buck_vc_fix_fq_adcch1
    MVirtualSignal vs_buck_vc_fix_fq_adcch2
    MVirtualSignal vs_buck_vc_fix_fq_adcch3
    MVirtualSignal vs_buck_vc_fix_fq_adcch4
    MVirtualSignal vs_buck_vc_fix_fq_adcch5
    MVirtualSignal vs_buck_vc_fix_fq_adcch6
    MVirtualSignal vs_buck_vc_fix_fq_adcch7
    /*The ADC channel signals are stored in the array*/
    RArray<MVirtualSignal> rarray_vs_buck_vc_fix_fq_adcch            = RArray(7);
    
    /*Signals for ADC Channel iclass */
    MVirtualSignal vs_buck_vc_fix_fq_adcch1_iclass_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch2_iclass_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch3_iclass_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch4_iclass_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch5_iclass_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch6_iclass_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch7_iclass_sel
    /*The ADC channel iclass signals are stored in the array*/
    RArray<MVirtualSignal> rarray_vs_buck_vc_fix_fq_adcch_iclass_sel = RArray(7);
    
    /* These are iclass signals coming from ADC_SCAN APP*/
    RArray<MVirtualSignal> rarray_vs_buck_vc_fix_fq_adc_scan_iclass  = RArray(7);
    /* These are iclass signals coming from ADC_QUEUE APP*/
    RArray<MVirtualSignal> rarray_vs_buck_vc_fix_fq_adc_queue_iclass = RArray(7);
    
    /*The ADC channel */
    MVirtualSignal vs_buck_vc_fix_fq_adcch1_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch2_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch3_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch4_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch5_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch6_sel
    MVirtualSignal vs_buck_vc_fix_fq_adcch7_sel
    /*The ADC channel signals are stored in the array*/
    RArray<MVirtualSignal> rarray_vs_buck_vc_fix_fq_adcch_sel      = RArray(7);
    
    MVirtualSignal vs_result_event_out
    MVirtualSignal vs_nvic_signal_in
    
    MVirtualSignalRA vs_pwm_ccu8_pm_out
    MVirtualSignalRA vs_hrpwm_pm_out
    
    /*The res_sel from resource group ACD CHANNEL*/
    MVirtualSignal vs_buck_vc_fix_fq_adcch1_ressel
    MVirtualSignal vs_buck_vc_fix_fq_adcch2_ressel
    MVirtualSignal vs_buck_vc_fix_fq_adcch3_ressel
    MVirtualSignal vs_buck_vc_fix_fq_adcch4_ressel
    MVirtualSignal vs_buck_vc_fix_fq_adcch5_ressel
    MVirtualSignal vs_buck_vc_fix_fq_adcch6_ressel
    MVirtualSignal vs_buck_vc_fix_fq_adcch7_ressel
    RArray<MVirtualSignal>   rarray_vs_buck_vc_fix_fq_adcch_ressel = RArray(7);
    
    /*The res_sel from resource group ACD RESULT*/
    MVirtualSignal vs_buck_vc_fix_fq_adcch1_res
    MVirtualSignal vs_buck_vc_fix_fq_adcch2_res
    MVirtualSignal vs_buck_vc_fix_fq_adcch3_res
    MVirtualSignal vs_buck_vc_fix_fq_adcch4_res
    MVirtualSignal vs_buck_vc_fix_fq_adcch5_res
    MVirtualSignal vs_buck_vc_fix_fq_adcch6_res
    MVirtualSignal vs_buck_vc_fix_fq_adcch7_res
    RArray<MVirtualSignal>   rarray_vs_buck_vc_fix_fq_adcch_res    = RArray(7);
    
    /*queue2channel signals from ADC QUEUE APP*/
    RArray<MVirtualSignalRA> rarray_vs_buck_vc_fix_fq_adc_queue    = RArray(7);
    
    /*scan2channel signals from ADC SCAN APP*/
    RArray<MVirtualSignalRA> rarray_vs_buck_vc_fix_fq_adc_scan     = RArray(7);
    
    RArray<MVirtualSignalRA> rarray_vs_adc_scan_trigger_in         = RArray(7);
    RArray<MVirtualSignalRA> rarray_vs_adc_queue_trigger_in        = RArray(7);
    RArray<GCheck>           rarray_gcheck_measure_entity          = RArray(7);
    RArray<GString>          rarray_gstring_measure_entity         = RArray(7);
    RArray<GCheck>           rarray_gcombo_q_position              = RArray(7);
    RArray<GFloat>           rarray_gfloat_divider_gain            = RArray(6); //array size is 6 because 'User_Defined' measurement does not have gain ratio
    
    
/*
 *   ____________________                  ____________________                         ____________________
 *  |    RG:_chan_a_pin  |                |     RG:_adcch1     |                       |    RG:_result      |
 *  |                    |_io      _adcch1|                    |_ressel      _adcch_res|                    |
 *  |               PAD  |--------------> |GCH          res_sel|---------------------->|res_sel             |
 *  |                    |                |       select       |                       |                    |
 *  |____________________|                |____________________|                       |____________________|
 *                                                  ^ _adcch_sel
 *                                                  |
 *                                        _adc_scan | _adc_queue
 *                                  ________________|_________________
 *                                 |   scan2channel |  queue2channel  |
 *                                 | ______________ | ______________  |
 *                                 |                |                 |
 *                                 | APP:ADC_SCAN   | APP:ADC_QUEUE   |
 *                                 |________________|_________________|
 * */
    // End   : User app property section
    
    GInteger ginteger_adc_num_bits         = GInteger(widgetName:"ginteger_adc_num_bits",  value:12, minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    GInteger ginteger_max_error            = GInteger(widgetName:"ginteger_max_error",     value:12, minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    GInteger ginteger_min_error            = GInteger(widgetName:"ginteger_min_error",     value:12, minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    GInteger ginteger_ref                  = GInteger(widgetName:"ginteger_ref",           value:12, minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    
    GFloat gfloat_adc_ref_voltage          = GFloat  (widgetName:"gfloat_adc_ref_voltage", value:3.3, minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    GFloat gfloat_bxk_max_abs              = GFloat  (widgetName:"gfloat_bxk_max_abs",     value:0,   minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    GFloat gfloat_a_max_abs                = GFloat  (widgetName:"gfloat_a_max_abs",       value:0,   minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    GFloat gfloat_wcase_bke                = GFloat  (widgetName:"gfloat_wcase_bke",       value:0,   minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    GFloat gfloat_wcase_au                 = GFloat  (widgetName:"gfloat_wcase_au",        value:0,   minValue:Long.MIN_VALUE, maxValue:Long.MAX_VALUE,enabled:true, visible:false, isMandatoryValue:false)
    
    // App Constructor
    public BUCK_VC_FIX_FQ(DaveEnv daveEnv) {
        int i;                   // needed for all indexing options
        Boolean is_4x_device; // true for XMC4x target, false for XMC1x target
        
        /* ---------------------------------------------------------- */
        /* ------------ Initializations - assigning to array -------- */
        /* ---------------------------------------------------------- */
        
        /* user given measurement entity name */
        rarray_gstring_measure_entity[0] = gstring_vout_measurement
        rarray_gstring_measure_entity[1] = gstring_vin_measurement
        rarray_gstring_measure_entity[2] = gstring_iout1_measurement
        rarray_gstring_measure_entity[3] = gstring_iout2_measurement
        rarray_gstring_measure_entity[4] = gstring_iout3_measurement
        rarray_gstring_measure_entity[5] = gstring_iout4_measurement
        rarray_gstring_measure_entity[6] = gstring_udef1_measurement
        
        /* measurement entity selection */
        rarray_gcheck_measure_entity[0]  = gcheck_measure_vout
        rarray_gcheck_measure_entity[1]  = gcheck_measure_vin
        rarray_gcheck_measure_entity[2]  = gcheck_measure_iout1
        rarray_gcheck_measure_entity[3]  = gcheck_measure_iout2
        rarray_gcheck_measure_entity[4]  = gcheck_measure_iout3
        rarray_gcheck_measure_entity[5]  = gcheck_measure_iout4
        rarray_gcheck_measure_entity[6]  = gcheck_measure_user_defined_1
        
        /* q position */
        rarray_gcombo_q_position[0]      = gcombo_vout_q_pos
        rarray_gcombo_q_position[1]      = gcombo_vin_q_pos
        rarray_gcombo_q_position[2]      = gcombo_iout1_q_pos
        rarray_gcombo_q_position[3]      = gcombo_iout2_q_pos
        rarray_gcombo_q_position[4]      = gcombo_iout3_q_pos
        rarray_gcombo_q_position[5]      = gcombo_iout4_q_pos
        rarray_gcombo_q_position[6]      = gcombo_adc_q_pos_user_defined_1
        
        
        rarray_gfloat_divider_gain[0]    = gfloat_vout_gain
        rarray_gfloat_divider_gain[1]    = gfloat_vin_gain
        rarray_gfloat_divider_gain[2]    = gfloat_iout1_gain
        rarray_gfloat_divider_gain[3]    = gfloat_iout2_gain
        rarray_gfloat_divider_gain[4]    = gfloat_iout3_gain
        rarray_gfloat_divider_gain[5]    = gfloat_iout4_gain
        
        //below are dummy tabs used for documentation purpose
        gtab_dummy_adc_measurement.visible      = false;
        gtab_dummy_overload_protections.visible = false;
        
        /* -------------------------------------------------------------- */
        /* ---------- Target Specific User Variable Initialization ------ */
        /* -------------------------------------------------------------- */
                
        if (daveEnv.project.selectedDevice.deviceId.family == "XMC4")
        {
            is_4x_device = true   // target device is XMC4x
        }
        else
        {
            is_4x_device = false  // target device is XMC1x
        }
        
        
        /* ---------- 4 HRPWM APP ------ */
        
        appres_hrpwm_1    = MRequiredApp("HRPWM","Phase 0", RNOTSHARABLE, "4.1.16", MF({gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 1) },Boolean))
        appres_hrpwm_2    = MRequiredApp("HRPWM","Phase 1", RNOTSHARABLE, "4.1.16", MF({gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 2) },Boolean))
        appres_hrpwm_3    = MRequiredApp("HRPWM","Phase 2", RNOTSHARABLE, "4.1.16", MF({gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 3) },Boolean))
        appres_hrpwm_4    = MRequiredApp("HRPWM","Phase 3", RNOTSHARABLE, "4.1.16", MF({gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 4) },Boolean))
        
        rarray_appres_hrpwm[0] = appres_hrpwm_1
        rarray_appres_hrpwm[1] = appres_hrpwm_2
        rarray_appres_hrpwm[2] = appres_hrpwm_3
        rarray_appres_hrpwm[3] = appres_hrpwm_4
        
        /* ---------- 4 PWM CCU8 APP ------ */

        appres_pwm_ccu8_1    = MRequiredApp("PWM_CCU8","Phase 0", RNOTSHARABLE, "4.1.18", MF({!gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 1)},Boolean))
        appres_pwm_ccu8_2    = MRequiredApp("PWM_CCU8","Phase 1", RNOTSHARABLE, "4.1.18", MF({!gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 2)},Boolean))
        appres_pwm_ccu8_3    = MRequiredApp("PWM_CCU8","Phase 2", RNOTSHARABLE, "4.1.18", MF({!gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 3)},Boolean))
        appres_pwm_ccu8_4    = MRequiredApp("PWM_CCU8","Phase 3", RNOTSHARABLE, "4.1.18", MF({!gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 4)},Boolean))
        
        rarray_appres_pwm_ccu8[0] = appres_pwm_ccu8_1
        rarray_appres_pwm_ccu8[1] = appres_pwm_ccu8_2
        rarray_appres_pwm_ccu8[2] = appres_pwm_ccu8_3
        rarray_appres_pwm_ccu8[3] = appres_pwm_ccu8_4
        
        /* ---------- CONTROL_LIB APP ------ */
        appres_power_con_library     = MRequiredApp("CONTROL_LIB","Control Library", RSHARABLE, "4.0.4")
        
        /* ---------- CPU APP ------ */
        appres_cpu_4x = MRequiredApp("CPU_CTRL_XMC4","CPU", RSHARABLE, "4.0.12", MF({((is_4x_device)  && (gcombo_isr_event.value == "Vout Result Event"))},Boolean))
        appres_cpu_1x = MRequiredApp("CPU_CTRL_XMC1","CPU", RSHARABLE, "4.0.6", MF({((!is_4x_device) && (gcombo_isr_event.value == "Vout Result Event"))},Boolean))
        
        /* ---------- 4 ADC QUEUE APP ------ */
        appres_queue_a = MRequiredApp("ADC_QUEUE","",RSHARABLE,"4.0.16", MF({gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[0].value},Boolean))
        appres_queue_b = MRequiredApp("ADC_QUEUE","",RSHARABLE,"4.0.16", MF({gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[1].value},Boolean))
        appres_queue_c = MRequiredApp("ADC_QUEUE","",RSHARABLE,"4.0.16", MF({gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[2].value},Boolean))
        appres_queue_d = MRequiredApp("ADC_QUEUE","",RSHARABLE,"4.0.16", MF({gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[3].value},Boolean))
        appres_queue_e = MRequiredApp("ADC_QUEUE","",RSHARABLE,"4.0.16", MF({gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[4].value},Boolean))
        appres_queue_f = MRequiredApp("ADC_QUEUE","",RSHARABLE,"4.0.16", MF({gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[5].value},Boolean))
        appres_queue_g = MRequiredApp("ADC_QUEUE","",RSHARABLE,"4.0.16", MF({gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[6].value},Boolean))

        rarray_appres_queue[0] = appres_queue_a
        rarray_appres_queue[1] = appres_queue_b
        rarray_appres_queue[2] = appres_queue_c
        rarray_appres_queue[3] = appres_queue_d
        rarray_appres_queue[4] = appres_queue_e
        rarray_appres_queue[5] = appres_queue_f
        rarray_appres_queue[6] = appres_queue_g
        
        /* ---------- ADC SCAN APP ------ */
        appres_scan_a = MRequiredApp("ADC_SCAN","",RSHARABLE,"4.0.14", MF({gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[0].value},Boolean))
        appres_scan_b = MRequiredApp("ADC_SCAN","",RSHARABLE,"4.0.14", MF({gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[1].value},Boolean))
        appres_scan_c = MRequiredApp("ADC_SCAN","",RSHARABLE,"4.0.14", MF({gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[2].value},Boolean))
        appres_scan_d = MRequiredApp("ADC_SCAN","",RSHARABLE,"4.0.14", MF({gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[3].value},Boolean))
        appres_scan_e = MRequiredApp("ADC_SCAN","",RSHARABLE,"4.0.14", MF({gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[4].value},Boolean))
        appres_scan_f = MRequiredApp("ADC_SCAN","",RSHARABLE,"4.0.14", MF({gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[5].value},Boolean))
        appres_scan_g = MRequiredApp("ADC_SCAN","",RSHARABLE,"4.0.14", MF({gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[6].value},Boolean))
        
        rarray_appres_scan[0] = appres_scan_a
        rarray_appres_scan[1] = appres_scan_b
        rarray_appres_scan[2] = appres_scan_c
        rarray_appres_scan[3] = appres_scan_d
        rarray_appres_scan[4] = appres_scan_e
        rarray_appres_scan[5] = appres_scan_f
        rarray_appres_scan[6] = appres_scan_g
        
        /* ---------- SYSTIMER APP ------ */
        appres_systimer = MRequiredApp("SYSTIMER","",RSHARABLE, "4.1.12", MF({gcheck_soft_start.value},Boolean))
        
        /* ---------------------------------------------------------------------------- */
        /* ------------ Hardware resource consumption & virtual signals block --------- */
        /* ---------------------------------------------------------------------------- */
        for(i=0; i<7; i++)
        {
            int index = i;
            
            /* ---------- consumes up to 7 ADC channel resources ------ */
            rarray_hwres_adcchan[index] = MVirtualResourceGroup(MF({rarray_gstring_measure_entity[index].value + " channel"},String), ["peripheral", "vadc", "0", "group", "*", "ch","*"], MF({rarray_gcheck_measure_entity[index].value},Boolean))
            
            /* ---------- consumes up to 7 ADC result resources ------ */
            rarray_hwres_result[index]  = MVirtualResourceGroup(MF({rarray_gstring_measure_entity[index].value + " result"},String), ["peripheral", "vadc", "0", "group", "*", "result","*"], MF({rarray_gcheck_measure_entity[index].value},Boolean))
            
                        
            /* ---------- virtual signals for ADC channel - ADC input pin is connected to this signal --------------- */
            rarray_vs_buck_vc_fix_fq_adcch[index]        = MVirtualSignal(rarray_hwres_adcchan[index], MF({rarray_gstring_measure_entity[index].value.toLowerCase() + "_channel"},String), "gch", MF({rarray_gcheck_measure_entity[index].value},Boolean), false)
            
            /* ---------- virtual signals for ADC channel - ADC request source (scan/queue) is connected to this signal --------------- */
            rarray_vs_buck_vc_fix_fq_adcch_sel[index]    = MVirtualSignal(rarray_hwres_adcchan[index], MF({rarray_gstring_measure_entity[index].value.toLowerCase() + "_channel_select"},String), "select", MF({rarray_gcheck_measure_entity[index].value},Boolean), false)
            
            /* ---------- virtual signals for ADC channel - the signal is connected to ADC result resource --------------- */
            rarray_vs_buck_vc_fix_fq_adcch_ressel[index] = MVirtualSignal(rarray_hwres_adcchan[index], MF({rarray_gstring_measure_entity[index].value.toLowerCase() + "_result_select"},String), "res_sel", MF({rarray_gcheck_measure_entity[index].value},Boolean), false)
            
            /* ---------- virtual signals for ADC result resource ---------------- */
            rarray_vs_buck_vc_fix_fq_adcch_res[index]    = MVirtualSignal(rarray_hwres_result[index],  MF({rarray_gstring_measure_entity[index].value.toLowerCase() + "_result"},String), "res_sel", MF({rarray_gcheck_measure_entity[index].value},Boolean), false)
            
            /* ---------- virtual signals for ADC channel iclass - the signal is connected to ADC request resource's (scan/queue) iclass signal ---------------- */
            rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[index] = MVirtualSignal(rarray_hwres_adcchan[index], MF({rarray_gstring_measure_entity[index].value.toLowerCase() + "_channel_iclass"},String), "iclass_sel", MF({rarray_gcheck_measure_entity[index].value},Boolean), false)
            
            /* ---------- virtual signals for ADC iclass - scan request resource -------- */
            rarray_vs_buck_vc_fix_fq_adc_scan_iclass[index]  =  MVirtualSignalRA(rarray_appres_scan[index], "vs_adc_scan_iclass2channel")
            
            /* ---------- virtual signals for ADC iclass - queue request resource -------- */
            rarray_vs_buck_vc_fix_fq_adc_queue_iclass[index] =  MVirtualSignalRA(rarray_appres_queue[index], "vs_adc_queue_iclass2channel")
            
            /* ---------- virtual signals for ADC channel - scan request resource -------- */
            rarray_vs_buck_vc_fix_fq_adc_scan[index]         =  MVirtualSignalRA(rarray_appres_scan[index], "vs_adc_scan_scan2channel")
            
            /* ---------- virtual signals for ADC Channel - queue request resource -------- */
            rarray_vs_buck_vc_fix_fq_adc_queue[index]        =  MVirtualSignalRA(rarray_appres_queue[index], "vs_adc_queue_queue2channel")
            
            /* ---------- virtual signal for ADC scan trigger input  -------- */
            rarray_vs_adc_scan_trigger_in[index]             =  MVirtualSignalRA(rarray_appres_scan[index], "vs_adc_scan_greqtr0sel")
            
            /* ---------- virtual signal for ADC queue trigger input  -------- */
            rarray_vs_adc_queue_trigger_in[index]            =  MVirtualSignalRA(rarray_appres_queue[index], "vs_adc_queue_greqtr0sel")
        }
        
        /*These signal are used for display in HW connectivity view.
         * Also the connection constraint to _adcch1_io cannot be put in a for() loop - DAVE MS limitation */
        vs_buck_vc_fix_fq_adcch1            = rarray_vs_buck_vc_fix_fq_adcch[0]
        vs_buck_vc_fix_fq_adcch2            = rarray_vs_buck_vc_fix_fq_adcch[1]
        vs_buck_vc_fix_fq_adcch3            = rarray_vs_buck_vc_fix_fq_adcch[2]
        vs_buck_vc_fix_fq_adcch4            = rarray_vs_buck_vc_fix_fq_adcch[3]
        vs_buck_vc_fix_fq_adcch5            = rarray_vs_buck_vc_fix_fq_adcch[4]
        vs_buck_vc_fix_fq_adcch6            = rarray_vs_buck_vc_fix_fq_adcch[5]
        vs_buck_vc_fix_fq_adcch7            = rarray_vs_buck_vc_fix_fq_adcch[6]
        
        /*These signal are used for display in HW connectivity view*/
        vs_buck_vc_fix_fq_adcch1_ressel     = rarray_vs_buck_vc_fix_fq_adcch_ressel[0]
        vs_buck_vc_fix_fq_adcch2_ressel     = rarray_vs_buck_vc_fix_fq_adcch_ressel[1]
        vs_buck_vc_fix_fq_adcch3_ressel     = rarray_vs_buck_vc_fix_fq_adcch_ressel[2]
        vs_buck_vc_fix_fq_adcch4_ressel     = rarray_vs_buck_vc_fix_fq_adcch_ressel[3]
        vs_buck_vc_fix_fq_adcch5_ressel     = rarray_vs_buck_vc_fix_fq_adcch_ressel[4]
        vs_buck_vc_fix_fq_adcch6_ressel     = rarray_vs_buck_vc_fix_fq_adcch_ressel[5]
        vs_buck_vc_fix_fq_adcch7_ressel     = rarray_vs_buck_vc_fix_fq_adcch_ressel[6]
        
        /*These signal are used for display in HW connectivity view*/
        vs_buck_vc_fix_fq_adcch1_res        = rarray_vs_buck_vc_fix_fq_adcch_res[0]
        vs_buck_vc_fix_fq_adcch2_res        = rarray_vs_buck_vc_fix_fq_adcch_res[1]
        vs_buck_vc_fix_fq_adcch3_res        = rarray_vs_buck_vc_fix_fq_adcch_res[2]
        vs_buck_vc_fix_fq_adcch4_res        = rarray_vs_buck_vc_fix_fq_adcch_res[3]
        vs_buck_vc_fix_fq_adcch5_res        = rarray_vs_buck_vc_fix_fq_adcch_res[4]
        vs_buck_vc_fix_fq_adcch6_res        = rarray_vs_buck_vc_fix_fq_adcch_res[5]
        vs_buck_vc_fix_fq_adcch7_res        = rarray_vs_buck_vc_fix_fq_adcch_res[6]
        
        /*These signal are used for display in HW connectivity view*/
        vs_buck_vc_fix_fq_adcch1_sel        = rarray_vs_buck_vc_fix_fq_adcch_sel[0]
        vs_buck_vc_fix_fq_adcch2_sel        = rarray_vs_buck_vc_fix_fq_adcch_sel[1]
        vs_buck_vc_fix_fq_adcch3_sel        = rarray_vs_buck_vc_fix_fq_adcch_sel[2]
        vs_buck_vc_fix_fq_adcch4_sel        = rarray_vs_buck_vc_fix_fq_adcch_sel[3]
        vs_buck_vc_fix_fq_adcch5_sel        = rarray_vs_buck_vc_fix_fq_adcch_sel[4]
        vs_buck_vc_fix_fq_adcch6_sel        = rarray_vs_buck_vc_fix_fq_adcch_sel[5]
        vs_buck_vc_fix_fq_adcch7_sel        = rarray_vs_buck_vc_fix_fq_adcch_sel[6]
        
        /*These signal are used for display in HW connectivity view*/
        vs_buck_vc_fix_fq_adcch1_iclass_sel = rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[0]
        vs_buck_vc_fix_fq_adcch2_iclass_sel = rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[1]
        vs_buck_vc_fix_fq_adcch3_iclass_sel = rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[2]
        vs_buck_vc_fix_fq_adcch4_iclass_sel = rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[3]
        vs_buck_vc_fix_fq_adcch5_iclass_sel = rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[4]
        vs_buck_vc_fix_fq_adcch6_iclass_sel = rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[5]
        vs_buck_vc_fix_fq_adcch7_iclass_sel = rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[6]
        
        /* ---------- 7 IO pad resource (channel pin) ------ */
        //Cant use rarray in @AddPin - DAVE MS limitation
        hwres_chan_a_pin = MVirtualResourceGroup("Vout pin", ["port", "p", "*", "pad", "*"], MF({rarray_gcheck_measure_entity[0].value },Boolean))
        hwres_chan_b_pin = MVirtualResourceGroup("Vin pin",  ["port", "p", "*", "pad", "*"], MF({rarray_gcheck_measure_entity[1].value  },Boolean))
        hwres_chan_c_pin = MVirtualResourceGroup("Iout1 pin",["port", "p", "*", "pad", "*"], MF({rarray_gcheck_measure_entity[2].value},Boolean))
        hwres_chan_d_pin = MVirtualResourceGroup("Iout2 pin",["port", "p", "*", "pad", "*"], MF({rarray_gcheck_measure_entity[3].value},Boolean))
        hwres_chan_e_pin = MVirtualResourceGroup("Iout3 pin",["port", "p", "*", "pad", "*"], MF({rarray_gcheck_measure_entity[4].value},Boolean))
        hwres_chan_f_pin = MVirtualResourceGroup("Iout4 pin",["port", "p", "*", "pad", "*"], MF({rarray_gcheck_measure_entity[5].value},Boolean))
        hwres_chan_g_pin = MVirtualResourceGroup(MF({gstring_udef1_measurement.value + " pin"},String),["port", "p", "*", "pad", "*"], MF({rarray_gcheck_measure_entity[6].value},Boolean))        
        
        /* ---------- NVIC node resource group for Vout Result Event ------ */
        hwres_nvicnode   = MVirtualResourceGroup("NVIC Node", ["peripheral", "cpu", "0", "nvic", "interrupt", "*"], MF({(gcombo_isr_event.value == "Vout Result Event")},Boolean))
        
        
        /* ---------- Virtual signal for VADC result event -------- */
        vs_result_event_out   = MVirtualSignal(rarray_hwres_result[0], "vout_result_event", "rev", true, false)
        
        /* ---------- Virtual signal for NVIC node -------- */
        vs_nvic_signal_in     = MVirtualSignal(hwres_nvicnode, "nvic_node", "signal_in", true, false)
        
        /* ---------- Virtual signal for PWM_CCU8 Phase 0 -------- */
        vs_pwm_ccu8_pm_out    = MVirtualSignalRA(appres_pwm_ccu8_1, "vs_ccu8_cc8_period_match_interrupt")
        
        /* ---------- Virtual signal for HRPWM Phase 0 -------- */
        vs_hrpwm_pm_out       = MVirtualSignalRA(appres_hrpwm_1, "vs_ccu8_cc8_period_match_interrupt")
        
        /* ---------- Virtual signals for IO pad resource (channel pin) ------ */
        @AddPin
        vs_buck_vc_fix_fq_adcch1_io  = MVirtualSignal(hwres_chan_a_pin, "vout_pin" , "pad",  MF({gcheck_measure_vout.value},Boolean), false)
        @AddPin
        vs_buck_vc_fix_fq_adcch2_io  = MVirtualSignal(hwres_chan_b_pin, "vin_pin", "pad",  MF({gcheck_measure_vin.value },Boolean), false)
        @AddPin
        vs_buck_vc_fix_fq_adcch3_io  = MVirtualSignal(hwres_chan_c_pin, "iout1_pin", "pad", MF({gcheck_measure_iout1.value},Boolean), false)
        @AddPin
        vs_buck_vc_fix_fq_adcch4_io  = MVirtualSignal(hwres_chan_d_pin, "iout2_pin", "pad", MF({gcheck_measure_iout2.value},Boolean), false)
        @AddPin
        vs_buck_vc_fix_fq_adcch5_io  = MVirtualSignal(hwres_chan_e_pin, "iout3_pin", "pad", MF({gcheck_measure_iout3.value},Boolean), false)
        @AddPin
        vs_buck_vc_fix_fq_adcch6_io  = MVirtualSignal(hwres_chan_f_pin, "iout4_pin", "pad", MF({gcheck_measure_iout4.value},Boolean), false)
        @AddPin
        vs_buck_vc_fix_fq_adcch7_io  = MVirtualSignal(hwres_chan_g_pin, MF({gstring_udef1_measurement.value+ "_pin"},String), "pad", MF({gcheck_measure_user_defined_1.value},Boolean), false)
        

        /* ---------------------------------------------------------- */
        /* -------------- APP IO Signals ---------------------------- */
        /* ---------------------------------------------------------- */
        
        /* Connection: IO pad <-> ADC channel */
        addConnectionConstraint(vs_buck_vc_fix_fq_adcch1_io, vs_buck_vc_fix_fq_adcch1, MF({gcheck_measure_vout.value            },Boolean))
        addConnectionConstraint(vs_buck_vc_fix_fq_adcch2_io, vs_buck_vc_fix_fq_adcch2, MF({gcheck_measure_vin.value             },Boolean))
        addConnectionConstraint(vs_buck_vc_fix_fq_adcch3_io, vs_buck_vc_fix_fq_adcch3, MF({gcheck_measure_iout1.value           },Boolean))
        addConnectionConstraint(vs_buck_vc_fix_fq_adcch4_io, vs_buck_vc_fix_fq_adcch4, MF({gcheck_measure_iout2.value           },Boolean))
        addConnectionConstraint(vs_buck_vc_fix_fq_adcch5_io, vs_buck_vc_fix_fq_adcch5, MF({gcheck_measure_iout3.value           },Boolean))
        addConnectionConstraint(vs_buck_vc_fix_fq_adcch6_io, vs_buck_vc_fix_fq_adcch6, MF({gcheck_measure_iout4.value           },Boolean))
        addConnectionConstraint(vs_buck_vc_fix_fq_adcch7_io, vs_buck_vc_fix_fq_adcch7, MF({gcheck_measure_user_defined_1.value  },Boolean))
    
        /* Connection: Scan <-> ADC channel [1-8] */
        for(i=0; i<7; i++)
        {
            int index = i;
            
            /* Connection: IO pad <-> ADC channel */
            //addConnectionConstraint(rarray_vs_buck_vc_fix_fq_adcch[index], rarray_vs_buck_vc_fix_fq_adcch[index], MF({rarray_gcheck_measure_entity[index].value},Boolean))
            
            /* Connection: ADC channel <-> Result reg */
            addConnectionConstraint(rarray_vs_buck_vc_fix_fq_adcch_ressel[index], rarray_vs_buck_vc_fix_fq_adcch_res[index], MF({rarray_gcheck_measure_entity[index].value},Boolean))
            
            /* Connection: Scan APP <-> ADC channel */
            addConnectionConstraint(rarray_vs_buck_vc_fix_fq_adc_scan[index],  rarray_vs_buck_vc_fix_fq_adcch_sel[index], MF({rarray_gcheck_measure_entity[index].value && (gcombo_adc_measurement_mode.value == "Scan")},Boolean))

            /* Connection: Queue APP <-> ADC channel */
            addConnectionConstraint(rarray_vs_buck_vc_fix_fq_adc_queue[index], rarray_vs_buck_vc_fix_fq_adcch_sel[index], MF({rarray_gcheck_measure_entity[index].value && (gcombo_adc_measurement_mode.value == "Queue")},Boolean))
            
            /*Connection: Scan APP iclass <-> ADC channel iclass */
            addConnectionConstraint(rarray_vs_buck_vc_fix_fq_adc_scan_iclass[index],  rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[index], MF({rarray_gcheck_measure_entity[index].value && (gcombo_adc_measurement_mode.value == "Scan")},Boolean))
            
            /*Connection: Queue APP iclass <-> ADC channel iclass */
            addConnectionConstraint(rarray_vs_buck_vc_fix_fq_adc_queue_iclass[index], rarray_vs_buck_vc_fix_fq_adcch_iclass_sel[index], MF({rarray_gcheck_measure_entity[index].value && (gcombo_adc_measurement_mode.value == "Queue")},Boolean))
           
            /* Connection: PWM_CCU8 Phase 0  <-> ADC_SCAN trigger */
            addConnectionConstraint(vs_pwm_ccu8_pm_out, rarray_vs_adc_scan_trigger_in[index],  MF({gcombo_mesurement_trigger.value == "PWM Timer (Phase 0)" && gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[index].value && (!gcheck_enable_high_res.value) && (gcombo_no_of_phases.value.toInteger() >= 1)},Boolean))
            
            /* Connection: HRPWM Phase 0     <-> ADC_SCAN trigger */
            addConnectionConstraint(vs_hrpwm_pm_out, rarray_vs_adc_scan_trigger_in[index],     MF({gcombo_mesurement_trigger.value == "PWM Timer (Phase 0)" && gcombo_adc_measurement_mode.value == "Scan" && rarray_gcheck_measure_entity[index].value && gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 1)},Boolean))
            
            /* Connection: PWM_CCU8 Phase 0  <-> ADC_QUEUE trigger */
            addConnectionConstraint(vs_pwm_ccu8_pm_out, rarray_vs_adc_queue_trigger_in[index], MF({gcombo_mesurement_trigger.value == "PWM Timer (Phase 0)" && gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[index].value && (!gcheck_enable_high_res.value) && (gcombo_no_of_phases.value.toInteger() >= 1)},Boolean))
            
            /* Connection: HRPWM Phase 0     <-> ADC_QUEUE trigger */
            addConnectionConstraint(vs_hrpwm_pm_out, rarray_vs_adc_queue_trigger_in[index],    MF({gcombo_mesurement_trigger.value == "PWM Timer (Phase 0)" && gcombo_adc_measurement_mode.value == "Queue" && rarray_gcheck_measure_entity[index].value && gcheck_enable_high_res.value && (gcombo_no_of_phases.value.toInteger() >= 1)},Boolean))
        }
        
        /* Connection: VADC result event <-> nvic node */
        addConnectionConstraint(vs_result_event_out, vs_nvic_signal_in, MF({ (gcombo_isr_event.value == "Vout Result Event") },Boolean))
        
        /* ---------------------------------------------------------- ---------------------------------------------------------------*/
        /* ---------- Target Specific User Variable Initialization ----------------------------------------------------------------- */
        /* ---------------------------------------------------------- ---------------------------------------------------------------*/
        
        /***********************************************************************************************************************
         * Tab: Buck converter configurations -
         **********************************************************************************************************************/
        gcheck_enable_high_res.visible          = MF({(is_4x_device)}, Boolean); /* No sw ids for 45, so this check ("XMC4") is enough */
                                        
        gimage_buck_topology.path               = MF({
                                                    if((gcheck_synch_conv.value == false) && (gcombo_no_of_phases.value == "1"))
                                                    {"doc/Buck_vcm_single_phase.png"}
                                                    else if((gcheck_synch_conv.value == true) && (gcombo_no_of_phases.value == "1"))
                                                    {"doc/Buck_vcm_single_phase_synch.png"}
                                                    else if ((gcheck_synch_conv.value == false) && (gcombo_no_of_phases.value != "1"))
                                                    {"doc/buck_n_phase.png"}
                                                    else
                                                    {"doc/buck_n_phase_synch.png"}
                                                    }, String)            
        
        gfloat_vout_ref.maxValue                = MF({
                                                    Float max_val;
                                                    max_val = gfloat_vin.value
                                                    return(max_val);
                                                    }, Float)
        
        /***********************************************************************************************************************
         * Tab: PWM configurations
         **********************************************************************************************************************/
        gimage_pwm.path             = MF({
                                        if(gcheck_enable_high_res.value == true)
                                        {"doc/pwm_hr.png"}
                                        else
                                        {"doc/pwm_ccu.png"}
                                        }, String)
        
        gfloat_pwm_res.minValue     = MF({
                                        if(gcheck_enable_high_res.value == true)                                        
                                        {(Float) 9} //retain default
                                        else
                                        {rarray_appres_pwm_ccu8[0].getVal(["gfloat_res", "minValue"])}
                                        }, Float)
        
        gfloat_pwm_res.maxValue     = MF({
                                        if(gcheck_enable_high_res.value == true)
                                        {(Float) 20000} //retain default
                                        else
                                        {rarray_appres_pwm_ccu8[0].getVal(["gfloat_res", "maxValue"])}
                                        }, Float)
        
        gfloat_pwm_res.enabled      = MF({(!gcheck_enable_high_res.value)}, Boolean)

        gfloat_dt_rising.minValue   = MF({
                                        Double min_val = 1000;
                                        if(gcheck_enable_high_res.value == true)
                                        {min_val = rarray_appres_hrpwm[0].getVal(["gfloat_hr_dt_rise", "minValue"])}
                                        else
                                        {min_val = rarray_appres_pwm_ccu8[0].getVal(["gfloat_ch1_dt_rise", "minValue"])}                                      
                                        return(min_val);
                                        }, Double)
        
        gfloat_dt_rising.maxValue   = MF({
                                        Double max_val = 1000;
                                        if(gcheck_enable_high_res.value == true)
                                        {max_val = rarray_appres_hrpwm[0].getVal(["gfloat_hr_dt_rise", "maxValue"])}
                                        else
                                        {max_val = rarray_appres_pwm_ccu8[0].getVal(["gfloat_ch1_dt_rise", "maxValue"])}
                                        return(max_val);
                                        }, Double)
        
        gfloat_dt_falling.minValue  = MF({
                                        Double min_val = 1000;
                                        if(gcheck_enable_high_res.value == true)
                                        {min_val = rarray_appres_hrpwm[0].getVal(["gfloat_hr_dt_fall", "minValue"])}
                                        else
                                        {min_val = rarray_appres_pwm_ccu8[0].getVal(["gfloat_ch1_dt_fall", "minValue"])}
                                        return(min_val);
                                        }, Double)
        
        gfloat_dt_falling.maxValue  = MF({
                                        Double max_val = 1000;
                                        if(gcheck_enable_high_res.value == true)
                                        {max_val = rarray_appres_hrpwm[0].getVal(["gfloat_hr_dt_fall", "maxValue"])}
                                        else
                                        {max_val = rarray_appres_pwm_ccu8[0].getVal(["gfloat_ch1_dt_fall", "maxValue"])}
                                        return(max_val);
                                        }, Double)
        
        ginteger_phase_shift.value  = MF({
                                        Integer max_val = 360;
                                        if(gcombo_no_of_phases.value == "1") {max_val = 0}
                                        else if (gcombo_no_of_phases.value == "2") {max_val = 180}
                                        else if (gcombo_no_of_phases.value == "3") {max_val = 120}
                                        else if (gcombo_no_of_phases.value == "4") {max_val = 90}
                                        return(max_val);
                                        }, Integer)
        
        gfloat_init_dc.minValue     = MF({
                                        Double min_val;
                                        min_val = gfloat_min_dc.value
                                        return(min_val);
                                        }, Double)
        
        gfloat_init_dc.maxValue     = MF({
                                        Double max_val;
                                        max_val = gfloat_max_dc.value
                                        return(max_val);
                                        }, Double)
        
        gfloat_min_dc.maxValue      = MF({
                                        Double min_val;
                                        min_val = gfloat_max_dc.value
                                        return(min_val);
                                        }, Double)
        
        gfloat_max_dc.minValue      = MF({
                                        Double max_val;
                                        max_val = gfloat_min_dc.value
                                        return(max_val);
                                        }, Double)
        
        /***********************************************************************************************************************
         * Push values to HRPWM App
         **********************************************************************************************************************/
        for(i=0; i<4; i++)
        {
            int index = i;
            
            /**
             * Push to HRPWM UI
             */
            
            //update frequency
            rarray_appres_hrpwm[index].setVal(["ginteger_freq", "value"], MF({ginteger_pwm_freq.value * 1000}, Integer))
            
            //update CCU8 compare1 value
            rarray_appres_hrpwm[index].setVal(["ginteger_cmp_ch1", "value"],
            MF({
                Integer num_of_phases = Integer.parseInt(gcombo_no_of_phases.value)
                Integer period_value
                Integer ccu8_compare1_value
                if((gcheck_enable_high_res.value == true) && (index < num_of_phases))
                {
                    period_value = rarray_appres_hrpwm[0].getVal(["ginteger_period", "value"])
                    ccu8_compare1_value = (Integer) ((period_value + 1) * (100 - gfloat_init_dc.value) / 100)
                }
                else
                {
                    ccu8_compare1_value = 100
                }
                return (ccu8_compare1_value);
            }, Integer))
            
            //update HRPWM compare1 value
            rarray_appres_hrpwm[index].setVal(["ginteger_hr_cmp1", "value"],
            MF({
                Integer num_of_phases = Integer.parseInt(gcombo_no_of_phases.value)
                Double hr_compare1_value = 0;
                Double period_value = 0;
                Double duty_ccu8 = 0;
                Integer ccu8_compare1_value = 0;
                Integer hr_compare1_max_value = 0;
                Float clock;
                
                if((gcheck_enable_high_res.value == true) && (index < num_of_phases))
                {
                    period_value = (Double) rarray_appres_hrpwm[0].getVal(["ginteger_period", "value"])
                    ccu8_compare1_value = (Integer) ((period_value + 1) * (100 - gfloat_init_dc.value) / 100)
                    clock = rarray_appres_hrpwm[0].getVal(["gfloat_clock", "value"])
                    duty_ccu8 = (Double)100 - ((Double)100 * ((Double)ccu8_compare1_value / (Double)(period_value+1)));
                    if((gfloat_init_dc.value - duty_ccu8) < 0)
                    {                        
                        hr_compare1_value =  (((period_value+1) * ((100 - gfloat_init_dc.value) / 100)) - ((Double)ccu8_compare1_value)) / ((Double)(clock * 150) / 2.power(0));
                        hr_compare1_value *= 1000000;                        
                    }
                    
                    hr_compare1_max_value = rarray_appres_hrpwm[0].getVal(["ginteger_hr_cmp1", "maxValue"])
                    if(hr_compare1_value > hr_compare1_max_value)
                    {
                        hr_compare1_value = hr_compare1_max_value;
                    }
                }
                else
                {
                    hr_compare1_value = 0
                }
                return ((Integer)hr_compare1_value);
            }, Integer))
            
            /*Set HRPWM compare 2 value to '0'*/
            rarray_appres_hrpwm[index].setVal(["ginteger_hr_cmp2", "value"],
            MF({
                Integer cmp_val = 0
                cmp_val = 0
                return (cmp_val);
            }, Integer))
            
            //Select Edge aligned mode
            rarray_appres_hrpwm[index].setVal(["gcombo_counting_mode", "value"], MF({"Edge Aligned"}, String))                                      
            //Select Symmetric mode
            rarray_appres_hrpwm[index].setVal(["gcombo_compare_mode", "value"], MF({"Symmetric"}, String))
            //Disable Initialize during startup
            rarray_appres_hrpwm[index].setVal(["gcheck_init_start", "value"], MF({false}, Boolean))
            //Disable single shot mode
            rarray_appres_hrpwm[index].setVal(["gcheck_single_shot", "value"], MF({false}, Boolean))
            
            //enable period match interrupt
            rarray_appres_hrpwm[index].setVal(["gcheck_int_per_match", "value"], MF({true}, Boolean))
            
            //select event0 function as external start
            rarray_appres_hrpwm[index].setVal(["gcombo_e0_fn", "value"], MF({"External Start"}, String))
            
            //select event0 low pass filter
            rarray_appres_hrpwm[index].setVal(["gcombo_e0_filter", "value"], MF({"No Filter"}, String))
            
            //enable synchronous start
            rarray_appres_hrpwm[index].setVal(["gcheck_sync_start", "value"], MF({true}, Boolean))
            
            //select active edge action for external start function
            rarray_appres_hrpwm[index].setVal(["gcombo_ext_start_action", "value"], MF({"Start Timer"}, String))
            
            //select e0 trigger edge as active
            rarray_appres_hrpwm[index].setVal(["gcombo_e0_trigger", "value"], MF({"Rising"}, String))
            
            //enable HRC direct output
            rarray_appres_hrpwm[index].setVal(["gcheck_hr_out0_enable", "value"], MF({true}, Boolean))
            
            //enable HRC indirect output for synchronous conversion
            rarray_appres_hrpwm[index].setVal(["gcheck_hr_out1_enable", "value"],
            MF({
                if(gcheck_synch_conv.value == true)
                {true}
                else
                {false}
            }, Boolean))
            
            //enable dead time
            rarray_appres_hrpwm[index].setVal(["gcheck_hr_dt_enable", "value"], MF({true}, Boolean))
            
            //update rising dead time
            rarray_appres_hrpwm[index].setVal(["gfloat_hr_dt_rise", "value"], MF({gfloat_dt_rising.value}, Float))
            
            //update falling dead time
            rarray_appres_hrpwm[index].setVal(["gfloat_hr_dt_fall", "value"], MF({gfloat_dt_falling.value}, Float))
            
            //select passive level for HRC direct output
            rarray_appres_hrpwm[index].setVal(["gcombo_hr_out0_pass_level", "value"],
            MF({
                if(gcombo_passive_lvl.value == "Low")
                {"Low"}
                else
                {"High"}
            }, String))
            
            //select passive level for HRC interted output
            rarray_appres_hrpwm[index].setVal(["gcombo_hr_out1_pass_level", "value"],
            MF({
                if(gcombo_passive_lvl.value == "Low")
                {"Low"}
                else
                {"High"}
            }, String))
            
            //enable high resolution path 
            rarray_appres_hrpwm[index].setVal(["gcheck_hr_enable", "value"],
            MF({
                Integer num_of_phases = Integer.parseInt(gcombo_no_of_phases.value)
                if(gcheck_enable_high_res.value && (index < num_of_phases))
                {true}
                else
                {true}
            }, Boolean))
            
            //select rising edge of HR path input as Set0 
            rarray_appres_hrpwm[index].setVal(["gcombo_hr_set0", "value"], MF({"Falling"}, String))
            
            //select falling edge of HR path input as Clear0 
            rarray_appres_hrpwm[index].setVal(["gcombo_hr_clear0", "value"], MF({"Rising"}, String))            
        }
        
       /***********************************************************************************************************************
        * Push values to PWM CCU8 App
        **********************************************************************************************************************/
        for(i=0; i<4; i++)
        {
            int index = i;
            
            /**
             * Push to PWM_CCU8 UI
             */
            
            //update frequency
            rarray_appres_pwm_ccu8[index].setVal(["ginteger_freq", "value"], MF({ginteger_pwm_freq.value * 1000}, Integer))
                
            //update resolution
            rarray_appres_pwm_ccu8[index].setVal(["gfloat_res", "value"], MF({gfloat_pwm_res.value}, Float))
            
            //update channel 1 duty cycle
            rarray_appres_pwm_ccu8[index].setVal(["gfloat_sym_duty_ch1", "value"], MF({gfloat_init_dc.value}, Float))
            
            //Select Edge aligned mode
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_counting_mode", "value"], MF({"Edge Aligned"}, String))
            //Select Symmetric mode
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_compare_mode", "value"], MF({"Symmetric"}, String))
            //Disable Initialize during startup
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_init_start", "value"], MF({false}, Boolean))
            //Disable single shot mode
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_single_shot", "value"], MF({false}, Boolean))
            //Select shadow transfer mode to Period match
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_shadow_txfr_mode", "value"], MF({"Period Match"}, String))
            //Select ST1 as status bit
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_status_bit", "value"], MF({"ST1"}, String))
            //Select Before Compare Match for Ch1 Passive level
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_ch1_out0_state", "value"], MF({"After Compare Match"}, String))
            //Select After Compare Match for Ch1 Passive level
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_ch1_out1_state", "value"], MF({"Before Compare Match"}, String))
            //Disable Multi channel1
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_mcm_ch1_enable", "value"], MF({false}, Boolean))
            //Disable Multi channel2
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_mcm_ch2_enable", "value"], MF({false}, Boolean))
            
            
            //enable period match interrupt
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_int_per_match", "value"], MF({true}, Boolean))
            
            //select event0 function as external start
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_e0_fn", "value"], MF({"External Start"}, String))
            
            //select event0 low pass filter
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_e0_filter", "value"], MF({"No Filter"}, String))
            
            //enable synchronous start
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_sync_start", "value"], MF({true}, Boolean))
            
            //select active edge action for external start function
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_ext_start_action", "value"], MF({"Start Timer"}, String))
            
            //select e0 trigger edge as active
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_e0_trigger", "value"], MF({"Rising"}, String))
            
            //enable channel 1 direct output
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_ch1_out0_enable", "value"], MF({true}, Boolean))
            
            //enable channel 1 inverted output
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_ch1_out1_enable", "value"], MF({true}, Boolean))
            
            //enable dead time
            rarray_appres_pwm_ccu8[index].setVal(["gcheck_ch1_dt_enable", "value"], MF({true}, Boolean))
            
            //update rising dead time
            rarray_appres_pwm_ccu8[index].setVal(["gfloat_ch1_dt_rise", "value"], MF({gfloat_dt_rising.value}, Float))
            
            //update falling dead time
            rarray_appres_pwm_ccu8[index].setVal(["gfloat_ch1_dt_fall", "value"], MF({gfloat_dt_falling.value}, Float))
            
            //select passive level for channel 1 direct output
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_ch1_out0_pass_level", "value"],
            MF({
                if(gcombo_passive_lvl.value == "Low")
                {"Low"}
                else
                {"High"}
            }, String))
            
            //select passive level for channel 1 inverted output
            rarray_appres_pwm_ccu8[index].setVal(["gcombo_ch1_out1_pass_level", "value"],
            MF({
                if(gcombo_passive_lvl.value == "Low")
                {"Low"}
                else
                {"High"}
            }, String))                                  
        }
        
        /***********************************************************************************************************************
         * Tab: ADC measurement configurations
         **********************************************************************************************************************/
        for(i=0; i<7; i++)
        {
            int index = i;            
            
            if((index == 0) || (index == 1) || (index == 2) || (index == 6)) //for vout, vin, iout1 and user_defined
            {
                rarray_gstring_measure_entity[index].enabled = MF({
                    if (rarray_gcheck_measure_entity[index].value == true)
                    {true}
                    else
                    {false}    
                    }, Boolean)
                rarray_gcombo_q_position[index].enabled      = MF({
                    if ((rarray_gcheck_measure_entity[index].value == true) && (gcombo_adc_measurement_mode.value == "Queue"))
                    {true}
                    else
                    {false}    
                    }, Boolean)
                
                if (index != 6) //divider gain is not applicable for 'User_Defined' measurement
                {
                rarray_gfloat_divider_gain[index].enabled    = MF({
                    if (rarray_gcheck_measure_entity[index].value == true)
                    {true}
                    else
                    {false}    
                    }, Boolean)
                }
            }
            else //for iout2, iout3, iout4
            {    
                rarray_gcheck_measure_entity[index].enabled  = MF({
                    Integer num_of_phases = Integer.parseInt(gcombo_no_of_phases.value)
                    if (num_of_phases > (index-2))
                    {true}
                    else
                    {false}
                    }, Boolean)
                rarray_gstring_measure_entity[index].enabled = MF({
                    Integer num_of_phases = Integer.parseInt(gcombo_no_of_phases.value)
                    if ((num_of_phases > (index-2)) && (rarray_gcheck_measure_entity[index].value == true))
                    {true}
                    else
                    {false}
                    }, Boolean)
                rarray_gcombo_q_position[index].enabled      = MF({
                    Integer num_of_phases = Integer.parseInt(gcombo_no_of_phases.value)
                    if ((num_of_phases > (index-2)) && (rarray_gcheck_measure_entity[index].value == true) && (gcombo_adc_measurement_mode.value == "Queue"))
                    {true}
                    else
                    {false}
                    }, Boolean)
                rarray_gfloat_divider_gain[index].enabled    = MF({
                    Integer num_of_phases = Integer.parseInt(gcombo_no_of_phases.value)
                    if ((num_of_phases > (index-2)) && (rarray_gcheck_measure_entity[index].value == true))
                    {true}
                    else
                    {false}
                    }, Boolean)
            }            
        }
            
        //Display only valid queue positions
        gcombo_vout_q_pos.options                       = MF({                                                                       
                                                            List l = ["0", "1", "2", "3", "4", "5", "6", "7"];                    
                                                                                        
                                                            String a = rarray_hwres_adcchan[0].getSolverUri()[6]                                    
                                                            if (gcheck_measure_vin.value)
                                                            {
                                                              String b = rarray_hwres_adcchan[1].getSolverUri()[6]
                                                              if (a == b) {l.remove(gcombo_vin_q_pos.value)}                                      
                                                            }
                                                            
                                                            if (gcheck_measure_iout1.value)
                                                            {
                                                              String c = rarray_hwres_adcchan[2].getSolverUri()[6]
                                                              if (a == c) {l.remove(gcombo_iout1_q_pos.value)}
                                                            }
                                                            
                                                            if (gcheck_measure_iout2.value)
                                                            {
                                                              String d = rarray_hwres_adcchan[3].getSolverUri()[6]
                                                              if (a == d) {l.remove(gcombo_iout2_q_pos.value)}
                                                            }
                                                            
                                                            if (gcheck_measure_iout3.value)
                                                            {
                                                              String e = rarray_hwres_adcchan[4].getSolverUri()[6]
                                                              if (a == e) {l.remove(gcombo_iout3_q_pos.value)}
                                                            }
                                                            
                                                            if (gcheck_measure_iout4.value)
                                                            {
                                                              String f = rarray_hwres_adcchan[5].getSolverUri()[6]
                                                              if (a == f) {l.remove(gcombo_iout4_q_pos.value)}
                                                            }
                                                            
                                                            if (gcheck_measure_user_defined_1.value)
                                                            {
                                                              String g = rarray_hwres_adcchan[6].getSolverUri()[6]
                                                              if (a == g) {l.remove(gcombo_adc_q_pos_user_defined_1.value)}
                                                            }                                                                        
                                                            return l; },List);
    
        gcombo_vin_q_pos.options                        = MF({
                                                            List l = ["0", "1", "2", "3", "4", "5", "6", "7"];
                                                            if (gcheck_measure_vin.value)
                                                            {                
                                                                String a = rarray_hwres_adcchan[0].getSolverUri()[6]
                                                                String b = rarray_hwres_adcchan[1].getSolverUri()[6]                
                                                                if (b == a) {l.remove(gcombo_vout_q_pos.value)}
                                                                
                                                                if (gcheck_measure_iout1.value)
                                                                {
                                                                  String c = rarray_hwres_adcchan[2].getSolverUri()[6]
                                                                  if (b == c) {l.remove(gcombo_iout1_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout2.value)
                                                                {
                                                                  String d = rarray_hwres_adcchan[3].getSolverUri()[6]
                                                                  if (b == d) {l.remove(gcombo_iout2_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout3.value)
                                                                {
                                                                  String e = rarray_hwres_adcchan[4].getSolverUri()[6]
                                                                  if (b == e) {l.remove(gcombo_iout3_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout4.value)
                                                                {
                                                                  String f = rarray_hwres_adcchan[5].getSolverUri()[6]
                                                                  if (b == f) {l.remove(gcombo_iout4_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_user_defined_1.value)
                                                                {
                                                                  String g = rarray_hwres_adcchan[6].getSolverUri()[6]
                                                                  if (b == g) {l.remove(gcombo_adc_q_pos_user_defined_1.value)}
                                                                }
                                                            }
                                                            return l; },List);
    
        gcombo_iout1_q_pos.options                      = MF({
                                                            List l = ["0", "1", "2", "3", "4", "5", "6", "7"];
                                                            if (gcheck_measure_iout1.value)
                                                            {                
                                                                String a = rarray_hwres_adcchan[0].getSolverUri()[6]
                                                                String c = rarray_hwres_adcchan[2].getSolverUri()[6]                
                                                                if (c == a) {l.remove(gcombo_vout_q_pos.value)}
                                                                
                                                                if (gcheck_measure_vin.value)
                                                                {
                                                                  String b = rarray_hwres_adcchan[1].getSolverUri()[6]
                                                                  if (c == b) {l.remove(gcombo_vin_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout2.value)
                                                                {
                                                                  String d = rarray_hwres_adcchan[3].getSolverUri()[6]
                                                                  if (c == d) {l.remove(gcombo_iout2_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout3.value)
                                                                {
                                                                  String e = rarray_hwres_adcchan[4].getSolverUri()[6]
                                                                  if (c == e) {l.remove(gcombo_iout3_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout4.value)
                                                                {
                                                                  String f = rarray_hwres_adcchan[5].getSolverUri()[6]
                                                                  if (c == f) {l.remove(gcombo_iout4_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_user_defined_1.value)
                                                                {
                                                                  String g = rarray_hwres_adcchan[6].getSolverUri()[6]
                                                                  if (c == g) {l.remove(gcombo_adc_q_pos_user_defined_1.value)}
                                                                }
                                                            }
                                                            return l; },List);
    
        gcombo_iout2_q_pos.options                      = MF({
                                                            List l = ["0", "1", "2", "3", "4", "5", "6", "7"];
                                                            if (gcheck_measure_iout2.value)
                                                            {                
                                                                String a = rarray_hwres_adcchan[0].getSolverUri()[6]
                                                                String d = rarray_hwres_adcchan[3].getSolverUri()[6]                
                                                                if (d == a) {l.remove(gcombo_vout_q_pos.value)}
                                                                
                                                                if (gcheck_measure_vin.value)
                                                                {
                                                                  String b = rarray_hwres_adcchan[1].getSolverUri()[6]
                                                                  if (d == b) {l.remove(gcombo_vin_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout1.value)
                                                                {
                                                                  String c = rarray_hwres_adcchan[2].getSolverUri()[6]
                                                                  if (d == c) {l.remove(gcombo_iout1_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout3.value)
                                                                {
                                                                  String e = rarray_hwres_adcchan[4].getSolverUri()[6]
                                                                  if (d == e) {l.remove(gcombo_iout3_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout4.value)
                                                                {
                                                                  String f = rarray_hwres_adcchan[5].getSolverUri()[6]
                                                                  if (d == f) {l.remove(gcombo_iout4_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_user_defined_1.value)
                                                                {
                                                                  String g = rarray_hwres_adcchan[6].getSolverUri()[6]
                                                                  if (d == g) {l.remove(gcombo_adc_q_pos_user_defined_1.value)}
                                                                }
                                                            }
                                                            return l; },List);
        
        gcombo_iout3_q_pos.options                      = MF({
                                                            List l = ["0", "1", "2", "3", "4", "5", "6", "7"];
                                                            if (gcheck_measure_iout3.value)
                                                            {                
                                                                String a = rarray_hwres_adcchan[0].getSolverUri()[6]
                                                                String e = rarray_hwres_adcchan[4].getSolverUri()[6]                
                                                                if (e == a) {l.remove(gcombo_vout_q_pos.value)}
                                                                
                                                                if (gcheck_measure_vin.value)
                                                                {
                                                                  String b = rarray_hwres_adcchan[1].getSolverUri()[6]
                                                                  if (e == b) {l.remove(gcombo_vin_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout1.value)
                                                                {
                                                                  String c = rarray_hwres_adcchan[2].getSolverUri()[6]
                                                                  if (e == c) {l.remove(gcombo_iout1_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout2.value)
                                                                {
                                                                  String d = rarray_hwres_adcchan[3].getSolverUri()[6]
                                                                  if (e == d) {l.remove(gcombo_iout2_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout4.value)
                                                                {
                                                                  String f = rarray_hwres_adcchan[5].getSolverUri()[6]
                                                                  if (e == f) {l.remove(gcombo_iout4_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_user_defined_1.value)
                                                                {
                                                                  String g = rarray_hwres_adcchan[6].getSolverUri()[6]
                                                                  if (e == g) {l.remove(gcombo_adc_q_pos_user_defined_1.value)}
                                                                }
                                                            }
                                                            return l; },List);
    
        gcombo_iout4_q_pos.options                      = MF({
                                                            List l = ["0", "1", "2", "3", "4", "5", "6", "7"];
                                                            if (gcheck_measure_iout4.value)
                                                            {                
                                                                String a = rarray_hwres_adcchan[0].getSolverUri()[6]
                                                                String f = rarray_hwres_adcchan[5].getSolverUri()[6]                
                                                                if (f == a) {l.remove(gcombo_vout_q_pos.value)}
                                                                
                                                                if (gcheck_measure_vin.value)
                                                                {
                                                                  String b = rarray_hwres_adcchan[1].getSolverUri()[6]
                                                                  if (f == b) {l.remove(gcombo_vin_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout1.value)
                                                                {
                                                                  String c = rarray_hwres_adcchan[2].getSolverUri()[6]
                                                                  if (f == c) {l.remove(gcombo_iout1_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout2.value)
                                                                {
                                                                  String d = rarray_hwres_adcchan[3].getSolverUri()[6]
                                                                  if (f == d) {l.remove(gcombo_iout2_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout3.value)
                                                                {
                                                                  String e = rarray_hwres_adcchan[4].getSolverUri()[6]
                                                                  if (f == e) {l.remove(gcombo_iout3_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_user_defined_1.value)
                                                                {
                                                                  String g = rarray_hwres_adcchan[6].getSolverUri()[6]
                                                                  if (f == g) {l.remove(gcombo_adc_q_pos_user_defined_1.value)}
                                                                }
                                                            }
                                                            return l; },List);
    
        gcombo_adc_q_pos_user_defined_1.options         = MF({
                                                            List l = ["0", "1", "2", "3", "4", "5", "6", "7"];
                                                            if (gcheck_measure_user_defined_1.value)
                                                            {                
                                                                String a = rarray_hwres_adcchan[0].getSolverUri()[6]
                                                                String g = rarray_hwres_adcchan[6].getSolverUri()[6]                
                                                                if (g == a) {l.remove(gcombo_vout_q_pos.value)}
                                                                
                                                                if (gcheck_measure_vin.value)
                                                                {
                                                                  String b = rarray_hwres_adcchan[1].getSolverUri()[6]
                                                                  if (g == b) {l.remove(gcombo_vin_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout1.value)
                                                                {
                                                                  String c = rarray_hwres_adcchan[2].getSolverUri()[6]
                                                                  if (g == c) {l.remove(gcombo_iout1_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout2.value)
                                                                {
                                                                  String d = rarray_hwres_adcchan[3].getSolverUri()[6]
                                                                  if (g == d) {l.remove(gcombo_iout2_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout3.value)
                                                                {
                                                                  String e = rarray_hwres_adcchan[4].getSolverUri()[6]
                                                                  if (g == e) {l.remove(gcombo_iout3_q_pos.value)}
                                                                }
                                                
                                                                if (gcheck_measure_iout4.value)
                                                                {
                                                                  String f = rarray_hwres_adcchan[5].getSolverUri()[6]
                                                                  if (g == f) {l.remove(gcombo_iout4_q_pos.value)}
                                                                }
                                                            }            
                                                            return l; },List);
    
        /*String for validating the string entered as callback function name*/
        gmessage_measurements.visible                     = MF({
                                                            String fn_regexp = ~/^[^\d\W]\w*\Z/
                                                            Matcher matcher_tx_vout  = (gstring_vout_measurement.value  =~ fn_regexp)
                                                            Matcher matcher_tx_vin   = (gstring_vin_measurement.value   =~ fn_regexp)
                                                            Matcher matcher_tx_iout1 = (gstring_iout1_measurement.value =~ fn_regexp)
                                                            Matcher matcher_tx_iout2 = (gstring_iout2_measurement.value =~ fn_regexp)
                                                            Matcher matcher_tx_iout3 = (gstring_iout3_measurement.value =~ fn_regexp)
                                                            Matcher matcher_tx_iout4 = (gstring_iout4_measurement.value =~ fn_regexp)
                                                            Matcher matcher_tx_udef1 = (gstring_udef1_measurement.value =~ fn_regexp)
                                                            Boolean ExpressionMatch_tx = (!matcher_tx_vout.matches()) || (!matcher_tx_vin.matches()) || (!matcher_tx_iout1.matches()) || (!matcher_tx_iout2.matches()) || (!matcher_tx_iout3.matches()) || (!matcher_tx_iout4.matches()) || (!matcher_tx_udef1.matches())
                                                            /*if(gstring_int_handler_cntrl_loop.visible && gstring_int_handler_cntrl_loop.enabled){return ExpressionMatch_tx} else{ return false}*/
                                                            return ExpressionMatch_tx;
                                                            },Boolean)
        /***********************************************************************************************************************
         * Tab: Control Settings
         **********************************************************************************************************************/
        gimage_filter.path                  = MF({
                                                if(gcombo_controller_type.value == "Type II (2P2Z)")
                                                {"doc/filter_2p2z.png"}
                                                else
                                                {"doc/filter_3p3z.png"}
                                                }, String)
        
        /* Show only for XMC1x */
        ggroup_filter_var_format.visible    = MF({ if(!is_4x_device) {true} else {false} }, Boolean)
        
        /* Show only for Type2 & Type3 filter */
        glabel_b0.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        gfloat_b0.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        glabel_b1.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        gfloat_b1.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        glabel_b2.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        gfloat_b2.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        glabel_a1.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        gfloat_a1.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        glabel_a2.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)
        gfloat_a2.visible                   = MF({ if((gcombo_controller_type.value == "Type III (3P3Z)") || (gcombo_controller_type.value == "Type II (2P2Z)")) {true} else {false} }, Boolean)        
        
        /* Show only for Type3 filter */
        glabel_a3.visible                   = MF({ if(gcombo_controller_type.value == "Type III (3P3Z)") {true} else {false} }, Boolean)
        gfloat_a3.visible                   = MF({ if(gcombo_controller_type.value == "Type III (3P3Z)") {true} else {false} }, Boolean)
        glabel_b3.visible                   = MF({ if(gcombo_controller_type.value == "Type III (3P3Z)") {true} else {false} }, Boolean)
        gfloat_b3.visible                   = MF({ if(gcombo_controller_type.value == "Type III (3P3Z)") {true} else {false} }, Boolean)        
        
        /* min range for 13x device co-efficients */
        gfloat_b0.minValue                  = MF({if(!is_4x_device && gfloat_b0.visible) {(Float)-32.0}else{(Float)-2047.0}},Float);
        gfloat_b1.minValue                  = MF({if(!is_4x_device && gfloat_b1.visible) {(Float)-32.0}else{(Float)-2047.0}},Float);
        gfloat_b2.minValue                  = MF({if(!is_4x_device && gfloat_b2.visible) {(Float)-32.0}else{(Float)-2047.0}},Float);
        gfloat_b3.minValue                  = MF({if(!is_4x_device && gfloat_b3.visible) {(Float)-32.0}else{(Float)-2047.0}},Float);
        gfloat_a3.minValue                  = MF({if(!is_4x_device && gfloat_a3.visible) {(Float)-32.0}else{(Float)-2047.0}},Float);
        gfloat_a2.minValue                  = MF({if(!is_4x_device && gfloat_a2.visible) {(Float)-32.0}else{(Float)-2047.0}},Float);
        gfloat_a1.minValue                  = MF({if(!is_4x_device && gfloat_a1.visible) {(Float)-32.0}else{(Float)-2047.0}},Float);
          
        /* max range for 13x device co-efficients */
        gfloat_b0.maxValue                  = MF({if(!is_4x_device && gfloat_b0.visible) {(Float)31.0}else{(Float)2047.0}},Float);
        gfloat_b1.maxValue                  = MF({if(!is_4x_device && gfloat_b1.visible) {(Float)31.0}else{(Float)2047.0}},Float);
        gfloat_b2.maxValue                  = MF({if(!is_4x_device && gfloat_b2.visible) {(Float)31.0}else{(Float)2047.0}},Float);
        gfloat_b3.maxValue                  = MF({if(!is_4x_device && gfloat_b3.visible) {(Float)31.0}else{(Float)2047.0}},Float);
        gfloat_a3.maxValue                  = MF({if(!is_4x_device && gfloat_a3.visible) {(Float)31.0}else{(Float)2047.0}},Float);
        gfloat_a2.maxValue                  = MF({if(!is_4x_device && gfloat_a2.visible) {(Float)31.0}else{(Float)2047.0}},Float);
        gfloat_a1.maxValue                  = MF({if(!is_4x_device && gfloat_a1.visible) {(Float)31.0}else{(Float)2047.0}},Float);

        if (is_4x_device == true)
        {           
            glabel_note_fixed_pt_calc.text  = "Note: Control loop will be calculated in float."
        }
        else /* for XMC1x */
        {
            /* PWM settings */
            ginteger_pwm_freq.value         = 130
            
            /* default compensator co-efficient values */           
            gfloat_b0.value                 = 0.931556870226
            gfloat_b1.value                 = -0.850635601247
            gfloat_b2.value                 = -0.930691696019
            gfloat_b3.value                 = 0.851500775454
            gfloat_a1.value                 = 1.419289001908
            gfloat_a2.value                 = -0.276896131758
            gfloat_a3.value                 = -0.14239287015                                
        }
        
        /* K */
        gfloat_k_gain.value               = MF({
                                                float value = 0;
                                                if (gcheck_enable_high_res.value == true) /* family is XMC4x */
                                                {
                                                    /* K = (1/Vout divider ratio)*(CCU8 Period Value * 256)*(ADC ref voltage/2^ADC_bits-1), Here 256 is for High Res */ 
                                                    value = (gfloat_adc_ref_voltage.value * (appres_hrpwm_1.getVal(["ginteger_period", "value"])+1) * 256) / (gfloat_vout_gain.value * ((2.power(ginteger_adc_num_bits.value))-1));
                                                }
                                                else /* family is either XMC4x or XMC1x */
                                                {
                                                    /* K = (1/Vout divider ratio)*(CCU8 Period Value)*(ADC ref voltage/2^ADC_bits-1) */
                                                    value = (gfloat_adc_ref_voltage.value * (appres_pwm_ccu8_1.getVal(["ginteger_period", "value"])+1)) / (gfloat_vout_gain.value * ((2.power(ginteger_adc_num_bits.value))-1));
                                                }
                                                return (value);
                                                },Float)
        
        /* set default UI vale */
        gfloat_max_out.value              = MF({
                                                float value = 0;
                                                
                                                if (gcheck_enable_high_res.value == true)
                                                {
                                                    value = (gfloat_max_dc.value) * (appres_hrpwm_1.getVal(["ginteger_period", "value"])+1) / 100
                                                }
                                                else
                                                {
                                                    value = (gfloat_max_dc.value) * (appres_pwm_ccu8_1.getVal(["ginteger_period", "value"])+1) / 100
                                                }
                                                return (value);
                                                },Float);
                                            
        gfloat_min_out.value              = MF({
                                                float value = 0;
                                                
                                                if (gcheck_enable_high_res.value == true)
                                                {
                                                    value = (gfloat_min_dc.value) * (appres_hrpwm_1.getVal(["ginteger_period", "value"])+1) / 100
                                                }
                                                else
                                                {
                                                    value = (gfloat_min_dc.value) * (appres_pwm_ccu8_1.getVal(["ginteger_period", "value"])+1) / 100
                                                }
                                                return (value);
                                                },Float);
        
        /* Calculation of number of integer bits for B coefficient of Type II / Type III compensator */
        /* Biggest abs BxK coeff B_iq -> IQ int */
        ginteger_b_coeffs_int_bits.value  = MF({
                                                float max_b = 0;
                                                Integer value = 0;
                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    value = Math.ceil((Math.log(gfloat_bxk_max_abs.value)/Math.log(2)))
                                                }
                                                return (value);
                                                }, Integer)
        
        /* Calculation of number of fractional bits for B coefficient of Type II / Type III compensator */
        /* Biggest abs BxK coeff B_iq -> IQ frac */
        ginteger_b_coeffs_fract_bits.value = MF({
                                                Integer value = 0;
                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    value = 32 - 1 - Math.ceil((Math.log(gfloat_wcase_bke.value + gfloat_wcase_au.value)/Math.log(2)))
                                                }
                                                return (value);
                                                }, Integer)
        
        /* Calculation of number of integer bits for A coefficient of Type II / Type III compensator */
        /* Biggest abs A coeff A_iq -> IQ int */
        ginteger_a_coeffs_int_bits.value  = MF({
                                                float max_a = 0;
                                                Integer value = 0;
                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {    
                                                    value = Math.ceil((Math.log(gfloat_a_max_abs.value)/Math.log(2)))
                                                }
                                                return (value);
                                                }, Integer)
        
        /* Calculation of number of fractional bits for A coefficient of Type II / Type III compensator */
        ginteger_a_coeffs_fract_bits.maxValue = MF({
                                                Integer value = 31;
                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {    
                                                    value = 32 - 1 - Math.ceil((Math.log(gfloat_wcase_au.value)/Math.log(2)))
                                                }
                                                return (value);
                                                }, Integer)
        
        /* Calculation of number of integer bits for Output coefficient of Type II / Type III compensator */
        /* Biggest U i.e. PWM limit   U_iq -> IQ int */
        ginteger_comp_output_int_bits.value   = MF({
                                                float max_a = 0;
                                                Integer value = 0;
                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {    
                                                    value = Math.ceil((Math.log(gfloat_max_out.value)/Math.log(2)))
                                                }
                                                return (value);
                                                }, Integer)
        
        /* Calculation of number of fractional bits for Output coefficient of Type II / Type III compensator */
        /* Biggest U i.e. PWM limit   U_iq -> IQ frac */
        ginteger_comp_output_fract_bits.value = MF({
                                                      Integer value = 0;
                                                    if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                    {
                                                        value = (32 - 1 - Math.ceil((Math.log(gfloat_wcase_au.value)/Math.log(2)))) - ginteger_a_coeffs_fract_bits.value 
                                                    }
                                                    return(value);
                                                    }, Integer)
        
        /* Biggest abs BxK coeff B_iq -> max value */
        gfloat_bxk_max_abs.value          = MF({
                                                float max_abs_bxk = 0;                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    if(gcombo_controller_type.value == "Type II (2P2Z)")
                                                        {max_abs_bxk = Math.max(Math.max(Math.abs(gfloat_b0.value), Math.abs(gfloat_b1.value)), Math.abs(gfloat_b2.value))}
                                                    else if(gcombo_controller_type.value == "Type III (3P3Z)")
                                                        {max_abs_bxk = Math.max(Math.max(Math.abs(gfloat_b0.value), Math.abs(gfloat_b1.value)), Math.max(Math.abs(gfloat_b2.value), Math.abs(gfloat_b3.value)))}
                                                        
                                                    max_abs_bxk =    max_abs_bxk*gfloat_k_gain.value;
                                                }
                                                return (max_abs_bxk);
                                                }, Float)
        
        /* Biggest abs A coeff A_iq -> max value */
        gfloat_a_max_abs.value            = MF({
                                                float max_abs_a = 0;                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    if(gcombo_controller_type.value == "Type II (2P2Z)")
                                                        {max_abs_a = Math.max(Math.abs(gfloat_a1.value), Math.abs(gfloat_a2.value))}
                                                    else if(gcombo_controller_type.value == "Type III (3P3Z)")
                                                        {max_abs_a = Math.max(Math.max(Math.abs(gfloat_a1.value), Math.abs(gfloat_a2.value)), Math.abs(gfloat_a3.value))}                                            
                                                }
                                                return (max_abs_a);
                                                }, Float)
        
        /* worst case of B[]KE[] */
        gfloat_wcase_bke.value            = MF({
                                                float value   = 0;                                                
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {   
                                                    float is_b3_valid = 1; /* valid for typeIII */                        
                                                    if (gcombo_controller_type.value == "Type II (2P2Z)") {is_b3_valid = 0} /* invalid for typeII */
                                                                                                    
                                                    float B0_k = gfloat_b0.value * gfloat_k_gain.value
                                                    float B1_k = gfloat_b1.value * gfloat_k_gain.value
                                                    float B2_k = gfloat_b2.value * gfloat_k_gain.value
                                                    float B3_k = gfloat_b3.value * gfloat_k_gain.value
                                                    
                                                    float B0_k_min_e = B0_k * ginteger_min_error.value
                                                    float B0_k_max_e = B0_k * ginteger_max_error.value
                                                    float B1_k_min_e = B1_k * ginteger_min_error.value
                                                    float B1_k_max_e = B1_k * ginteger_max_error.value
                                                    float B2_k_min_e = B2_k * ginteger_min_error.value
                                                    float B2_k_max_e = B2_k * ginteger_max_error.value
                                                    float B3_k_min_e = B3_k * ginteger_min_error.value * is_b3_valid /* make coeff B3 valid only for typeIII */
                                                    float B3_k_max_e = B3_k * ginteger_max_error.value * is_b3_valid /* make coeff B3 valid only for typeIII */
                                                    
                                                    float min_sum = Math.min(B0_k_min_e, B0_k_max_e)+Math.min(B1_k_min_e, B1_k_max_e)+Math.min(B2_k_min_e, B2_k_max_e)+Math.min(B3_k_min_e, B3_k_max_e)
                                                    float max_sum = Math.max(B0_k_min_e, B0_k_max_e)+Math.max(B1_k_min_e, B1_k_max_e)+Math.max(B2_k_min_e, B2_k_max_e)+Math.max(B3_k_min_e, B3_k_max_e)
                                                    value = Math.max(Math.abs(min_sum), Math.abs(max_sum))
                                                }
                                                return (value);
                                                }, Float)
        
        /* worst case of A[]U[] */
        gfloat_wcase_au.value             = MF({
                                                float value   = 0;
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    float is_a3_valid = 1; /* valid for typeIII */
                                                    if (gcombo_controller_type.value == "Type II (2P2Z)") {is_a3_valid = 0} /* invalid for typeII */
                                                    
                                                    float A1_min_e = gfloat_a1.value * gfloat_max_out.value * -1
                                                    float A1_max_e = gfloat_a1.value * gfloat_max_out.value
                                                    float A2_min_e = gfloat_a2.value * gfloat_max_out.value * -1
                                                    float A2_max_e = gfloat_a2.value * gfloat_max_out.value
                                                    float A3_min_e = gfloat_a3.value * gfloat_max_out.value * -1 * is_a3_valid /* make coeff A3 valid only for typeIII */
                                                    float A3_max_e = gfloat_a3.value * gfloat_max_out.value      * is_a3_valid /* make coeff A3 valid only for typeIII */
                                                    
                                                    float min_sum = Math.min(A1_min_e, A1_max_e)+Math.min(A2_min_e, A2_max_e)+Math.min(A3_min_e, A3_max_e)
                                                    float max_sum = Math.max(A1_min_e, A1_max_e)+Math.max(A2_min_e, A2_max_e)+Math.max(A3_min_e, A3_max_e)
                                                    value = Math.max(Math.abs(min_sum), Math.abs(max_sum))
                                                }
                                                return (value);
                                                }, Float)        
        
        /* REF */
        ginteger_ref.value                = MF({
                                                Integer value = 0;
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    value = gfloat_vout_ref.value * gfloat_vout_gain.value * ((2.power(ginteger_adc_num_bits.value))-1)/(gfloat_adc_ref_voltage.value)
                                                }
                                                return (value);
                                                }, Integer)
        
        /* MAX E */
        ginteger_max_error.value          = MF({
                                                Integer value = 0;
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    value = ginteger_ref.value - 0
                                                }
                                                return (value);
                                                }, Integer)
        
        /* MIN E */
        ginteger_min_error.value          = MF({
                                                Integer value = 0;
                                                if ((is_4x_device == false) && (gcombo_controller_type.value != "PI")) /* Execute only for XMC1x family and if compensator is Type II or Type III */
                                                {
                                                    value = ginteger_ref.value - ((2.power(ginteger_adc_num_bits.value))-1)   
                                                }
                                                return (value);
                                                }, Integer)
        
        /***********************************************************************************************************************
         * Tab: Control configurations (Soft start)
         **********************************************************************************************************************/
        ggroup_user_code.visible            = MF({gcheck_user_code.value}, Boolean)
        ginteger_soft_start_val.enabled     = MF({gcheck_soft_start.value}, Boolean)
        
        ginteger_soft_start_val.minValue    = MF({
                                                Integer value = 0;
                                                if (gcheck_soft_start.value)
                                                    {value = appres_systimer.getVal(["ginteger_systickinterval", "value"])}
                                                else
                                                    {value = 1500}
                                                return (value);
                                                }, Integer)
        
        gimage_control_config.path          = MF({
                                                if(gcheck_vin_feed_fwd.value)
                                                {"doc/buck_control_config_with_ff.png"}
                                                else
                                                {"doc/buck_control_config_without_ff.png"}
                                                }, String)
        
        gcheck_vin_feed_fwd.enabled         = MF({gcheck_measure_vin.value}, Boolean)
        
        /*String for validating the string entered as callback function name*/
        gmessage_user_callback.visible         = MF({
                                                String fn_regexp = ~/^[^\d\W]\w*\Z/
                                                Matcher matcher_tx = (gstring_user_code.value =~ fn_regexp)
                                                Boolean ExpressionMatch_tx = !matcher_tx.matches()
                                                if(ggroup_user_code.visible){ return ExpressionMatch_tx} else{ return false}
                                                },Boolean)
        
        /***********************************************************************************************************************
         * Tab: Overload protections
         **********************************************************************************************************************/
        glabel_overload_protect_vout.text   = MF({gstring_vout_measurement.value + " [V]"}, String)
        glabel_overload_protect_vin.text    = MF({gstring_vin_measurement.value + " [V]"}, String)
        glabel_overload_protect_iout1.text  = MF({gstring_iout1_measurement.value + " [A]"}, String)
        glabel_overload_protect_iout2.text  = MF({gstring_iout2_measurement.value + " [A]"}, String)
        glabel_overload_protect_iout3.text  = MF({gstring_iout3_measurement.value + " [A]"}, String)
        glabel_overload_protect_iout4.text  = MF({gstring_iout4_measurement.value + " [A]"}, String)
        
        gcheck_sw_protection_vout.enabled   = MF({(gcheck_measure_vout.value == true)},Boolean)
        gcheck_sw_protection_vin.enabled    = MF({(gcheck_measure_vin.value == true)},Boolean)
        gcheck_sw_protection_iout1.enabled  = MF({(gcheck_measure_iout1.value == true)},Boolean)
        gcheck_sw_protection_iout2.enabled  = MF({(gcheck_measure_iout2.value == true) && (gcombo_no_of_phases.value.toInteger() >= 2)},Boolean)
        gcheck_sw_protection_iout3.enabled  = MF({(gcheck_measure_iout3.value == true) && (gcombo_no_of_phases.value.toInteger() >= 3)},Boolean)
        gcheck_sw_protection_iout4.enabled  = MF({(gcheck_measure_iout4.value == true) && (gcombo_no_of_phases.value.toInteger() >= 4)},Boolean)
        
        gfloat_high_limit_vout.enabled      = MF({(gcheck_measure_vout.value == true)},Boolean)
        gfloat_high_limit_vin.enabled       = MF({(gcheck_measure_vin.value == true)},Boolean)
        gfloat_high_limit_iout1.enabled     = MF({(gcheck_measure_iout1.value == true)},Boolean)
        gfloat_high_limit_iout2.enabled     = MF({(gcheck_measure_iout2.value == true) && (gcombo_no_of_phases.value.toInteger() >= 2)},Boolean)
        gfloat_high_limit_iout3.enabled     = MF({(gcheck_measure_iout3.value == true) && (gcombo_no_of_phases.value.toInteger() >= 3)},Boolean)
        gfloat_high_limit_iout4.enabled     = MF({(gcheck_measure_iout4.value == true) && (gcombo_no_of_phases.value.toInteger() >= 4)},Boolean)
        
        gfloat_low_limit_vout.enabled       = MF({(gcheck_measure_vout.value == true)},Boolean)
        gfloat_low_limit_vin.enabled        = MF({(gcheck_measure_vin.value == true)},Boolean)
        gfloat_low_limit_iout1.enabled      = MF({(gcheck_measure_iout1.value == true)},Boolean)
        gfloat_low_limit_iout2.enabled      = MF({(gcheck_measure_iout2.value == true) && (gcombo_no_of_phases.value.toInteger() >= 2)},Boolean)
        gfloat_low_limit_iout3.enabled      = MF({(gcheck_measure_iout3.value == true) && (gcombo_no_of_phases.value.toInteger() >= 3)},Boolean)
        gfloat_low_limit_iout4.enabled      = MF({(gcheck_measure_iout4.value == true) && (gcombo_no_of_phases.value.toInteger() >= 4)},Boolean)
        
        gcombo_protection_reaction_vout.enabled   = MF({(gcheck_measure_vout.value == true)},Boolean)
        gcombo_protection_reaction_vin.enabled    = MF({(gcheck_measure_vin.value == true)},Boolean)
        gcombo_protection_reaction_iout1.enabled  = MF({(gcheck_measure_iout1.value == true)},Boolean)
        gcombo_protection_reaction_iout2.enabled  = MF({(gcheck_measure_iout2.value == true) && (gcombo_no_of_phases.value.toInteger() >= 2)},Boolean)
        gcombo_protection_reaction_iout3.enabled  = MF({(gcheck_measure_iout3.value == true) && (gcombo_no_of_phases.value.toInteger() >= 3)},Boolean)
        gcombo_protection_reaction_iout4.enabled  = MF({(gcheck_measure_iout4.value == true) && (gcombo_no_of_phases.value.toInteger() >= 4)},Boolean)
        
        float ref_value = 3.3 
        
        gfloat_high_limit_vout.minValue     = MF({gfloat_low_limit_vout.value},Float)
        gfloat_high_limit_vin.minValue      = MF({gfloat_low_limit_vin.value},Float)
        gfloat_high_limit_iout1.minValue    = MF({gfloat_low_limit_iout1.value},Float)
        gfloat_high_limit_iout2.minValue    = MF({gfloat_low_limit_iout2.value},Float)
        gfloat_high_limit_iout3.minValue    = MF({gfloat_low_limit_iout3.value},Float)
        gfloat_high_limit_iout4.minValue    = MF({gfloat_low_limit_iout4.value},Float)
        
        gfloat_high_limit_vout.maxValue     = MF({ref_value/gfloat_vout_gain.value},Float)
        gfloat_high_limit_vin.maxValue      = MF({ref_value/gfloat_vin_gain.value},Float)
        gfloat_high_limit_iout1.maxValue    = MF({ref_value/gfloat_iout1_gain.value},Float)
        gfloat_high_limit_iout2.maxValue    = MF({ref_value/gfloat_iout2_gain.value},Float)
        gfloat_high_limit_iout3.maxValue    = MF({ref_value/gfloat_iout3_gain.value},Float)
        gfloat_high_limit_iout4.maxValue    = MF({ref_value/gfloat_iout4_gain.value},Float)
        
        gfloat_low_limit_vout.maxValue      = MF({ref_value/gfloat_vout_gain.value},Float)
        gfloat_low_limit_vin.maxValue       = MF({ref_value/gfloat_vin_gain.value},Float)
        gfloat_low_limit_iout1.maxValue     = MF({ref_value/gfloat_iout1_gain.value},Float)
        gfloat_low_limit_iout2.maxValue     = MF({ref_value/gfloat_iout2_gain.value},Float)
        gfloat_low_limit_iout3.maxValue     = MF({ref_value/gfloat_iout3_gain.value},Float)
        gfloat_low_limit_iout4.maxValue     = MF({ref_value/gfloat_iout4_gain.value},Float)
        
        /***********************************************************************************************************************
         * Tab: Interrupt Configurations
         **********************************************************************************************************************/
        ginterruptprio_cntrl_loop.enabled               = MF({gcombo_isr_event.value == "Vout Result Event"},Boolean)
        
        /* disable sub priority for XMC13 device */
        ginterruptprio_cntrl_loop.subPriorityVisible    = MF({(is_4x_device)},Boolean);            
        
        ginterruptprio_cntrl_loop.priorityValue         = MF({
                                                            Integer priority = 61
                                                            if (is_4x_device)
                                                            {priority = 61}
                                                            else
                                                            {priority = 1}
                                                            return priority
                                                            },Integer);
    
        ginterruptprio_cntrl_loop.maxPriority           = MF({
                                                            Integer priority = 63
                                                            if ((is_4x_device) && (gcombo_isr_event.value == "Vout Result Event")) // (true) && (true)
                                                            {                
                                                                priority = appres_cpu_4x.getVal(["gint_maxInterruptPreemptPriority", "value"]).toInteger()
                                                            }
                                                            else if ((is_4x_device) && (gcombo_isr_event.value != "Vout Result Event")) // (true) && (false)
                                                            {
                                                                priority = 63;
                                                            }
                                                            else if ((!is_4x_device) && (gcombo_isr_event.value == "Vout Result Event")) // (false) && (true)
                                                            {                
                                                                priority = appres_cpu_1x.getVal(["gint_maxInterruptPreemptPriority", "value"]).toInteger()
                                                            }                    
                                                            else // if ((!is_4x_device) && (gcombo_isr_event.value != "Vout Result Event")) // (false) && (false)
                                                            {
                                                                priority = 3;
                                                            }
                                                            return priority
                                                            }, Integer)
            
        ginterruptprio_cntrl_loop.maxSubPriority        =  MF({
                                                            Integer subpriority = 0
                                                            if ((is_4x_device) && (gcombo_isr_event.value == "Vout Result Event"))
                                                            {
                                                                subpriority = appres_cpu_4x.getVal(["gint_maxInterruptSubPriority", "value"]).toInteger()
                                                            }
                                                            return subpriority
                                                            }, Integer)
        
        /*String for validating the string entered as callback function name*/
        gmessage_cntrl_loop_isr.visible                 = MF({
                                                            String fn_regexp = ~/^[^\d\W]\w*\Z/
                                                            Matcher matcher_tx = (gstring_int_handler_cntrl_loop.value =~ fn_regexp)
                                                            Boolean ExpressionMatch_tx = !matcher_tx.matches()
                                                            if(gstring_int_handler_cntrl_loop.visible && gstring_int_handler_cntrl_loop.enabled){return ExpressionMatch_tx} else{ return false}
                                                            },Boolean)
        
        /* ---------------------------------------------------------- */
        /* ---------------- APP IO Connections ---------------------- */
        /* ---------------------------------------------------------- */
        
        /* -------------------------------------------------------- */
        /* ------------ APP Configuration ------------------------- */
        /* -------------------------------------------------------- */
    }
    
    /* File Generation */
    def generateFiles(){
        copy("buck_vc_fix_fq.c", "buck_vc_fix_fq.c")
        copy("buck_vc_fix_fq.h", "buck_vc_fix_fq.h")
        generate("buck_vc_fix_fq_confc.tmpl", "buck_vc_fix_fq_conf.c")
        generate("buck_vc_fix_fq_controlc.tmpl", "buck_vc_fix_fq_control_loop.c")
        generate("buck_vc_fix_fq_confh.tmpl", "buck_vc_fix_fq_conf.h")
        generate("buck_vc_fix_fq_externh.tmpl", "buck_vc_fix_fq_extern.h")
    }
    
    static main(args){
        BUCK_VC_FIX_FQ obj  = new BUCK_VC_FIX_FQ();
    }
}
