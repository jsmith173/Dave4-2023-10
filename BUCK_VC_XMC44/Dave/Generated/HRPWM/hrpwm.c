/**
 * @file hrpwm.c
 * @date 2016-03-21
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * HRPWM v4.1.22 - HRPWM APP using one slice of CCU8 and HRC, with external events, dead time and high resolution
 *                 positioning support, to generate up to 2 PWM outputs.
 *
 * Copyright (c) 2015 - 2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-14:
 *     - Initial version for DAVEv4
 *
 * 2015-05-20:
 *     - HRPWM_AcknowledgeInterrupt() api is renamed as HRPWM_ClearEvent().
 *
 * 2015-06-20:
 *     - Copyright information updated.
 *
 * 2016-03-21:
 *     - Bug Fix: Trap enable configuration is corrected in HRPWM_lConfigure_Events() API.
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "hrpwm.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/

/* Initialize the App Interrupts */
static void HRPWM_lInit_Interrupt(HRPWM_t* handle_ptr);

/* Initialize the App events and configurations */
static void HRPWM_lConfigure_Events(HRPWM_t* handle_ptr);

/* Initialize the App pin configurations */
static void HRPWM_lInit_GPIO(HRPWM_t* handle_ptr);

/* Initialize the App high resolution mode */
#ifdef HRPWM_MODULE_USED
static HRPWM_STATUS_t HRPWM_lHRPWM_Init(HRPWM_t* handle_ptr);
#endif
/* Sets the period and duty in Asymmetric center aligned mode */
static HRPWM_STATUS_t HRPWM_lSetDutyCycleAsym_CA(HRPWM_t* handle_ptr, uint32_t period, float shift, float duty_cycle);

/* Sets the period and duty in Asymmetric center aligned mode */
static HRPWM_STATUS_t HRPWM_lSetDutyCycleAsym_EA(HRPWM_t* handle_ptr, uint32_t period, float shift, float duty_cycle);

/**********************************************************************************************************************
* API IMPLEMENTATION
***********************************************************************************************************************/

/* API to retrieve App version info */
DAVE_APP_VERSION_t HRPWM_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = HRPWM_MAJOR_VERSION;
  version.minor = HRPWM_MINOR_VERSION;
  version.patch = HRPWM_PATCH_VERSION;

  return version;
}

/* This function initializes the app */
HRPWM_STATUS_t HRPWM_Init(HRPWM_t* handle_ptr)
{
  HRPWM_STATUS_t status;
  GLOBAL_CCU8_STATUS_t status_ccu8_global;
  uint32_t prescalar;
  float frequency_module;

  status = HRPWM_STATUS_FAILURE;
  status_ccu8_global = GLOBAL_CCU8_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (HRPWM_STATE_UNINITIALIZED == handle_ptr->state)
  {
    /* Initialize consumed Apps */
    status_ccu8_global = GLOBAL_CCU8_Init(handle_ptr->config_ptr->global_ccu8_handle);

    /* Initialize CCU8x_CC8y slice */
    if (GLOBAL_CCU8_STATUS_SUCCESS == status_ccu8_global)
    {
      XMC_DEBUG("HRPWM_Init:Initilizing slice");

      /* Configure CCU8x_CC8y slice as timer */
      XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr);
      /* Set period match value of the timer  */
      XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->period_value);

      /* Set timer compare match value for channel 1 */
      XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                          (uint16_t) handle_ptr->config_ptr->compare1_value);
      /* Set timer compare match value for channel 2 */
      XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                          (uint16_t) handle_ptr->config_ptr->compare2_value);

      XMC_CCU8_SLICE_DeadTimeInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->dt_config_ptr);

      /* Configure events */
      HRPWM_lConfigure_Events(handle_ptr);

      /* Enable the interrupts */
      HRPWM_lInit_Interrupt(handle_ptr);

      status = HRPWM_lHRPWM_Init(handle_ptr);

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->dither_shadow_txfr_msk);

      /*Initializes the GPIO*/
      HRPWM_lInit_GPIO(handle_ptr);

      if (HRPWM_STATUS_SUCCESS == status)
      {
        handle_ptr->state = HRPWM_STATE_INITIALIZED;
      }

      frequency_module = (float) handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
      handle_ptr->frequency_module = frequency_module;
      handle_ptr->high_res_const = 1.0F / (frequency_module * 150.0E-12F);

      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
      prescalar = (uint32_t) 1 << prescalar;
      handle_ptr->frequency_tclk = frequency_module / ((float) prescalar);

      status = HRPWM_STATUS_SUCCESS;

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
      {
        status = HRPWM_Start(handle_ptr);
      }

    }
    else
    {
      handle_ptr->state = HRPWM_STATE_UNINITIALIZED;
    }

  }
  else
  {
    status = HRPWM_STATUS_ALREADY_INITIALIZED;
    XMC_DEBUG("HRPWM_Init:HRPWM_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
} /* end of HRPWM_Init() api */

static void HRPWM_lInit_Interrupt(HRPWM_t* handle_ptr)
{
  /* Enable events. Bind event to corresponding service request node. */
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
                                  handle_ptr->config_ptr->sr_per_match);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1,
                                  handle_ptr->config_ptr->sr_cmp1_match_up);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1,
                                  handle_ptr->config_ptr->sr_cmp1_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2,
                                  handle_ptr->config_ptr->sr_cmp2_match_up);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2,
                                  handle_ptr->config_ptr->sr_cmp2_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH,
                                  handle_ptr->config_ptr->sr_one_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0,
                                  handle_ptr->config_ptr->sr_e0);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT1,
                                  handle_ptr->config_ptr->sr_e1);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2,
                                  handle_ptr->config_ptr->sr_e2);

  if ((bool) true == handle_ptr->config_ptr->int_per_match)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt period match enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp1_match_up)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt compare match ch1 up enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp1_match_down)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt compare match ch1 down enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1);
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp2_match_up)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt compare match ch2 up enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2);
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp2_match_down)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt compare match ch2 down enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2);
  }

  if ((bool) true == handle_ptr->config_ptr->int_one_match_down)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt one match enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH);
  }

  if ((bool) true == handle_ptr->config_ptr->int_e0)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt event 0 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0);
  }

  if ((bool) true == handle_ptr->config_ptr->int_e1)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt event 1 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT1);
  }

  if ((bool) true == handle_ptr->config_ptr->int_e2)
  {
    XMC_DEBUG("HRPWM_Init: Interrupt event 2 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2);
  }
}
static void HRPWM_lInit_GPIO(HRPWM_t* handle_ptr)
{
  if ((bool) true == handle_ptr->config_ptr->gpio_hr_out0_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_hr_out0_ptr, handle_ptr->config_ptr->gpio_hr_out0_pin,
                  handle_ptr->config_ptr->gpio_hr_out0_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_hr_out1_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_hr_out1_ptr, handle_ptr->config_ptr->gpio_hr_out1_pin,
                  handle_ptr->config_ptr->gpio_hr_out1_config_ptr);
  }
}

static void HRPWM_lConfigure_Events(HRPWM_t* handle_ptr)
{
  /* Configure slice to a external event 0 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_0,
                                handle_ptr->config_ptr->event0_config_ptr);

  /* Configure slice to a external event 1 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_1,
                                handle_ptr->config_ptr->event1_config_ptr);

  /* Configure slice to a external event 2 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_2,
                                handle_ptr->config_ptr->event2_config_ptr);

  /* External signal controls start of the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
  {
    XMC_CCU8_SLICE_StartConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_start_event,
                               handle_ptr->config_ptr->ext_start_mode);
  }

  /* External signal can stop the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
  {
    XMC_CCU8_SLICE_StopConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
                              handle_ptr->config_ptr->ext_stop_mode);
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
  {
    XMC_CCU8_SLICE_DirectionConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
  {
    XMC_CCU8_SLICE_GateConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
  }
  /* Timer increments on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
  {
    XMC_CCU8_SLICE_CountConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_event);
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
  {
    XMC_CCU8_SLICE_LoadConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_event);
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
  {
    XMC_CCU8_SLICE_ModulationConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
                                    handle_ptr->config_ptr->ext_mod_mode, XMC_CCU8_SLICE_MODULATION_CHANNEL_1_AND_2,
                                    handle_ptr->config_ptr->ext_mod_sync);
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
  {
    XMC_CCU8_SLICE_TrapConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
                              handle_ptr->config_ptr->ext_trap_sync);
    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
    {
      XMC_CCU8_SLICE_EnableTrap(
          handle_ptr->ccu8_slice_ptr,
          (uint32_t)(XMC_CCU8_SLICE_OUTPUT_0 | XMC_CCU8_SLICE_OUTPUT_1 | XMC_CCU8_SLICE_OUTPUT_2 | XMC_CCU8_SLICE_OUTPUT_3)
          );
    }
  }

  if ((XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_override_edge_event) || (XMC_CCU8_SLICE_EVENT_NONE
      != handle_ptr->config_ptr->ext_override_level_event))
  {
    XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu8_slice_ptr,
                                                   handle_ptr->config_ptr->event1_config_ptr,
                                                   handle_ptr->config_ptr->event2_config_ptr);
    XMC_CCU8_SLICE_StatusBitOverrideConfig(handle_ptr->ccu8_slice_ptr);
  }
}

static HRPWM_STATUS_t HRPWM_lHRPWM_Init(HRPWM_t* handle_ptr)
{
  HRPWM_STATUS_t status;
  GLOBAL_HRPWM_STATUS_t status_hrpwm_global;

  status = HRPWM_STATUS_FAILURE;
  status_hrpwm_global = GLOBAL_HRPWM_STATUS_FAILURE;

  status_hrpwm_global = GLOBAL_HRPWM_Init(handle_ptr->config_ptr->global_hrpwm_handle);

  if (GLOBAL_HRPWM_STATUS_SUCCESS == status_hrpwm_global)
  {
    XMC_HRPWM_HRC_Init(handle_ptr->hrc_slice_ptr, handle_ptr->config_ptr->hrc_channel_config_ptr);

    XMC_HRPWM_HRC_ConfigSourceSelect0(handle_ptr->hrc_slice_ptr, handle_ptr->config_ptr->hrc_src_config0_ptr);
    XMC_HRPWM_HRC_ConfigSourceSelect1(handle_ptr->hrc_slice_ptr, handle_ptr->config_ptr->hrc_src_config1_ptr);

    XMC_HRPWM_HRC_Set_HR_Source(handle_ptr->hrc_slice_ptr, XMC_HRPWM_HRC_SOURCE_0);
    XMC_HRPWM_HRC_SetCompare1(handle_ptr->hrc_slice_ptr, (uint8_t) handle_ptr->config_ptr->hr_cr1);
    XMC_HRPWM_HRC_SetCompare2(handle_ptr->hrc_slice_ptr, (uint8_t) handle_ptr->config_ptr->hr_cr2);
    XMC_HRPWM_HRC_SetDeadTimeRising(handle_ptr->hrc_slice_ptr, (uint16_t) handle_ptr->config_ptr->dt_hrpwm_rise);
    XMC_HRPWM_HRC_SetDeadTimeFalling(handle_ptr->hrc_slice_ptr, (uint16_t) handle_ptr->config_ptr->dt_hrpwm_fall);

    if ((bool) true == handle_ptr->config_ptr->hrpwm_hr_path_enable)
    {
      XMC_HRPWM_EnableHighResolutionPath(handle_ptr->hrc_module_ptr, handle_ptr->config_ptr->hrpwm_hr_path_enable_mask);
    }

    if ((bool) true == handle_ptr->config_ptr->hrpwm_lr_path_enable)
    {
      XMC_HRPWM_EnableLowResolutionPath(handle_ptr->hrc_module_ptr, handle_ptr->config_ptr->hrpwm_lr_path_enable_mask);
    }

    status = HRPWM_STATUS_SUCCESS;
  }

  return (status);
}

/**********************************************************************************************************/
/*Starts the CCU8_CC8 slice. This needs to be called even if external start is configured.*/
HRPWM_STATUS_t HRPWM_Start(HRPWM_t* handle_ptr)
{
  HRPWM_STATUS_t status;
  status = HRPWM_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((HRPWM_STATE_INITIALIZED == handle_ptr->state) || (HRPWM_STATE_STOPPED == handle_ptr->state))
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU8_EnableClock(handle_ptr->ccu8_module_ptr, handle_ptr->slice_number);

    if (XMC_CCU8_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
    {
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
    }

    handle_ptr->state = HRPWM_STATE_RUNNING;
    status = HRPWM_STATUS_SUCCESS;
    XMC_DEBUG("HRPWM_Start:start PWM");
  }
  return (status);
} /* end of HRPWM_Start() api */
/**********************************************************************************************************/
/*Stops the CCU8_CC8 slice. */
HRPWM_STATUS_t HRPWM_Stop(HRPWM_t* handle_ptr)
{
  HRPWM_STATUS_t status;
  status = HRPWM_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
    XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
    XMC_CCU8_DisableClock(handle_ptr->ccu8_module_ptr, handle_ptr->slice_number);

    handle_ptr->state = HRPWM_STATE_STOPPED;
    status = HRPWM_STATUS_SUCCESS;
    XMC_DEBUG("HRPWM_Stop:stop PWM");
  }
  return (status);

} /* end of HRPWM_Stop() api */
/**********************************************************************************************************/

/*Sets the frequency for CCU8_CC8 slice Symmetric Mode. */
HRPWM_STATUS_t HRPWM_SetFreqSymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz)
{
  HRPWM_STATUS_t status;
  float frequency_tclk;
  uint32_t period;
  float duty_ch1;
  float duty_ch2;
  float compare_f;
  uint32_t compare_ch1;
  uint32_t compare_ch2;
  uint32_t hr_cr1;

  status = HRPWM_STATUS_FAILURE;
  frequency_tclk = 0.0F;
  XMC_ASSERT("HRPWM_SetFreqSymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    if (0U == pwm_freq_hz)
    {
      XMC_DEBUG("HRPWM_SetPwmFreq:cannot set frequency 0Hz");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      frequency_tclk = frequency_tclk / (float) pwm_freq_hz;
      period = (uint32_t) frequency_tclk;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
      {
        period = period >> 1U;/*divide by 2*/
      }

      if ((period != 0U) && (period <= HRPWM_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        duty_ch1 = handle_ptr->sym_duty1;
        duty_ch2 = handle_ptr->sym_duty2;

        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_f = (((float) (period) * (100.0F - duty_ch2)) / 100.0F);
        compare_ch2 = (uint32_t) compare_f;
        compare_f = (((float) (period) * (100.0F - duty_ch1)) / 100.0F);
        compare_ch1 = (uint32_t) compare_f;

        compare_f = (compare_f - (float) compare_ch1) * handle_ptr->high_res_const;
        hr_cr1 = (uint32_t)(compare_f);
        if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr
            ->timer_mode)
        {
          hr_cr1 = hr_cr1 << 1; /*Double hr_cr1 = hr_cr1 * 2 */
        }
        if (hr_cr1 > handle_ptr->hr_cr_max)
        {
          hr_cr1 = handle_ptr->hr_cr_max;
        }
        XMC_HRPWM_HRC_SetCompare1(handle_ptr->hrc_slice_ptr, (uint8_t) hr_cr1);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                            (uint16_t) compare_ch1);
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                            (uint16_t) compare_ch2);
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

        XMC_DEBUG("HRPWM_SetPwmFreq:frequency set");
        status = HRPWM_STATUS_SUCCESS;
      }
    }
  }
  return (status);

} /* end of HRPWM_SetFreqSymmetric() api */

/**********************************************************************************************************/

/*Sets the frequency and (float)duty cycle for CCU8_CC8 slice Symmetric Mode. */
HRPWM_STATUS_t HRPWM_SetFreqAndDutyCycleSymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz, float duty_ch1,
                                                  float duty_ch2)
{
  HRPWM_STATUS_t status;
  uint32_t period;
  uint32_t compare_ch1;
  uint32_t compare_ch2;
  float compare_f;
  float frequency_tclk;
  uint32_t hr_cr1;

  status = HRPWM_STATUS_FAILURE;
  frequency_tclk = 0.0F;
  XMC_ASSERT("HRPWM_SetFreqAndDutyCycleSymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (handle_ptr->state != HRPWM_STATE_UNINITIALIZED)
  {
    if (0U == pwm_freq_hz)
    {
      XMC_DEBUG("HRPWM_SetFreqAndDutyCycleSymmetric:cannot set frequency 0Hz");
    }
    else if ((duty_ch1 > 100.0F) || (duty_ch2 > 100.0F))
    {
      XMC_DEBUG("HRPWM_SetFreqAndDutyCycleSymmetric:duty > 100");
    }
    else if ((duty_ch1 < 0.0F) || (duty_ch2 < 0.0F))
    {
      XMC_DEBUG("HRPWM_SetFreqAndDutyCycleSymmetric:duty < 0");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      frequency_tclk = frequency_tclk / (float) pwm_freq_hz;
      period = (uint32_t) frequency_tclk;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
      {
        period = period >> 1;
      }

      if ((period != 0U) && (period <= HRPWM_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_f = (((float) (period) * (100.0F - duty_ch2)) / 100.0F);
        compare_ch2 = (uint32_t) compare_f;
        compare_f = (((float) (period) * (100.0F - duty_ch1)) / 100.0F);
        compare_ch1 = (uint32_t) compare_f;

        compare_f = (compare_f - (float) compare_ch1) * handle_ptr->high_res_const;
        hr_cr1 = (uint32_t)(compare_f);
        if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr
            ->timer_mode)
        {
          hr_cr1 = hr_cr1 << 1; /*Double hr_cr1 = hr_cr1 * 2 */
        }
        if (hr_cr1 > handle_ptr->hr_cr_max)
        {
          hr_cr1 = handle_ptr->hr_cr_max;
        }
        XMC_HRPWM_HRC_SetCompare1(handle_ptr->hrc_slice_ptr, (uint8_t) hr_cr1);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                            (uint16_t) compare_ch1);
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                            (uint16_t) compare_ch2);
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

        handle_ptr->sym_duty1 = duty_ch1;
        handle_ptr->sym_duty2 = duty_ch2;

        XMC_DEBUG("HRPWM_SetFreqAndDutyCycleSymmetric:frequency set");
        status = HRPWM_STATUS_SUCCESS;
      }
    }
  }
  return (status);

}/* end of HRPWM_SetFreqAndDutyCycleSymmetric() api */

/**********************************************************************************************************/

/*Sets the duty cycle (float) for CCU8_CC8 slice. */
HRPWM_STATUS_t HRPWM_SetDutyCycleSymmetric(HRPWM_t* handle_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_t channel,
                                           float duty_cycle)
{
  HRPWM_STATUS_t status;
  uint32_t period;
  uint32_t compare;
  float compare_f;
  uint32_t hr_cr1;

  status = HRPWM_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_SetDutyCycleSymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    /* duty cycle has to be in between 0 and 100 */
    if ((duty_cycle > 100.0F))
    {
      XMC_DEBUG("HRPWM_SetDutyCycle:Cannot set dutycycle > 100");
    }
    else if ((duty_cycle < 0.0F))
    {
      XMC_DEBUG("HRPWM_SetDutyCycle:Cannot set dutycycle < 0");
    }
    else
    {

      period = (uint32_t) XMC_CCU8_SLICE_GetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr) + 1U;
      /* Duty Cycle(symmetric) = (PR+1-CR1) / (PR+1) */
      compare_f = (((float) (period) * (100.0F - duty_cycle)) / 100.0F);
      compare = (uint32_t) compare_f;

      compare_f = (compare_f - (float) compare) * handle_ptr->high_res_const;
      hr_cr1 = (uint32_t) compare_f;
      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
      {
        hr_cr1 = hr_cr1 << 1U; /*Double hr_cr1 = hr_cr1 * 2 */
      }
      if (hr_cr1 > handle_ptr->hr_cr_max)
      {
        hr_cr1 = handle_ptr->hr_cr_max;
      }
      XMC_HRPWM_HRC_SetCompare1(handle_ptr->hrc_slice_ptr, (uint8_t) hr_cr1);

      XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, channel, (uint16_t) compare);
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

      if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
      {
        handle_ptr->sym_duty1 = duty_cycle;
      }
      else
      {

        handle_ptr->sym_duty2 = duty_cycle;
      }

      XMC_DEBUG("HRPWM_SetDutyCycleFloat:dutycycle set");
      status = HRPWM_STATUS_SUCCESS;
    }
  }
  return (status);
} /* end of HRPWM_SetDutyCycleSymmetric() api */

/**********************************************************************************************************/
/*Sets the frequency for CCU8_CC8 slice Asymmetric Mode. */
HRPWM_STATUS_t HRPWM_SetFreqAsymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz)
{
  HRPWM_STATUS_t status;
  float frequency_tclk;
  uint32_t period;
  float duty_cycle;
  float shift;

  status = HRPWM_STATUS_FAILURE;
  frequency_tclk = 0.0F;
  XMC_ASSERT("HRPWM_SetFreqAsymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    if (0U == pwm_freq_hz)
    {
      XMC_DEBUG("HRPWM_SetPwmFreq:cannot set frequency 0Hz");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      frequency_tclk = frequency_tclk / (float) pwm_freq_hz;
      period = (uint32_t) frequency_tclk;
      duty_cycle = handle_ptr->asym_duty;
      shift = handle_ptr->asym_shift;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
      {
        period = period >> 1U;
        if ((period != 0U) && (period <= HRPWM_MAX_TIMER_COUNT))
        {
          status = HRPWM_lSetDutyCycleAsym_CA(handle_ptr, period, shift, duty_cycle);
        }
      }
      else
      {
        if ((period != 0U) && (period <= HRPWM_MAX_TIMER_COUNT))
        {
          status = HRPWM_lSetDutyCycleAsym_EA(handle_ptr, period, shift, duty_cycle);
        }
      }

      if (HRPWM_STATUS_SUCCESS == status)
      {
        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
      }

    }
  }
  return (status);
}/* end of HRPWM_SetFreqAsymmetric() api */

/**********************************************************************************************************/

/*Sets the duty cycle and shift (uint32_t) for CCU8_CC8 slice in Asymmetric mode. */
/*(shift + duty_cycle <= 100)  and (shift + duty_cycle >= 50) */
HRPWM_STATUS_t HRPWM_SetDutyCycleAsymmetric(HRPWM_t* handle_ptr, float shift, float duty_cycle)
{
  HRPWM_STATUS_t status;
  uint32_t period;

  status = HRPWM_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_SetDutyCycleAsymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
    {
      period = (uint32_t) XMC_CCU8_SLICE_GetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr) + 1U;
      status = HRPWM_lSetDutyCycleAsym_CA(handle_ptr, period, shift, duty_cycle);
    }
    else
    {
      period = (uint32_t) XMC_CCU8_SLICE_GetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr) + 1U;
      status = HRPWM_lSetDutyCycleAsym_EA(handle_ptr, period, shift, duty_cycle);
    }
  }
  return (status);
}/* end of HRPWM_SetDutyCycleAsymmetric() api */
/**********************************************************************************************************/

/*Sets the frequency, (float)shift and (float)duty cycle for CCU8_CC8 slice Asymmetric Mode. */
HRPWM_STATUS_t HRPWM_SetFreqAndDutyCycleAsymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz, float shift,
                                                   float duty_cycle)
{
  HRPWM_STATUS_t status;
  float frequency_tclk;
  uint32_t period;

  status = HRPWM_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_SetFreqAndDutyCycleAsymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    if (0U == pwm_freq_hz)
    {
      XMC_DEBUG("HRPWM_SetFreqAndDutyCycleAsymmetric:cannot set frequency 0Hz");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      frequency_tclk = frequency_tclk / (float) pwm_freq_hz;
      period = (uint32_t) frequency_tclk;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
      {
        period = period >> 1U;
        if ((period != 0U) && (period <= HRPWM_MAX_TIMER_COUNT))
        {
          status = HRPWM_lSetDutyCycleAsym_CA(handle_ptr, period, shift, duty_cycle);
        }
      }
      else
      {
        if ((period != 0U) && (period <= HRPWM_MAX_TIMER_COUNT))
        {
          status = HRPWM_lSetDutyCycleAsym_EA(handle_ptr, period, shift, duty_cycle);
        }
      }

      if (HRPWM_STATUS_SUCCESS == status)
      {
        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
      }
    }
  }
  return (status);
}/* end of HRPWM_SetFreqAndDutyCycleAsymmetric() api */
/**********************************************************************************************************/

static HRPWM_STATUS_t HRPWM_lSetDutyCycleAsym_CA(HRPWM_t* handle_ptr, uint32_t period, float shift, float duty_cycle)
{
  HRPWM_STATUS_t status;
  uint32_t compare_ch1;
  uint32_t compare_ch2;
  float compare_f1;
  float compare_f2;
  uint32_t hr_cr1;
  uint32_t hr_cr2;

  status = HRPWM_STATUS_FAILURE;
  if ((shift < 0.0F) || (duty_cycle < 0.0F))
  {
    XMC_DEBUG("HRPWM_lSetDutyCycleAsym_CA:Cannot set center aligned mode (shift or duty_cycle) < 0");
  }
  else if (((shift + duty_cycle) > 100.0F) || ((shift + duty_cycle) < 50.0F))
  {
    XMC_DEBUG("HRPWM_lSetDutyCycleAsym_CA:Cannot set center aligned mode 50 < (shift + duty_cycle) < 100");
  }
  else
  {
    compare_f1 = (((float) period * shift * 2.0F) / (100.0F));
    compare_f2 = (((float) period * 2.0F * (100.0F - (shift + duty_cycle))) / (100.0F));
    compare_ch1 = (uint32_t) compare_f1;
    compare_ch2 = (uint32_t) compare_f2;

    compare_f1 = (compare_f1 - (float) compare_ch1) * handle_ptr->high_res_const;
    compare_f2 = (compare_f2 - (float) compare_ch2) * handle_ptr->high_res_const;
    hr_cr1 = (uint32_t)(compare_f1);
    hr_cr2 = (uint32_t)(compare_f2);

    if (hr_cr1 > handle_ptr->hr_cr_max)
    {
      hr_cr1 = handle_ptr->hr_cr_max;
    }
    hr_cr2 = hr_cr2 + hr_cr1;

    if (hr_cr2 > handle_ptr->hr_cr_max)
    {
      hr_cr2 = handle_ptr->hr_cr_max;
    }

    XMC_HRPWM_HRC_SetCompare1(handle_ptr->hrc_slice_ptr, (uint8_t) hr_cr1);
    XMC_HRPWM_HRC_SetCompare2(handle_ptr->hrc_slice_ptr, (uint8_t) hr_cr2);

    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                        (uint16_t) compare_ch1);
    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                        (uint16_t) compare_ch2);
    XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

    handle_ptr->asym_duty = duty_cycle;
    handle_ptr->asym_shift = shift;
    status = HRPWM_STATUS_SUCCESS;
    XMC_DEBUG("HRPWM_lSetDutyCycleAsym_CA:dutycycle set center aligned mode");

  }
  return (status);
}/* end of HRPWM_lSetDutyCycleAsym_CA() api */
/**********************************************************************************************************/

static HRPWM_STATUS_t HRPWM_lSetDutyCycleAsym_EA(HRPWM_t* handle_ptr, uint32_t period, float shift, float duty_cycle)
{
  HRPWM_STATUS_t status;
  uint32_t compare_ch1;
  uint32_t compare_ch2;
  float compare_f1;
  float compare_f2;
  uint32_t hr_cr1;
  uint32_t hr_cr2;

  status = HRPWM_STATUS_FAILURE;
  if ((shift < 0.0F) || (duty_cycle < 0.0F))
  {
    XMC_DEBUG("HRPWM_lSetDutyCycleAsym_EA:Cannot set edge aligned mode (shift or duty_cycle) < 0");
  }
  else if (((shift + duty_cycle) > 100.0F))
  {
    XMC_DEBUG("HRPWM_lSetDutyCycleAsym_EA:Cannot set edge aligned mode (shift + duty_cycle) > 100");
  }
  else
  {
    compare_f1 = (((float) period * shift) / (100.0F));
    compare_f2 = (((float) period * (shift + duty_cycle)) / (100.0F));
    compare_ch1 = (uint32_t) compare_f1;
    compare_ch2 = (uint32_t) compare_f2;

    compare_f1 = (compare_f1 - (float) compare_ch1) * handle_ptr->high_res_const;
    compare_f2 = (compare_f2 - (float) compare_ch2) * handle_ptr->high_res_const;
    hr_cr1 = (uint32_t)(compare_f1);
    hr_cr2 = (uint32_t)(compare_f2);

    if (hr_cr1 > handle_ptr->hr_cr_max)
    {
      hr_cr1 = handle_ptr->hr_cr_max;
    }
    hr_cr2 = hr_cr2 + hr_cr1;

    if (hr_cr2 > handle_ptr->hr_cr_max)
    {
      hr_cr2 = handle_ptr->hr_cr_max;
    }

    XMC_HRPWM_HRC_SetCompare1(handle_ptr->hrc_slice_ptr, (uint8_t) hr_cr1);
    XMC_HRPWM_HRC_SetCompare2(handle_ptr->hrc_slice_ptr, (uint8_t) hr_cr2);

    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                        (uint16_t) compare_ch1);
    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                        (uint16_t) compare_ch2);
    XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

    handle_ptr->asym_duty = duty_cycle;
    handle_ptr->asym_shift = shift;
    status = HRPWM_STATUS_SUCCESS;
    XMC_DEBUG("HRPWM_lSetDutyCycleAsym_EA:dutycycle set edge aligned mode");

  }
  return (status);
}/* end of HRPWM_lSetDutyCycleAsym_EA() api */
/**********************************************************************************************************/

/* end of CCU8 function definitions */


