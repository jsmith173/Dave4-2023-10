/**
 * @file buck_pcc_fix_fq.c
 * @date 2016-01-24
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * BUCK_PCC_FIX_FQ v4.1.4 - APP can be used to control different configurations of buck in peak current control mode.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-10-08:
 *     - Initial version for DAVEv4
 *
 *
 * 2015-10-15:
 *     - Typo in BUCK_PCC_FIX_FQ_lClearOverloadProtectionVariables() API is corrected.
 *
 * 2016-01-18:
 *     - APP handle structure is modified
 *
 * 2016-01-19:
 *     - Bugs fixed in BUCK_PCC_FIX_FQ_Start() & BUCK_PCC_FIX_FQ_Stop() APIs.
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "buck_pcc_fix_fq.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/* Based on the XMC family the reset values are applied to the variables */
#if(UC_FAMILY == XMC4)
#define BUCK_PCC_FIX_FQ_CLEAR_U (0.0f)
#define BUCK_PCC_FIX_FQ_CLEAR_I (0.0f)
#else
#define BUCK_PCC_FIX_FQ_CLEAR_U (0U)
#define BUCK_PCC_FIX_FQ_CLEAR_I (0)
#endif

/***********************************************************************************************************************
 * PRIVATE FUNCTION PROTOTYPES
 **********************************************************************************************************************/
#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
/* Initialize ADC scan configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lADC_SCAN_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
#endif

#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
/* Initialize ADC queue configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lADC_QUEUE_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
#endif

#ifdef BUCK_PCC_FIX_FQ_RESULT_INT_USED
/* Initialize Interrupt configurations */
void BUCK_PCC_FIX_FQ_lInterrupt_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
#endif

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
/* Initialize PWM_CCU8 configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU8_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Start timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU8_Start(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Stop timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU8_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr);

/* Initialize CMP_REF configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_REF_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);

#ifdef BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED
/* Initialize PWM_CCU4 configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU4_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Start timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU4_Start(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Stop timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU4_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr);
#endif

#ifdef BUCK_PCC_FIX_FQ_BLANKING_AND_SLOPE_USED
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lDIGITAL_IO_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
#endif
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
/* Initialize HRPWM configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lHRPWM_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Start timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lHRPWM_Start(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Stop timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lHRPWM_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr);

/* Initialize COMP_SLOPE_GEN configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Start CSG */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Start(BUCK_PCC_FIX_FQ_t *handle_ptr);
/* Stop CSG */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr);
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lSYSTIMER_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lSYSTIMER_Start(BUCK_PCC_FIX_FQ_t *handle_ptr);
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lSYSTIMER_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr);
#endif


/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/

/* Clears the variables used by the compensator */
void BUCK_PCC_FIX_FQ_lClearCompensatorVariables(BUCK_PCC_FIX_FQ_t *handle_ptr);

/* Clears the variables used for Over load protection */
void BUCK_PCC_FIX_FQ_lClearOverloadProtectionVariables(BUCK_PCC_FIX_FQ_t *handle_ptr);

/* All the timers used in the APP are synchronously started */
void BUCK_PCC_FIX_FQ_lSynchronousStart(BUCK_PCC_FIX_FQ_t *handle_ptr);

/**********************************************************************************************************************
* API IMPLEMENTATION
***********************************************************************************************************************/

/* API to retrieve driver version info */
DAVE_APP_VERSION_t BUCK_PCC_FIX_FQ_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = BUCK_PCC_FIX_FQ_MAJOR_VERSION;
  version.minor = BUCK_PCC_FIX_FQ_MINOR_VERSION;
  version.patch = BUCK_PCC_FIX_FQ_PATCH_VERSION;

  return version;
}

/* Initialize BUCK_PCC_FIX_FQ APP parameters and lower level APP's */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;

  XMC_ASSERT("BUCK_PCC_FIX_FQ_Init: handle_ptr is NULL", (handle_ptr != NULL));

  if (handle_ptr->state == BUCK_PCC_FIX_FQ_STATE_UNINITIALIZED)
  {
#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
    if(handle_ptr->adc_config->adc_mode == BUCK_PCC_FIX_FQ_ADC_MODE_SCAN)
    {
      status = BUCK_PCC_FIX_FQ_lADC_SCAN_Init(handle_ptr); /* Initialize ADC_SCAN configurations  */
    }
#endif

#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
    if(handle_ptr->adc_config->adc_mode == BUCK_PCC_FIX_FQ_ADC_MODE_QUEUE)
    {
      status = BUCK_PCC_FIX_FQ_lADC_QUEUE_Init(handle_ptr); /* Initialize ADC_QUEUE configurations  */
    }
#endif

    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
      status = BUCK_PCC_FIX_FQ_lPWM_CCU8_Init(handle_ptr);  /* Initialize PWM_CCU8 configurations */

      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = BUCK_PCC_FIX_FQ_lCOMP_REF_Init(handle_ptr);  /* Initialize COMP_REF configurations */
      }

#ifdef BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = BUCK_PCC_FIX_FQ_lPWM_CCU4_Init(handle_ptr);  /* Initialize PWM_CCU4 configurations */
      }
#endif

#ifdef BUCK_PCC_FIX_FQ_BLANKING_AND_SLOPE_USED
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = BUCK_PCC_FIX_FQ_lDIGITAL_IO_Init(handle_ptr);  /* Initialize DIGITAL_IO configurations */
      }
#endif

#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
      status = BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Init(handle_ptr);  /* Initialize COMP_SLOPE_GEN configurations */

      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = BUCK_PCC_FIX_FQ_lHRPWM_Init(handle_ptr);  /* Initialize HRPWM configurations */
      }
#endif
    }

#ifdef BUCK_PCC_FIX_FQ_RESULT_INT_USED
    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
      if ((handle_ptr->config->interrupt_event == BUCK_PCC_FIX_FQ_INTERRUPT_VOUT_RESULT_EVENT))
      {
        BUCK_PCC_FIX_FQ_lInterrupt_Init(handle_ptr); /* Initialize interrupt */
      }
    }
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
    if (handle_ptr->config->soft_start_enable == true)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = BUCK_PCC_FIX_FQ_lSYSTIMER_Init(handle_ptr);
      }
    }
#endif

    handle_ptr->state = BUCK_PCC_FIX_FQ_STATE_INITIALIZED;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_ALREADY_INITIALIZED;
  }

  return (status);
}

/* Prepares the timers ready for PWM generation on a external signal event */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_Start(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  XMC_ASSERT("BUCK_PCC_FIX_FQ_Start: handle_ptr is NULL", (handle_ptr != NULL));

  if ((handle_ptr->state == BUCK_PCC_FIX_FQ_STATE_INITIALIZED) || (handle_ptr->state == BUCK_PCC_FIX_FQ_STATE_STOPPED))
  {
    /* Clears the variables used by the compensator, Starts the BUCK from a known state */
    BUCK_PCC_FIX_FQ_lClearCompensatorVariables(handle_ptr);

    /* Clears the variables used for Over load protection, Starts the BUCK from a known state */
    BUCK_PCC_FIX_FQ_lClearOverloadProtectionVariables(handle_ptr);

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
    status = BUCK_PCC_FIX_FQ_lPWM_CCU8_Start(handle_ptr);

#ifdef BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED
    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
      status = BUCK_PCC_FIX_FQ_lPWM_CCU4_Start(handle_ptr);
    }
#endif

#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
      status = BUCK_PCC_FIX_FQ_lHRPWM_Start(handle_ptr);
    }

    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
      status = BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Start(handle_ptr);
    }
#endif

    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {

#ifdef BUCK_PCC_FIX_FQ_RESULT_INT_USED
      if ((handle_ptr->config->interrupt_event == BUCK_PCC_FIX_FQ_INTERRUPT_VOUT_RESULT_EVENT))
      {
        NVIC_EnableIRQ((IRQn_Type)handle_ptr->interrupt_config->node); /* Enable Vout Result Event's nvic node */
      }
#endif

#ifdef BUCK_PCC_FIX_FQ_END_OF_REQ_SOURCE_INT_USED
#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
      if(handle_ptr->adc_config->adc_mode == BUCK_PCC_FIX_FQ_ADC_MODE_SCAN)
      {
        NVIC_EnableIRQ((IRQn_Type)handle_ptr->adc_scan_app_handle_array[0]->rs_intr_handle->node_id); /* Enable end of request source event's nvic node */
      }
#endif

#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
      if(handle_ptr->adc_config->adc_mode == BUCK_PCC_FIX_FQ_ADC_MODE_QUEUE)
      {
        NVIC_EnableIRQ((IRQn_Type)handle_ptr->adc_queue_app_handle_array[0]->rs_intr_handle->node_id); /* Enable end of request source event's nvic node */
      }
#endif
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
      if (handle_ptr->config->soft_start_enable == true)
      {
        status = BUCK_PCC_FIX_FQ_lSYSTIMER_Start(handle_ptr);
      }
#endif

      /* Synchronously start the timers */
      BUCK_PCC_FIX_FQ_lSynchronousStart(handle_ptr);
    }

    handle_ptr->state = BUCK_PCC_FIX_FQ_STATE_RUNNING;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}

/* Stops PWM generation by timers */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  XMC_ASSERT("BUCK_PCC_FIX_FQ_Stop: handle_ptr is NULL", (handle_ptr != NULL));

  if (handle_ptr->state != BUCK_PCC_FIX_FQ_STATE_UNINITIALIZED)
  {
#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
    status = BUCK_PCC_FIX_FQ_lPWM_CCU8_Stop(handle_ptr);

#ifdef BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED
    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
      status = BUCK_PCC_FIX_FQ_lPWM_CCU4_Stop(handle_ptr);
    }
#endif

#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
    status = BUCK_PCC_FIX_FQ_lHRPWM_Stop(handle_ptr);

    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
      status = BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Stop(handle_ptr);
    }
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
    if (handle_ptr->config->soft_start_enable == true)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        BUCK_PCC_FIX_FQ_lSYSTIMER_Stop(handle_ptr);
      }
    }
#endif

    if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
    {
#ifdef BUCK_PCC_FIX_FQ_RESULT_INT_USED
      if ((handle_ptr->config->interrupt_event == BUCK_PCC_FIX_FQ_INTERRUPT_VOUT_RESULT_EVENT))
      {
        NVIC_DisableIRQ((IRQn_Type)handle_ptr->interrupt_config->node); /* Enable vout result event's nvic node */
      }
#endif

#ifdef BUCK_PCC_FIX_FQ_END_OF_REQ_SOURCE_INT_USED
#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
        if(handle_ptr->adc_config->adc_mode == BUCK_PCC_FIX_FQ_ADC_MODE_SCAN)
        {
          NVIC_DisableIRQ((IRQn_Type)handle_ptr->adc_scan_app_handle_array[0]->rs_intr_handle->node_id); /* Enable end of request source event's nvic node */
        }
#endif
#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
        if(handle_ptr->adc_config->adc_mode == BUCK_PCC_FIX_FQ_ADC_MODE_QUEUE)
        {
          NVIC_DisableIRQ((IRQn_Type)handle_ptr->adc_queue_app_handle_array[0]->rs_intr_handle->node_id); /* Enable end of request source event's nvic node */
        }
#endif
#endif

    }

    handle_ptr->state = BUCK_PCC_FIX_FQ_STATE_STOPPED;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}

/***********************************************************************************************************************
 * PRIVATE API IMPLEMENTATION
 **********************************************************************************************************************/
#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
/* Initialize ADC scan configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lADC_SCAN_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t adc_resource;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  ADC_SCAN_STATUS_t adc_scan_status = ADC_SCAN_SUCCESS;
  const BUCK_PCC_FIX_FQ_ADCConfig_t *const adc_config = handle_ptr->adc_config;

  for (adc_resource = 0U; adc_resource < (uint8_t)BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH; adc_resource++)
  {
    if (handle_ptr->adc_scan_app_handle_array[adc_resource] != NULL)
    {
      if (adc_scan_status == ADC_SCAN_SUCCESS)
      {
        adc_scan_status = ADC_SCAN_Init(handle_ptr->adc_scan_app_handle_array[adc_resource]);

        if (adc_scan_status == ADC_SCAN_SUCCESS)
        {
          /* insert scan entry */
          ADC_SCAN_InsertScanEntry(handle_ptr->adc_scan_app_handle_array[adc_resource],
                                   adc_config->scan_entry_handle_array[adc_resource]);

          /* channel initialization */
          XMC_VADC_GROUP_ChannelInit(handle_ptr->group_ptr_array[adc_resource],
                                     (uint32_t) adc_config->channel_num_array[adc_resource],
                                     adc_config->channel_handle_array[adc_resource]);
        }
      }
    }
  }

  if (adc_scan_status == ADC_SCAN_SUCCESS)
  {
    /* result register initialization */
    XMC_VADC_GROUP_ResultInit(handle_ptr->group_ptr_array[0],
                              (uint32_t)adc_config->result_register_num_array[0],
                              adc_config->result_reg_handle);

    for (adc_resource = 0U; adc_resource < (uint8_t)BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH; adc_resource++)
    {
      if (handle_ptr->adc_scan_app_handle_array[adc_resource] != NULL)
      {
        /* Inserts the channel entries into the hardware */
        ADC_SCAN_AllEntriesInserted(handle_ptr->adc_scan_app_handle_array[adc_resource]);
      }
    }

    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
/* Initialize ADC scan configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lADC_QUEUE_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t adc_resource;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  ADC_QUEUE_STATUS_t adc_queue_status = ADC_QUEUE_SUCCESS;
  const BUCK_PCC_FIX_FQ_ADCConfig_t *const adc_config = handle_ptr->adc_config;

  for (adc_resource = 0U; adc_resource < (uint8_t)BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH; adc_resource++)
  {
    if (handle_ptr->adc_queue_app_handle_array[adc_resource] != NULL)
    {
      if (adc_queue_status == ADC_QUEUE_SUCCESS)
      {
        adc_queue_status = ADC_QUEUE_Init(handle_ptr->adc_queue_app_handle_array[adc_resource]);

        if (adc_queue_status == ADC_QUEUE_SUCCESS)
        {
          /* insert queue entry */
          ADC_QUEUE_InsertQueueEntry(handle_ptr->adc_queue_app_handle_array[adc_resource],
                                     adc_config->q_entry_handle_array[adc_resource]);

          /* channel initialization */
          XMC_VADC_GROUP_ChannelInit(handle_ptr->group_ptr_array[adc_resource],
                                     (uint32_t)adc_config->channel_num_array[adc_resource],
                                     adc_config->channel_handle_array[adc_resource]);
        }
      }
    }
  }

  if (adc_queue_status == ADC_QUEUE_SUCCESS)
  {
    /* result register initialization */
    XMC_VADC_GROUP_ResultInit(handle_ptr->group_ptr_array[0],
                              (uint32_t) adc_config->result_register_num_array[0],
                              adc_config->result_reg_handle);

    for (adc_resource = 0U; adc_resource < (uint8_t)BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH; adc_resource++)
    {
      if (handle_ptr->adc_queue_app_handle_array[adc_resource] != NULL)
      {
        /* Inserts the channel entries into the hardware */
        ADC_QUEUE_AllEntriesInserted(handle_ptr->adc_queue_app_handle_array[adc_resource]);
      }
    }

    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
/* Initialize PWM_CCU8 configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU8_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  PWM_CCU8_STATUS_t pwm_ccu8_status = PWM_CCU8_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if ((handle_ptr->pwm_ccu8_handle_array[phase] != NULL) && (pwm_ccu8_status == PWM_CCU8_STATUS_SUCCESS))
    {
      /* Initialize CCU slice */
      pwm_ccu8_status = PWM_CCU8_Init(handle_ptr->pwm_ccu8_handle_array[phase]);
    }
  }

  if (pwm_ccu8_status == PWM_CCU8_STATUS_SUCCESS)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU8_Start(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  uint8_t kernel_number;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->pwm_ccu8_handle_array[phase] != NULL)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = (BUCK_PCC_FIX_FQ_STATUS_t) PWM_CCU8_Start(handle_ptr->pwm_ccu8_handle_array[phase]);

        /* Load phase shifted timer value for interleaved buck */
        XMC_CCU8_SLICE_SetTimerValue(handle_ptr->pwm_ccu8_handle_array[phase]->ccu8_slice_ptr, handle_ptr->pwm_config->phase_timer_val[phase]);

        /* Read CCU8 kernel number */
        kernel_number = handle_ptr->pwm_ccu8_handle_array[phase]->kernel_number;

        /* Calculation of kernel position in CCUCON register */
        handle_ptr->ccu_modules |= (uint32_t)1 << ((uint32_t) SCU_GENERAL_CCUCON_GSC80_Pos + kernel_number);

        XMC_GPIO_Init(handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out0_ptr,
                      handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out0_pin,
                      handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out0_config_ptr);

        if(handle_ptr->pwm_config->synch_converter == true)
        {
          XMC_GPIO_Init(handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out1_ptr,
                        handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out1_pin,
                        handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out1_config_ptr);
        }
      }
    }
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU8_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->pwm_ccu8_handle_array[phase] != NULL)
    {
      XMC_GPIO_SetMode(handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out0_ptr,
                       handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out0_pin,
                       XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
      XMC_GPIO_SetOutputLevel(handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out0_ptr,
                              handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out0_pin,
                              handle_ptr->pwm_config->ccu8_output_passive_level);

      if(handle_ptr->pwm_config->synch_converter == true)
      {
        XMC_GPIO_SetMode(handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out1_ptr,
                         handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out1_pin,
                         XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
        XMC_GPIO_SetOutputLevel(handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out1_ptr,
                                handle_ptr->pwm_ccu8_handle_array[phase]->config_ptr->gpio_ch1_out1_pin,
                                handle_ptr->pwm_config->ccu8_output_passive_level);
      }
    }
  }

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->pwm_ccu8_handle_array[phase] != NULL)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = (BUCK_PCC_FIX_FQ_STATUS_t) PWM_CCU8_Stop(handle_ptr->pwm_ccu8_handle_array[phase]);
      }
    }
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED /* XMC1x family */
/* Initialize COMP_REF configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_REF_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  COMP_REF_STATUS_t comp_ref_status = COMP_REF_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if ((handle_ptr->comp_ref_handle_array[phase] != NULL)  && (comp_ref_status == COMP_REF_STATUS_SUCCESS))
    {
      /* Initialize COMP_REF */
      comp_ref_status = COMP_REF_Init(handle_ptr->comp_ref_handle_array[phase]);
    }
  }

  if (comp_ref_status == COMP_REF_STATUS_SUCCESS)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#if defined (BUCK_PCC_FIX_FQ_PWM_CCU8_USED) && defined(BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED)
/* Initialize PWM_CCU4 configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU4_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  PWM_CCU4_STATUS_t pwm_ccu4_status = PWM_CCU4_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if ((handle_ptr->pwm_ccu4_handle_array[phase] != NULL) && (pwm_ccu4_status == PWM_CCU4_STATUS_SUCCESS))
    {
      /* Initialize CCU slice */
      pwm_ccu4_status = PWM_CCU4_Init(handle_ptr->pwm_ccu4_handle_array[phase]);
    }
  }

  if (pwm_ccu4_status == PWM_CCU4_STATUS_SUCCESS)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#if defined (BUCK_PCC_FIX_FQ_PWM_CCU8_USED) && defined(BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED)
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU4_Start(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  uint8_t kernel_number;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->pwm_ccu4_handle_array[phase] != NULL)
      {
        if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
        {
          status = (BUCK_PCC_FIX_FQ_STATUS_t) PWM_CCU4_Start(handle_ptr->pwm_ccu4_handle_array[phase]);

          /* Load phase shifted timer value for interleaved buck */
          XMC_CCU4_SLICE_SetTimerValue(handle_ptr->pwm_ccu4_handle_array[phase]->ccu4_slice_ptr, handle_ptr->pwm_config->phase_timer_val[phase]);

          /* Read CCU4 kernel number */
          kernel_number = handle_ptr->pwm_ccu4_handle_array[phase]->kernel_number;

          /* Calculation of kernel position in CCUCON register */
          handle_ptr->ccu_modules |= (uint32_t)1 << (SCU_GENERAL_CCUCON_GSC40_Pos + kernel_number);
        }
    }
  }

  return (status);
}
#endif

#if defined (BUCK_PCC_FIX_FQ_PWM_CCU8_USED) && defined(BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED)
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lPWM_CCU4_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->pwm_ccu4_handle_array[phase] != NULL)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = (BUCK_PCC_FIX_FQ_STATUS_t) PWM_CCU4_Stop(handle_ptr->pwm_ccu4_handle_array[phase]);
      }
    }
  }

  return (status);
}
#endif

#if defined (BUCK_PCC_FIX_FQ_PWM_CCU8_USED) && defined(BUCK_PCC_FIX_FQ_BLANKING_AND_SLOPE_USED)
/* Initialize DIGITAL_IO configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lDIGITAL_IO_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  DIGITAL_IO_STATUS_t digital_io_status = DIGITAL_IO_STATUS_OK;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if ((handle_ptr->digital_io_handle_array[phase] != NULL) && (digital_io_status == DIGITAL_IO_STATUS_OK))
    {
      /* Initialize IO pin */
      digital_io_status = DIGITAL_IO_Init(handle_ptr->digital_io_handle_array[phase]);
    }
  }

  if (digital_io_status == DIGITAL_IO_STATUS_OK)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
/* Initialize COMP_SLOPE_GEN configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  COMP_SLOPE_GEN_STATUS_t csg_status = COMP_SLOPE_GEN_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if ((handle_ptr->csg_handle_array[phase] != NULL)  && (csg_status == COMP_SLOPE_GEN_STATUS_SUCCESS))
    {
      /* Initialize CCU slice */
      csg_status = COMP_SLOPE_GEN_Init(handle_ptr->csg_handle_array[phase]);
    }
  }

  if (csg_status == COMP_SLOPE_GEN_STATUS_SUCCESS)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Start(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->csg_handle_array[phase] != NULL)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = (BUCK_PCC_FIX_FQ_STATUS_t) COMP_SLOPE_GEN_Start_CSG(handle_ptr->csg_handle_array[phase]);

        if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
        {
          /*  Sets the start value of slope generator */
         status = (BUCK_PCC_FIX_FQ_STATUS_t) COMP_SLOPE_GEN_SetDACStartValue(handle_ptr->csg_handle_array[phase], handle_ptr->config->dac_start_value);
        }
      }
    }
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lCOMP_SLOPE_GEN_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->csg_handle_array[phase] != NULL)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = (BUCK_PCC_FIX_FQ_STATUS_t) COMP_SLOPE_GEN_Stop_CSG(handle_ptr->csg_handle_array[phase]);
      }
    }
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
/* Initialize HRPWM configurations */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lHRPWM_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status;
  HRPWM_STATUS_t hrpwm_status = HRPWM_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if ((handle_ptr->hrpwm_handle_array[phase] != NULL)  && (hrpwm_status == HRPWM_STATUS_SUCCESS))
    {
      /* Initialize CCU8 and HRPWM slice */
      hrpwm_status = HRPWM_Init(handle_ptr->hrpwm_handle_array[phase]);
    }
  }

  if (hrpwm_status == HRPWM_STATUS_SUCCESS)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lHRPWM_Start(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  uint8_t kernel_number;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->hrpwm_handle_array[phase] != NULL)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = (BUCK_PCC_FIX_FQ_STATUS_t) HRPWM_Start(handle_ptr->hrpwm_handle_array[phase]);

        /* Load phase shifted timer value for interleaved buck */
        XMC_CCU8_SLICE_SetTimerValue(handle_ptr->hrpwm_handle_array[phase]->ccu8_slice_ptr, handle_ptr->pwm_config->phase_timer_val[phase]);

        /* Read CCU8 kernel number */
        kernel_number = handle_ptr->hrpwm_handle_array[phase]->kernel_number;

        /* Calculation of kernel position in CCUCON register */
        handle_ptr->ccu_modules |= (uint32_t)1 << ((uint32_t) SCU_GENERAL_CCUCON_GSC80_Pos + kernel_number);

        XMC_GPIO_Init(handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out0_ptr, handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out0_pin,
                      handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out0_config_ptr);

        if(handle_ptr->pwm_config->synch_converter == true)
        {
          XMC_GPIO_Init(handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out1_ptr, handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out1_pin,
                        handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out1_config_ptr);
        }
      }
    }
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED /* XMC4x family */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lHRPWM_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  uint8_t phase;
  BUCK_PCC_FIX_FQ_STATUS_t status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->hrpwm_handle_array[phase] != NULL)
    {
      XMC_GPIO_SetMode(handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out0_ptr,
                       handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out0_pin,
                       XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
      XMC_GPIO_SetOutputLevel(handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out0_ptr,
                              handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out0_pin,
                              handle_ptr->pwm_config->ccu8_output_passive_level);

      if(handle_ptr->pwm_config->synch_converter == true)
      {
        XMC_GPIO_SetMode(handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out1_ptr,
                         handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out1_pin,
                         XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
        XMC_GPIO_SetOutputLevel(handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out1_ptr,
                                handle_ptr->hrpwm_handle_array[phase]->config_ptr->gpio_hr_out1_pin,
                                handle_ptr->pwm_config->ccu8_output_passive_level);
      }
    }
  }

  for (phase = 0U; phase < (uint8_t) handle_ptr->pwm_config->no_of_phases; phase++)
  {
    if (handle_ptr->hrpwm_handle_array[phase] != NULL)
    {
      if (status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
      {
        status = (BUCK_PCC_FIX_FQ_STATUS_t) HRPWM_Stop(handle_ptr->hrpwm_handle_array[phase]);
      }
    }
  }

  return (status);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_RESULT_INT_USED
/* Initialize interrupt */
void BUCK_PCC_FIX_FQ_lInterrupt_Init(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  const BUCK_PCC_FIX_FQ_IntConfig_t *const interrupt_config = handle_ptr->interrupt_config;

#if(UC_FAMILY == XMC4)
  NVIC_SetPriority(interrupt_config->node,
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       (uint32_t)interrupt_config->priority,
                                       (uint32_t)interrupt_config->subpriority));
#else /* For XMC1 devices */
  NVIC_SetPriority(interrupt_config->node, (uint32_t) interrupt_config->priority);
#endif

#if (UC_SERIES == XMC14)
  XMC_SCU_SetInterruptControl((uint8_t)interrupt_config->node,
                              (((uint8_t)interrupt_config->node << 8U) | interrupt_config->irqctrl));
#endif

  XMC_VADC_GROUP_SetResultInterruptNode(handle_ptr->group_ptr_array[0],
                                        (uint32_t)handle_ptr->adc_config->result_register_num_array[0],
                                        interrupt_config->vout_result_ev_srline);
}
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
/* Initializes SYSTIMER APP */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lSYSTIMER_Init(BUCK_PCC_FIX_FQ_t * handle_ptr)
{
  BUCK_PCC_FIX_FQ_STATUS_t status        = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
  SYSTIMER_STATUS_t       systimer_status = SYSTIMER_STATUS_FAILURE;

  systimer_status = SYSTIMER_Init(handle_ptr->systimer_handle);

  if (systimer_status == SYSTIMER_STATUS_SUCCESS)
  {
    handle_ptr->software_timer_id = SYSTIMER_CreateTimer(
                                    handle_ptr->config->systick_timer_period,
                                    SYSTIMER_MODE_PERIODIC,
                                    handle_ptr->config->systimer_call_back,
                                    handle_ptr);

    if (handle_ptr->software_timer_id == 0U) /* Check if the returned timer id is invalid */
    {
      status = BUCK_PCC_FIX_FQ_STATUS_FAILURE; /* Invalid timer */
    }

  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  }
  return status;
}
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
/* Starts the software timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lSYSTIMER_Start(BUCK_PCC_FIX_FQ_t * handle_ptr)
{
  BUCK_PCC_FIX_FQ_STATUS_t status         = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  SYSTIMER_STATUS_t       systimer_status = SYSTIMER_STATUS_FAILURE;

  /* Initialize soft start state */
  handle_ptr->soft_start_complete = false;

  systimer_status = SYSTIMER_StartTimer(handle_ptr->software_timer_id);

  if (systimer_status == SYSTIMER_STATUS_SUCCESS)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
    handle_ptr->software_timer_status = BUCK_PCC_FIX_FQ_SW_TIMER_START_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
    handle_ptr->software_timer_status = BUCK_PCC_FIX_FQ_SW_TIMER_START_FAILED;
  }

  return status;
}
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
/* Stops the software timer */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_lSYSTIMER_Stop(BUCK_PCC_FIX_FQ_t * handle_ptr)
{
  BUCK_PCC_FIX_FQ_STATUS_t status        = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
  SYSTIMER_STATUS_t       systimer_status = SYSTIMER_STATUS_FAILURE;

  /* Reset soft start state */
  handle_ptr->soft_start_complete = false;

  systimer_status = SYSTIMER_StopTimer(handle_ptr->software_timer_id);

  if (systimer_status == SYSTIMER_STATUS_SUCCESS)
  {
    status = BUCK_PCC_FIX_FQ_STATUS_SUCCESS;
    handle_ptr->software_timer_status = BUCK_PCC_FIX_FQ_SW_TIMER_STOP_SUCCESS;
  }
  else
  {
    status = BUCK_PCC_FIX_FQ_STATUS_FAILURE;
    handle_ptr->software_timer_status = BUCK_PCC_FIX_FQ_SW_TIMER_STOP_FAILED;
  }

  return status;
}
#endif

/* Clears the variables used by the compensator */
void BUCK_PCC_FIX_FQ_lClearCompensatorVariables(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  handle_ptr->buck_vout           = BUCK_PCC_FIX_FQ_CLEAR_U; /* Clears feedback. fdbk_ptr points to buck_vout */

  if (handle_ptr->config->soft_start_enable == true)
  {
    /* Soft start is selected, reference needs to be started from zero */
    handle_ptr->vout_reference    = BUCK_PCC_FIX_FQ_CLEAR_U; /* Clears reference. ref_ptr points to vout_reference */
  }

  /* Reset Type II filter variables */
#ifdef BUCK_PCC_FIX_FQ_TYPE_II_FILTER_USED
  if (handle_ptr->config->filter == BUCK_PCC_FIX_FQ_FILTER_TYPE_II)
  {
    handle_ptr->typeII->x_0       = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeII->x_1       = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeII->y_0       = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeII->y_1       = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeII->out       = BUCK_PCC_FIX_FQ_CLEAR_I;
  }
#endif

  /* Reset Type III filter variables */
#ifdef BUCK_PCC_FIX_FQ_TYPE_III_FILTER_USED
  if (handle_ptr->config->filter == BUCK_PCC_FIX_FQ_FILTER_TYPE_III)
  {
    handle_ptr->typeIII->x_0      = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeIII->x_1      = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeIII->x_2      = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeIII->y_0      = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeIII->y_1      = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeIII->y_2      = BUCK_PCC_FIX_FQ_CLEAR_I;
    handle_ptr->typeIII->out      = BUCK_PCC_FIX_FQ_CLEAR_I;
  }
#endif
}

/* All the timers used in the APP are synchronously started */
void BUCK_PCC_FIX_FQ_lSynchronousStart(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  /* Initialize to a Low state */
  XMC_SCU_SetCcuTriggerLow (handle_ptr->ccu_modules);

  /* Enable synchronous start - The timers under this BUCK APP are started synchronously */
  XMC_SCU_SetCcuTriggerHigh(handle_ptr->ccu_modules);

  /* Disable synchronous start */
  XMC_SCU_SetCcuTriggerLow (handle_ptr->ccu_modules);
}

/* Clears the variables used for Over load protection */
void BUCK_PCC_FIX_FQ_lClearOverloadProtectionVariables(BUCK_PCC_FIX_FQ_t *handle_ptr)
{
  handle_ptr->enable_load_protection     = false;
  handle_ptr->vout_avg                   = BUCK_PCC_FIX_FQ_CLEAR_U;
  handle_ptr->vin_avg                    = BUCK_PCC_FIX_FQ_CLEAR_U;
  handle_ptr->iout1_avg                  = BUCK_PCC_FIX_FQ_CLEAR_U;
  handle_ptr->iout2_avg                  = BUCK_PCC_FIX_FQ_CLEAR_U;
  handle_ptr->iout3_avg                  = BUCK_PCC_FIX_FQ_CLEAR_U;
  handle_ptr->iout4_avg                  = BUCK_PCC_FIX_FQ_CLEAR_U;
}
