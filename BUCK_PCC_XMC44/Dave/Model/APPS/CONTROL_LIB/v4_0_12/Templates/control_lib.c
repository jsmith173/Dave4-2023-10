/**
 * @file contol_lib.c
 * @date 2016-02-03
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * CONTROL_LIB v4.0.12 - APP provides Type II, Type III libraries for Digital Power Conversion
 *
 * Copyright (c) 2016-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-11-27:
 *     - Initial version for DAVEv4
 *
 * 2016-02-03:
 *     - PI functions are removed
 *
 * 2016-07-07:
 *     - Added APIs for Square root, Moving Average filter and PI controller.
 *     - Fix in output scaling of CONTROL_LIB_2P2ZFixedPointInit() and CONTROL_LIB_3P3ZFixedPointInit() APIs.
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "control_lib.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/

/**********************************************************************************************************************
 * API IMPLEMENTATION
 ***********************************************************************************************************************/

/* API to retrieve driver version info */
DAVE_APP_VERSION_t CONTROL_LIB_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = CONTROL_LIB_MAJOR_VERSION;
  version.minor = CONTROL_LIB_MINOR_VERSION;
  version.patch = CONTROL_LIB_PATCH_VERSION;

  return version;
}

/*********************************************************************************************************************/

/* Calculates a second order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_2P2ZFloatInit(CONTROL_LIB_2P2Z_DATA_FLOAT_t* handle_ptr,
                                 volatile float* ref_ptr, volatile float* fdbk_ptr,
                                 float b0, float b1, float b2,
                                 float a1, float a2, float k,
                                 float limit_min, float limit_max)
{
  memset(handle_ptr, 0, sizeof(*handle_ptr));

  handle_ptr->fdbk_ptr = fdbk_ptr; /**< pointer to ADC register which is used for feedback */
  handle_ptr->ref_ptr = ref_ptr; /**< ADC ref */
  handle_ptr->coeff_b0 = b0 * k; /*coefficient filter current input*/
  handle_ptr->coeff_b1 = b1 * k; /*coefficient filter input one previous*/
  handle_ptr->coeff_b2 = b2 * k; /*coefficient filter input two previous*/
  handle_ptr->coeff_a1 = a1; /*coefficient filter output one previous*/
  handle_ptr->coeff_a2 = a2; /*coefficient filter output two previous*/
  handle_ptr->out_limit_max = limit_max; /*maximum output saturation*/
  handle_ptr->out_limit_min = limit_min; /*output saturation min for filter implementation*/
  handle_ptr->out_limit_imin = -limit_max; /*minimum output saturation*/

  handle_ptr->m_k = k;
  handle_ptr->out = 0.0f;
}

/* Calculates a second order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_2P2ZFloat(CONTROL_LIB_2P2Z_DATA_FLOAT_t* handle_ptr)
{
  float acc;

  acc = handle_ptr->coeff_b2 * handle_ptr->x_1;
  handle_ptr->x_1 = handle_ptr->x_0;
  acc += handle_ptr->coeff_b1 * handle_ptr->x_0;

  handle_ptr->x_0 = (float)*handle_ptr->ref_ptr;
  handle_ptr->x_0 = handle_ptr->x_0 - (float)*handle_ptr->fdbk_ptr;

  acc += handle_ptr->coeff_b0 * handle_ptr->x_0;

  acc += handle_ptr->coeff_a2 * handle_ptr->y_1;
  handle_ptr->y_1 = handle_ptr->y_0;
  acc += handle_ptr->coeff_a1 * handle_ptr->y_0;

  acc = CONTROL_LIB_FloatMin(acc, handle_ptr->out_limit_max);
  acc = CONTROL_LIB_FloatMax(acc, handle_ptr->out_limit_imin);

  handle_ptr->y_0 = acc;

  acc = CONTROL_LIB_FloatMax(acc, handle_ptr->out_limit_min);

  handle_ptr->out = acc;
}

/*******************************************************************************************************************/

/* Initializes a second order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_2P2ZFixedPointInit(CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t* handle_ptr,
                                      volatile int16_t* ref_ptr, volatile int16_t* fdbk_ptr,
                                      float b0, float b1, float b2,
                                      float a1, float a2, float k,
                                      int16_t coeff_fract_bits_b, int16_t xn_fract_bits,
                                      int16_t coeff_fract_bits_a, int16_t yn_fract_bits,
                                      int16_t out_fract_bits,
                                      int32_t limit_min, int32_t limit_max)
{
  memset((void *)handle_ptr, 0, sizeof(*handle_ptr));

  handle_ptr->fdbk_ptr = fdbk_ptr;
  handle_ptr->ref_ptr = ref_ptr;

  handle_ptr->coeff_b2 = CONTROL_LIB_FloatToFix(b2 * k, (uint16_t) coeff_fract_bits_b);
  handle_ptr->coeff_b1 = CONTROL_LIB_FloatToFix(b1 * k, (uint16_t) coeff_fract_bits_b);
  handle_ptr->coeff_b0 = CONTROL_LIB_FloatToFix(b0 * k, (uint16_t) coeff_fract_bits_b);

  handle_ptr->coeff_a2 = CONTROL_LIB_FloatToFix(a2, (uint16_t) coeff_fract_bits_a);
  handle_ptr->coeff_a1 = CONTROL_LIB_FloatToFix(a1, (uint16_t) coeff_fract_bits_a);

  handle_ptr->out_limit_max = limit_max;
  handle_ptr->out_limit_imin = -limit_max;
  handle_ptr->out_limit_min = limit_min;

  handle_ptr->scale_b = (xn_fract_bits + coeff_fract_bits_b) - out_fract_bits;
  handle_ptr->scale_a = (yn_fract_bits + coeff_fract_bits_a) - (coeff_fract_bits_b + xn_fract_bits);
  handle_ptr->scale_out = out_fract_bits;
}

/* Calculates a second order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_2P2ZFixedPoint(CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t* handle_ptr)
{
  int32_t acc;

  acc = handle_ptr->coeff_a2 * handle_ptr->y_1;
  handle_ptr->y_1 = handle_ptr->y_0;
  acc += handle_ptr->coeff_a1 * handle_ptr->y_0;
  acc = acc >> (uint16_t) handle_ptr->scale_a;

  acc += handle_ptr->coeff_b2 * handle_ptr->x_1;
  handle_ptr->x_1 = handle_ptr->x_0;
  acc += handle_ptr->coeff_b1 * handle_ptr->x_0;

  handle_ptr->x_0 = (int16_t)*handle_ptr->ref_ptr;
  handle_ptr->x_0 = handle_ptr->x_0 - (int16_t)*handle_ptr->fdbk_ptr;

  acc += handle_ptr->coeff_b0 * handle_ptr->x_0;

  acc = acc >> (uint16_t) handle_ptr->scale_b;

  acc = CONTROL_LIB_FixMin(acc, handle_ptr->out_limit_max);
  acc = CONTROL_LIB_FixMax(acc, handle_ptr->out_limit_imin);

  handle_ptr->y_0 = acc;

  acc = acc >> (uint16_t) handle_ptr->scale_out;

  acc = CONTROL_LIB_FixMax(acc, handle_ptr->out_limit_min);

  handle_ptr->out = acc;
}

/*********************************************************************************************************************/

/* Calculates a third order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_3P3ZFloatInit(CONTROL_LIB_3P3Z_DATA_FLOAT_t* handle_ptr,
                                 volatile float* ref_ptr, volatile float* fdbk_ptr,
                                 float b0, float b1, float b2, float b3,
                                 float a1, float a2, float a3, float k,
                                 float limit_min, float limit_max)
{
  memset((void *)handle_ptr, 0, sizeof(*handle_ptr));

  handle_ptr->fdbk_ptr = fdbk_ptr; /**< pointer to ADC register which is used for feedback */
  handle_ptr->ref_ptr = ref_ptr; /**< ADC ref */
  handle_ptr->coeff_b0 = b0 * k; /*coefficient filter current input*/
  handle_ptr->coeff_b1 = b1 * k; /*coefficient filter input one previous*/
  handle_ptr->coeff_b2 = b2 * k; /*coefficient filter input two previous*/
  handle_ptr->coeff_b3 = b3 * k; /*coefficient filter input three previous*/
  handle_ptr->coeff_a1 = a1; /*coefficient filter output one previous*/
  handle_ptr->coeff_a2 = a2; /*coefficient filter output two previous*/
  handle_ptr->coeff_a3 = a3; /*coefficient filter output three previous*/
  handle_ptr->out_limit_max = limit_max; /*maximum output saturation*/
  handle_ptr->out_limit_min = limit_min; /*output saturation min for filter implementation*/
  handle_ptr->out_limit_imin = -limit_max; /*minimum output saturation*/

  handle_ptr->m_k = k;
  handle_ptr->out = 0.0f;
}

/* Calculates a third order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_3P3ZFloat(CONTROL_LIB_3P3Z_DATA_FLOAT_t* handle_ptr)
{
  float acc;

  acc = handle_ptr->coeff_b3 * handle_ptr->x_2;
  handle_ptr->x_2 = handle_ptr->x_1;
  acc += handle_ptr->coeff_b2 * handle_ptr->x_1;
  handle_ptr->x_1 = handle_ptr->x_0;
  acc += handle_ptr->coeff_b1 * handle_ptr->x_0;

  handle_ptr->x_0 = (float)*handle_ptr->ref_ptr;
  handle_ptr->x_0 = handle_ptr->x_0 - (float)*handle_ptr->fdbk_ptr;

  acc += handle_ptr->coeff_b0 * handle_ptr->x_0;

  acc += handle_ptr->coeff_a3 * handle_ptr->y_2;
  handle_ptr->y_2 = handle_ptr->y_1;
  acc += handle_ptr->coeff_a2 * handle_ptr->y_1;
  handle_ptr->y_1 = handle_ptr->y_0;
  acc += handle_ptr->coeff_a1 * handle_ptr->y_0;

  acc = CONTROL_LIB_FloatMin(acc, handle_ptr->out_limit_max);
  acc = CONTROL_LIB_FloatMax(acc, handle_ptr->out_limit_imin);

  handle_ptr->y_0 = acc;

  acc = CONTROL_LIB_FloatMax(acc, handle_ptr->out_limit_min);

  handle_ptr->out = acc;
}

/*******************************************************************************************************************/
/* Initializes a third order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_3P3ZFixedPointInit(CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t* handle_ptr,
                                      volatile int16_t* ref_ptr, volatile int16_t* fdbk_ptr,
                                      float b0, float b1, float b2, float b3,
                                      float a1, float a2, float a3, float k,
                                      int16_t coeff_fract_bits_b, int16_t xn_fract_bits,
                                      int16_t coeff_fract_bits_a, int16_t yn_fract_bits,
                                      int16_t out_fract_bits,
                                      int32_t limit_min, int32_t limit_max)
{
  memset((void *)handle_ptr, 0, sizeof(*handle_ptr));

  handle_ptr->fdbk_ptr = fdbk_ptr;
  handle_ptr->ref_ptr = ref_ptr;

  handle_ptr->coeff_b3 = CONTROL_LIB_FloatToFix(b3 * k, (uint16_t) coeff_fract_bits_b);
  handle_ptr->coeff_b2 = CONTROL_LIB_FloatToFix(b2 * k, (uint16_t) coeff_fract_bits_b);
  handle_ptr->coeff_b1 = CONTROL_LIB_FloatToFix(b1 * k, (uint16_t) coeff_fract_bits_b);
  handle_ptr->coeff_b0 = CONTROL_LIB_FloatToFix(b0 * k, (uint16_t) coeff_fract_bits_b);

  handle_ptr->coeff_a3 = CONTROL_LIB_FloatToFix(a3, (uint16_t) coeff_fract_bits_a);
  handle_ptr->coeff_a2 = CONTROL_LIB_FloatToFix(a2, (uint16_t) coeff_fract_bits_a);
  handle_ptr->coeff_a1 = CONTROL_LIB_FloatToFix(a1, (uint16_t) coeff_fract_bits_a);

  handle_ptr->out_limit_max = limit_max;
  handle_ptr->out_limit_imin = -limit_max;
  handle_ptr->out_limit_min = limit_min;

  handle_ptr->scale_b = (xn_fract_bits + coeff_fract_bits_b) - out_fract_bits;
  handle_ptr->scale_a = (yn_fract_bits + coeff_fract_bits_a) - (coeff_fract_bits_b + xn_fract_bits);
  handle_ptr->scale_out = out_fract_bits;
}

/* Calculates a third order control law with IIR filter and programmable output saturation. */
void CONTROL_LIB_3P3ZFixedPoint(CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t* handle_ptr)
{
  int32_t acc;

  acc = handle_ptr->coeff_a3 * handle_ptr->y_2;
  handle_ptr->y_2 = handle_ptr->y_1;
  acc += handle_ptr->coeff_a2 * handle_ptr->y_1;
  handle_ptr->y_1 = handle_ptr->y_0;
  acc += handle_ptr->coeff_a1 * handle_ptr->y_0;
  acc = acc >> (uint16_t) handle_ptr->scale_a;

  acc += handle_ptr->coeff_b3 * handle_ptr->x_2;
  handle_ptr->x_2 = handle_ptr->x_1;
  acc += handle_ptr->coeff_b2 * handle_ptr->x_1;
  handle_ptr->x_1 = handle_ptr->x_0;
  acc += handle_ptr->coeff_b1 * handle_ptr->x_0;

  handle_ptr->x_0 = (int16_t)*handle_ptr->ref_ptr;
  handle_ptr->x_0 = handle_ptr->x_0 - (int16_t)*handle_ptr->fdbk_ptr;

  acc += handle_ptr->coeff_b0 * handle_ptr->x_0;

  acc = acc >> (uint16_t) handle_ptr->scale_b;

  acc = CONTROL_LIB_FixMin(acc, handle_ptr->out_limit_max);
  acc = CONTROL_LIB_FixMax(acc, handle_ptr->out_limit_imin);
  handle_ptr->y_0 = acc;

  acc = acc >> (uint16_t) handle_ptr->scale_out;
  acc = CONTROL_LIB_FixMax(acc, handle_ptr->out_limit_min);
  handle_ptr->out = acc;
}

/*********************************************************************************************************************/
/* Initializes a PI controller with anti-windup scheme and programmable output limit saturation. */
void CONTROL_LIB_PIFloatInit(CONTROL_LIB_PI_DATA_FLOAT_t* handle_ptr,
                                   volatile uint32_t* ref_ptr, volatile uint32_t* fdbk_ptr,
                                   float kp, float ki,
                                   float limit_min, float limit_max,
								   volatile uint32_t* out)
{
  memset((void *)handle_ptr, 0, sizeof(*handle_ptr));

  handle_ptr->fdbk_ptr = fdbk_ptr; /**< pointer to ADC register which is used for feedback */
  handle_ptr->ref_ptr = ref_ptr; /**< ADC ref */
  handle_ptr->kp = kp; /*coefficient filter current input*/
  handle_ptr->ki = ki; /*coefficient filter input one previous*/
  handle_ptr->out_limit_max = limit_max; /*maximum output saturation*/
  handle_ptr->out_limit_min = limit_min; /*output saturation min for filter implementation*/
  handle_ptr->out = out;
}




/*******************************************************************************************************************/
/* Initializes a PI controller with anti-windup scheme and programmable output limit saturation. */
void CONTROL_LIB_PIFixedPointInit(CONTROL_LIB_PI_DATA_FIXED_POINT_t* handle_ptr,
                                   volatile uint32_t* ref_ptr, volatile uint32_t* fdbk_ptr,
                                   float kp, float ki,
                                   int16_t fract_bits_kp, int16_t fract_bits_ki,
                                   int16_t fract_bits_error, int16_t fract_bits_uk,
								   int16_t fract_bits_out,
                                   int32_t limit_min, int32_t limit_max,
								    volatile uint32_t* out)
{
  memset((void *)handle_ptr, 0, sizeof(*handle_ptr));

  handle_ptr->fdbk_ptr = fdbk_ptr; /**< pointer to ADC register which is used for feedback */
  handle_ptr->ref_ptr = ref_ptr; /**< ADC ref */

  handle_ptr->kp = CONTROL_LIB_FloatToFix(kp, (uint16_t)fract_bits_kp);
  handle_ptr->ki = CONTROL_LIB_FloatToFix(ki, (uint16_t)fract_bits_ki);

  handle_ptr->out_limit_max = (limit_max << fract_bits_uk); /*maximum output saturation*/
  handle_ptr->out_limit_min = (limit_min << fract_bits_uk); /*output saturation min for filter implementation*/

  handle_ptr->scale_i = (fract_bits_ki - fract_bits_kp);
  handle_ptr->scale_out = (fract_bits_uk - fract_bits_out);

  handle_ptr->out = out;

}

/*********************************************************************************************************************/

