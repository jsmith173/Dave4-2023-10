/**
 * @file contol_lib.h
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * CONTROL_LIB v4.0.12 - APP provides Type II, Type III libraries for Digital Power Conversion
 *
 * Copyright (c) 2016-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-11-27:
 *     - Initial version for DAVEv4
 *
 * 2016-02-03:
 *     - PI data structures are removed
 *
 * 2016-07-07:
 *     - Added APIs for Square root, Moving Average filter and PI controller functionalities.
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */

#ifndef CONTROL_LIB_H_
#define CONTROL_LIB_H_

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "xmc_common.h"
#include "DAVE_Common.h"
#include "control_lib_extern.h"

/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define CONTROL_LIB_XMC_LIB_MAJOR_VERSION 2
#define CONTROL_LIB_XMC_LIB_MINOR_VERSION 0
#define CONTROL_LIB_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > CONTROL_LIB_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == CONTROL_LIB_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > CONTROL_LIB_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == CONTROL_LIB_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == CONTROL_LIB_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= CONTROL_LIB_XMC_LIB_PATCH_VERSION)))
#error "CONTROL_LIB requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/

/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/
/**
 * @ingroup CONTROL_LIB_datastructures
 * @{
 */

/**
 * @brief Two-pole two-zero floating point data & coefficients structure
 */
typedef struct CONTROL_LIB_2P2Z_DATA_FLOAT{
  volatile float* fdbk_ptr; /*!< Pointer to feedback */
  volatile float* ref_ptr; /*!< Pointer to reference */

  float coeff_b0; /*!< coefficient filter for current input*/
  float coeff_b1; /*!< coefficient filter for input one previous*/
  float coeff_b2; /*!< coefficient filter for input two previous*/

  float coeff_a1; /*!< coefficient filter for output one previous*/
  float coeff_a2; /*!< coefficient filter for output two previous*/

  float out_limit_max; /*!< maximum output saturation*/
  float out_limit_imin; /*!< output saturation min for filter implementation*/
  float out_limit_min; /*!< minimum output saturation*/

  float m_k; /*!<  DC gain*/

  float x_0; /*!< filter current input*/
  float x_1; /*!< filter input one previous*/

  float y_0; /*!< filter current output*/
  float y_1; /*!< filter output one previous*/

  float out; /*!< filter output after saturation*/

} CONTROL_LIB_2P2Z_DATA_FLOAT_t;

/**
 * @brief Two-pole two-zero fixed point data & coefficients structure
 */
typedef struct CONTROL_LIB_2P2Z_DATA_FIXED_POINT{
  volatile int16_t* fdbk_ptr;
  volatile int16_t* ref_ptr;

  int32_t coeff_b0; /*!< coefficient filter for current input*/
  int32_t coeff_b1; /*!< coefficient filter for input one previous*/
  int32_t coeff_b2; /*!< coefficient filter for input two previous*/

  int32_t coeff_a1; /*!< coefficient filter for output one previous*/
  int32_t coeff_a2; /*!< coefficient filter for output two previous*/

  int32_t x_0; /*!< filter current input*/
  int32_t x_1; /*!< filter input one previous*/

  int32_t y_0; /*!< filter current output*/
  int32_t y_1; /*!< filter output one previous*/

  int32_t out_limit_max; /*!< maximum output saturation*/
  int32_t out_limit_min; /*!< output saturation min for filter implementation*/
  int32_t out_limit_imin; /*!< minimum output saturation*/

  int16_t scale_a; /*!< fraction bit adjustment for product of y[n] and output coefficient*/
  int16_t scale_b; /*!< fraction bit adjustment for product of x[n] and input coefficient*/
  int16_t scale_out; /*!< fraction bit adjustment for output*/

  int32_t out; /*!< filter output*/

} CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t;

/**
 * @brief Three-pole three-zero floating point data & coefficients structure
 */
typedef struct CONTROL_LIB_3P3Z_DATA_FLOAT{
  volatile float* fdbk_ptr; /*!< Pointer to feedback */
  volatile float* ref_ptr; /*!< Pointer to reference */

  float coeff_b0; /*!< coefficient filter for current input*/
  float coeff_b1; /*!< coefficient filter for input one previous*/
  float coeff_b2; /*!< coefficient filter for input two previous*/
  float coeff_b3; /*!< coefficient filter for input three previous*/

  float coeff_a1; /*!< coefficient filter for output one previous*/
  float coeff_a2; /*!< coefficient filter for output two previous*/
  float coeff_a3; /*!< coefficient filter for output three previous*/

  float out_limit_max; /*!< maximum output saturation*/
  float out_limit_min; /*!< output saturation min for filter implementation*/
  float out_limit_imin; /*!< minimum output saturation*/

  float m_k; /*!< DC gain*/

  float x_0; /*!< filter current input*/
  float x_1; /*!< filter input one previous*/
  float x_2; /*!< filter input two previous*/

  float y_0; /*!< filter current output*/
  float y_1; /*!< filter output one previous*/
  float y_2; /*!< filter output two previous*/

  float out; /*!< filter output after saturation*/

} CONTROL_LIB_3P3Z_DATA_FLOAT_t;

/**
 * @brief Three-pole three-zero fixed point data & coefficients structure
 */
typedef struct CONTROL_LIB_3P3Z_DATA_FIXED_POINT{
  volatile int16_t* fdbk_ptr;
  volatile int16_t* ref_ptr;

  int32_t coeff_b0; /*!< coefficient filter for current input*/
  int32_t coeff_b1; /*!< coefficient filter for input one previous*/
  int32_t coeff_b2; /*!< coefficient filter for input two previous*/
  int32_t coeff_b3; /*!< coefficient filter for input three previous*/

  int32_t coeff_a1; /*!< coefficient filter for output one previous*/
  int32_t coeff_a2; /*!< coefficient filter for output two previous*/
  int32_t coeff_a3; /*!< coefficient filter for output three previous*/

  int32_t x_0; /*!< filter current input*/
  int32_t x_1; /*!< filter input one previous*/
  int32_t x_2; /*!< filter input two previous*/

  int32_t y_0; /*!< filter current output*/
  int32_t y_1; /*!< filter output one previous*/
  int32_t y_2; /*!< filter output two previous*/

  int32_t out_limit_max; /*!< maximum output saturation*/
  int32_t out_limit_min; /*!< output saturation min for filter implementation*/
  int32_t out_limit_imin; /*!< minimum output saturation*/

  int16_t scale_a; /*!< fraction bit adjustment for product of y[n] and output coefficient*/
  int16_t scale_b; /*!< fraction bit adjustment for product of x[n] and input coefficient*/
  int16_t scale_out; /*!< fraction bit adjustment for output*/

  int32_t out; /*!< filter output after saturation*/

} CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t;

/**
* @brief PI floating point data & coefficients structure
*/
typedef struct CONTROL_LIB_PI_DATA_FLOAT
{
  volatile uint32_t* fdbk_ptr;           /**< Pointer to feedback, generally ADC result register*/
  volatile uint32_t* ref_ptr;            /**< Pointer to reference */

  float  error;                /*!< PI error signal (reference value - feedback value), error[k] */
  float  kp;                   /*!< Proportional gain Kp constant */
  float  ki;                   /*!< Integral gain Ki constant*/

  float  out_limit_max;        /*!< Maximum value of the PI output */
  float  out_limit_min;        /*!< Minimum value of the PI output */

  float  uk;                 /*!< PI output U[k] */
  float  ik;                   /*!< Integral result I[k] */
  float  ik_1;                 /*!< Integral result I[k-1] */

  volatile uint32_t* out;     /*!< PI Output after anti-windup scheme */

} CONTROL_LIB_PI_DATA_FLOAT_t;

/**
* @brief PI fixed point data & coefficients structure
*/
typedef struct CONTROL_LIB_PI_DATA_FIXED_POINT
{
  volatile uint32_t* fdbk_ptr;           /**< Pointer to feedback, generally ADC result register*/
  volatile uint32_t* ref_ptr;            /**< Pointer to reference */

  int32_t  error;              /*!< PI error signal (reference value - feedback value), error[k] */
  int32_t  kp;                 /*!< Proportional gain Kp constant */
  int32_t  ki;                 /*!< Integral gain Ki constant*/

  int32_t  out_limit_max;      /*!< Maximum value of the PI output */
  int32_t  out_limit_min;      /*!< Minimum value of the PI output */

  int32_t  uk;                 /*!< PI output U[k] */
  int32_t  ik;                 /*!< Integral result I[k] */
  int32_t  ik_1;               /*!< Integral result I[k-1] */

  int16_t  scale_i;           /*!< fraction bit adjustment for i[k] */
  int16_t  scale_out;         /*!< fraction bit adjustment for u[k]*/

  volatile uint32_t* out;     /*!< PI Output after anti-windup scheme */

} CONTROL_LIB_PI_DATA_FIXED_POINT_t;

/**
 * @brief Moving average fixed point data structure
*/
typedef struct CONTROL_LIB_MOVING_AVERAGE_FIXED_POINT
{
   int32_t  out_avg;
   int32_t  input_avg;
   int32_t  num_samples;

} CONTROL_LIB_MOVING_AVERAGE_FIXED_POINT_t;
/**
 * @}
 */

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/* Support for C++ */
#ifdef __cplusplus
extern "C" {
#endif

/**
 * @ingroup CONTROL_LIB_apidoc
 * @{
 */

/**
 * @brief Retrieves the version of the CONTROL_LIB APP.
 * @param None
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_APP_VERSION_t version;
 * 
 *   version = CONTROL_LIB_GetAppVersion();
 * 
 *   if (version.major != 4U)
 *   {
 *     // Probably, not the right version.
 *   }
 * 
 *   while(1)
 *   {
 * 
 *   }
 *   return (0);
 * 
 * }
 * @endcode
 */
DAVE_APP_VERSION_t CONTROL_LIB_GetAppVersion(void);

/*********************************************************************************************************************/
/**
 * @brief Converts an integer with decimal point defined to floating point.
 * @param i Integer with decimal point defined to be converted to floating point.
 * @param q Number of bits defined for decimal part.
 *
 * \par<b>Description: </b><br>
 * The function can be used to converts an integer with decimal point defined to floating point.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   int32_t decimal_3V3 = 3375; // 3.3 with 10 bits for decimal;
 *   float   float_3V3;
 * 
 *   float_3V3 = CONTROL_LIB_FixToFloat(decimal_3V3 , 10);
 *   while(1)
 *   {
 * 
 *   }
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE float CONTROL_LIB_FixToFloat(int32_t i, uint16_t q)
{
  float result;
  uint16_t den;

  den = 1U << q;
  den = den - 1U;
  result = (float) i;
  result = result / (float) den;
  return (result);
}

/*********************************************************************************************************************/
/**
 * @brief Converts a float to a integer with decimal point defined.
 * @param f floating point number to be converted to scaled integer.
 * @param q Number of bits defined for decimal part.
 *
 * \par<b>Description: </b><br>
 * The function can be used to converts an integer with decimal point defined to floating point.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   int32_t decimal_3V3;
 *   float   float_3V3 = 3.3f;
 * 
 *   decimal_3V3 = CONTROL_LIB_FloatToFix(float_3V3 , 10);
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE int32_t CONTROL_LIB_FloatToFix(float f, uint16_t q)
{
  int32_t result;
  uint32_t num;

  num = 1U << q;
  num = num - 1U;
  f = f * (float) num;
  result = (int32_t) f;
  return (result);
}

/*********************************************************************************************************************/
/**
 * @brief Returns the lower value among two floating point numbers.
 * @param a floating point number 1 to be compared.
 * @param b floating point number 2 to be compared.
 *
 * \par<b>Description: </b><br>
 * The function can be used find the lower value number amount two floating point numbers.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   float   a = 100.0f;
 *   float   b = 120.0f;
 *   float   c;
 * 
 *   c = CONTROL_LIB_FloatMin(a, b);
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE float CONTROL_LIB_FloatMin(float a, float b)
{
  return (((a) < (b)) ? (a) : (b));
}

/*********************************************************************************************************************/
/**
 * @brief Returns the higher value among two floating point numbers.
 * @param a floating point number 1 to be compared.
 * @param b floating point number 2 to be compared.
 *
 * \par<b>Description: </b><br>
 * The function can be used find the higher value number amount two floating point numbers.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   float   a = 100.0f;
 *   float   b = 120.0f;
 *   float   c;
 * 
 *   c = CONTROL_LIB_FloatMax(a, b);
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE float CONTROL_LIB_FloatMax(float a, float b)
{
  return (((a) > (b)) ? (a) : (b));
}

/*********************************************************************************************************************/
/**
 * @brief Returns the lower value among two fixed point numbers.
 * @param a fixed point number 1 to be compared.
 * @param b fixed point number 2 to be compared.
 *
 * \par<b>Description: </b><br>
 * The function can be used find the lower value number amount two fixed point numbers.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   int32_t   a = 100;
 *   int32_t   b = 120;
 *   int32_t   c;
 * 
 *   c = CONTROL_LIB_FixMin(a, b);
 * 
 *   while(1)
 *   {
 *   }
 * return 0;
 * }
 * @endcode
 */
__STATIC_INLINE int32_t CONTROL_LIB_FixMin(int32_t a, int32_t b)
{
  return (((a) < (b)) ? (a) : (b));
}

/*********************************************************************************************************************/
/**
 * @brief Returns the higher value among two fixed point numbers.
 * @param a fixed point number 1 to be compared.
 * @param b fixed point number 2 to be compared.
 *
 * \par<b>Description: </b><br>
 * The function can be used find the higher value number amount two fixed point numbers.
 *
 * Example Usage:
 * @code
#include "DAVE.h"

int main(void)
{
  int32_t   a = 100;
  int32_t   b = 120;
  int32_t   c;

  c = CONTROL_LIB_FixMax(a, b);

  while(1)
  {
  }
  return 0;
}
 * @endcode
 */
__STATIC_INLINE int32_t CONTROL_LIB_FixMax(int32_t a, int32_t b)
{
  return (((a) > (b)) ? (a) : (b));
}

/*********************************************************************************************************************/

/**
 * @brief Initializes the data structure of CONTROL_LIB_2P2ZFloat() API.
 * @param handle_ptr   pointer to CONTROL_LIB_2P2Z_DATA_FLOAT_t structure
 * @param b0 coefficient filter for input current
 * @param b1 coefficient filter for input one previous
 * @param b2 coefficient filter for input two previous
 * @param a1 coefficient filter for output one previous
 * @param a2 coefficient filter for output two previous
 * @param limit_max maximum output saturation
 * @param limit_min minimum output saturation
 * @param k DC gain
 * @param ref_ptr Pointer to reference voltage variable
 * @param fdbk_ptr pointer to feedback variable
 *
 * \par<b>Description: </b><br>
 * The function can be used to initialize the data structure CONTROL_LIB_2P2Z_DATA_FLOAT_t used by CONTROL_LIB_2P2ZFloat() API.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   float ref       = 3247.1304f;             //reference voltage 3.3 volts in steps of ADC
 *   float vout      = 2702.5139f;             //measured feedback voltage 3 volts in steps of ADC
 *   float b0        = 2.226044f;              //coefficient filter for current input
 *   float b1        = 0.110847f;              //coefficient filter for input one previous
 *   float b2        = -2.115196f;             //coefficient filter for input two previous
 *   float a1        = 1.833333f;              //coefficient filter for output one previous
 *   float a2        = -0.833333f;             //coefficient filter for output two previous
 *   float limit_max = 1023.0f;                //maximum output saturation
 *   float limit_min = 155.0f;                 //output saturation min for filter implementation
 *   float k         = 0.3140570f;             //DC gain
 *   CONTROL_LIB_2P2Z_DATA_FLOAT_t data_p2z2;  //control data structure
 * 
 *   CONTROL_LIB_2P2ZFloatInit(&data_p2z2,
 *                             &ref, &vout,
 *                             b0, b1, b2,
 *                             a1, a2,
 *                             k,
 *                             limit_min, limit_max
 *                             );
 * 
 *   CONTROL_LIB_2P2ZFloat(&data_p2z2);
 * 
 *   compare_value = (uint16_t)data_p2z2.out;
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_2P2ZFloatInit(CONTROL_LIB_2P2Z_DATA_FLOAT_t* handle_ptr,
                               volatile float* ref_ptr, volatile float* fdbk_ptr,
                               float b0, float b1, float b2,
                               float a1, float a2, float k,
                               float limit_min, float limit_max);

/*********************************************************************************************************************/

/**
 * @brief Calculates a second order control law with IIR filter with programmable output saturation.
 * @param handle_ptr CONTROL_LIB_2P2Z_DATA_FLOAT_t structure with proper coefficient values.
 *
 * \par<b>Description: </b><br>
 * The function can be used to implement control using 2 pole 2 zero filter. The computation is done in float point.
 *
 *  Y(z)   b0(z) + b1(z-1) + b2(z-2)   <br>
 *  --- = ---------------------------  <br>
 *  X(z)     1   - a1(z-1) - a2(z-2)   <br>
 *
 *  y[n] - a1y[n-1] - a2y[n-2] = b0x[n] + b1x[n-1] + b2x[n-2] <br>
 *
 *  y[n] = b0x[n] + b1x[n-1] + b2x[n-2] + a1y[n-1] + a2y[n-2] <br>
 *
 *  where x[n] = ref - fdbk;
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   float ref       = 3247.1304f;             //reference voltage 3.3 volts in steps of ADC
 *   float vout      = 2702.5139f;             //measured feedback voltage 3 volts in steps of ADC
 *   float b0        = 2.226044f;              //coefficient filter for current input
 *   float b1        = 0.110847f;              //coefficient filter for input one previous
 *   float b2        = -2.115196f;             //coefficient filter for input two previous
 *   float a1        = 1.833333f;              //coefficient filter for output one previous
 *   float a2        = -0.833333f;             //coefficient filter for output two previous
 *   float limit_max = 1023.0f;                //maximum output saturation
 *   float limit_min = 155.0f;                 //output saturation min for filter implementation
 *   float k         = 0.3140570f;             //DC gain
 *   CONTROL_LIB_2P2Z_DATA_FLOAT_t data_p2z2;  //control data structure
 * 
 *   CONTROL_LIB_2P2ZFloatInit(&data_p2z2,
 *                             &ref, &vout,
 *                             b0, b1, b2,
 *                             a1, a2,
 *                             k,
 *                             limit_min, limit_max
 *                             );
 * 
 *   CONTROL_LIB_2P2ZFloat(&data_p2z2);
 * 
 *   compare_value = (uint16_t)data_p2z2.out;
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_2P2ZFloat(CONTROL_LIB_2P2Z_DATA_FLOAT_t* handle_ptr);

/*********************************************************************************************************************/
/**
 * @brief Initializes the data structure of CONTROL_LIB_2P2ZFixedPoint() API.
 * @param handle_ptr   pointer to CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t structure
 * @param b0 coefficient filter for current input
 * @param b1 coefficient filter for input one previous
 * @param b2 coefficient filter for input two previous
 * @param a1 coefficient filter for output one previous
 * @param a2 coefficient filter for output two previous
 * @param limit_max maximum output saturation
 * @param limit_min minimum output saturation
 * @param k DC gain
 * @param ref_ptr pointer to reference voltage variable
 * @param fdbk_ptr pointer to feedback variable
 * @param coeff_fract_bits_b no of bits to be considered in coefficient b
 * @param xn_fract_bits no of bits to be considered in error input xn
 * @param coeff_fract_bits_a no of bits to be considered in coefficient a
 * @param yn_fract_bits no of bits to be considered in output yn
 * @param out_fract_bits no of bits to be considered in filter output
 *
 * \par<b>Description: </b><br>
 * The function an be used to initialize the data structure CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t used by CONTROL_LIB_2P2ZFixedPointInit() API.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   volatile int16_t ref  = 3247;       // reference voltage
 *   volatile int16_t vout = 2702;       // measured feedback voltage
 *   float b0          = 0.003333492f;   //coefficient filter for current input
 *   float b1          = 4.75873E-06f;   //coefficient filter for input one previous
 *   float b2          = -0.003328733f;  //coefficient filter for input two previous
 *   float a1          = 1.865423051f;   //coefficient filter for output one previous
 *   float a2          = -0.865423051f;  //coefficient filter for output two previous
 *   float k           = 1.0f;           // DC gain
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_b        1     0            19          19
 *   //     xn             1    12             0          12
 *   //     ---------------------------------------------------
 *   //     coeff_b*xn      1   12            19          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_a        1     1            14          15
 *   //     yn             1     8             8          16
 *   //     -------------------------------------------------------
 *   //     coeff_a*yn     1     9            22          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     out            1     8             8          17
 * 
 *   int16_t bits_b    = 19;             // no of bits to be considered in coefficient b
 *   int16_t bits_xn   = 0;              // no of bits to be considered in error input xn
 *   int16_t bits_a    = 14;             // no of bits to be considered in coefficient a
 *   int16_t bits_yn   = 8;              // no of bits to be considered in output yn
 *   int16_t bits_out  = 8;              // no of bits to be considered in filter output
 *   int32_t limit_max = 350;            // output saturation max for filter implementation
 *   int32_t limit_min = 0;              // output saturation min for filter implementation
 * 
 *   CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t data_p2z2;   // control data structure
 * 
 *   CONTROL_LIB_2P2ZFixedPointInit(&data_p2z2,
 *                                  &ref, &vout,
 *                                  b0, b1, b2,
 *                                  a1, a2,
 *                                  k,
 *                                  bits_b, bits_xn,
 *                                  bits_a, bits_yn,
 *                                  bits_out,
 *                                  limit_min, limit_max
 *                                  );
 * 
 *   CONTROL_LIB_2P2ZFixedPoint(&data_p2z2);
 * 
 *   compare_value = (uint16_t)data_p2z2.out;
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 */
void CONTROL_LIB_2P2ZFixedPointInit(CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t* handle_ptr,
                                      volatile int16_t* ref_ptr, volatile int16_t* fdbk_ptr,
                                      float b0, float b1, float b2,
                                      float a1, float a2, float k,
                                      int16_t coeff_fract_bits_b, int16_t xn_fract_bits,
                                      int16_t coeff_fract_bits_a, int16_t yn_fract_bits,
                                      int16_t out_fract_bits,
                                      int32_t limit_min, int32_t limit_max);

/*********************************************************************************************************************/
/**
 * @brief Calculates a second order control law with IIR filter with programmable output saturation.
 * @param handle_ptr CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t structure with proper coefficient values.
 *
 * \par<b>Description: </b><br>
 * The function can be used to implement control using 2 pole 2 zero filter. The computation is done in fixed point.
 *
 *  Y(z)   b0(z) + b1(z-1) + b2(z-2)  <br>
 *  --- = --------------------------  <br>
 *  X(z)     1   - a1(z-1) - a2(z-2)  <br>
 *
 *  y[n] - a1y[n-1] - a2y[n-2] = b0x[n] + b1x[n-1] + b2x[n-2] <br>
 *
 *  y[n] = b0x[n] + b1x[n-1] + b2x[n-2] + a1y[n-1] + a2y[n-2] <br>
 *
 *  where x[n] = ref - fdbk;
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   volatile int16_t ref  = 3247;       // reference voltage
 *   volatile int16_t vout = 2702;       // measured feedback voltage
 *   float b0          = 0.003333492f;   //coefficient filter for current input
 *   float b1          = 4.75873E-06f;   //coefficient filter for input one previous
 *   float b2          = -0.003328733f;  //coefficient filter for input two previous
 *   float a1          = 1.865423051f;   //coefficient filter for output one previous
 *   float a2          = -0.865423051f;  //coefficient filter for output two previous
 *   float k           = 1.0f;           // DC gain
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_b        1     0            19          19
 *   //     xn             1    12             0          12
 *   //     ---------------------------------------------------
 *   //     coeff_b*xn      1   12            19          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_a        1     1            14          15
 *   //     yn             1     8             8          16
 *   //     -------------------------------------------------------
 *   //     coeff_a*yn     1     9            22          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     out            1     8             8          17
 * 
 *   int16_t bits_b    = 19;             // no of bits to be considered in coefficient b
 *   int16_t bits_xn   = 0;              // no of bits to be considered in error input xn
 *   int16_t bits_a    = 14;             // no of bits to be considered in coefficient a
 *   int16_t bits_yn   = 8;              // no of bits to be considered in output yn
 *   int16_t bits_out  = 8;              // no of bits to be considered in filter output
 *   int32_t limit_max = 350;            // output saturation max for filter implementation
 *   int32_t limit_min = 0;              // output saturation min for filter implementation
 * 
 *   CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t data_p2z2;   // control data structure
 * 
 *   CONTROL_LIB_2P2ZFixedPointInit(&data_p2z2,
 *                                  &ref, &vout,
 *                                  b0, b1, b2,
 *                                  a1, a2,
 *                                  k,
 *                                  bits_b, bits_xn,
 *                                  bits_a, bits_yn,
 *                                  bits_out,
 *                                  limit_min, limit_max
 *                                  );
 * 
 *   CONTROL_LIB_2P2ZFixedPoint(&data_p2z2);
 * 
 *   compare_value = (uint16_t)data_p2z2.out;
 * 
 *   while(1)
 *   {
 * 
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_2P2ZFixedPoint(CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t* handle_ptr);

/*********************************************************************************************************************/

/**
 * @brief Initializes the data structure of CONTROL_LIB_3P3ZFloat() API.
 * @param handle_ptr   pointer to CONTROL_LIB_3P3Z_DATA_FLOAT_t structure
 * @param b0 coefficient filter for input current
 * @param b1 coefficient filter for input one previous
 * @param b2 coefficient filter for input two previous
 * @param b3 coefficient filter for input three previous
 * @param a1 coefficient filter for output one previous
 * @param a2 coefficient filter for output two previous
 * @param a3 coefficient filter for output three previous
 * @param limit_max maximum output saturation
 * @param limit_min minimum output saturation
 * @param k DC gain
 * @param ref_ptr Pointer to reference voltage variable
 * @param fdbk_ptr pointer to feedback variable
 *
 * \par<b>Description: </b><br>
 * The function can be used to initialize the data structure CONTROL_LIB_3P3Z_DATA_FLOAT_t used by CONTROL_LIB_3P3ZFloat() API.
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   float ref       = 3247.1304f;             //reference voltage 3.3 volts in steps of ADC
 *   float vout      = 2702.5139f;             //measured feedback voltage 3 volts in steps of ADC
 *   float b0        = 1.58457f;               //coefficient filter for current input
 *   float b1        = -1.47457f;              //coefficient filter for input one previous
 *   float b2        = -1.582984f;             //coefficient filter for input two previous
 *   float b3        = 1.476156f;              //coefficient filter for input three previous
 *   float a1        = 1.529213f;              //coefficient filter for output one previous
 *   float a2        = -0.362413f;             //coefficient filter for output two previous
 *   float a3        = -0.166799f;             //coefficient filter for output three previous
 *   float limit_max = 160.0f;                 //maximum output saturation
 *   float limit_min = 0.0f;                   //output saturation min for filter implementation
 *   float k         = 0.406513f;              //DC gain
 *   CONTROL_LIB_3P3Z_DATA_FLOAT_t data_p3z3;  // control data structure
 * 
 *   CONTROL_LIB_3P3ZFloatInit(&data_p3z3,
 *                             &ref, &vout,
 *                             b0, b1, b2, b3,
 *                             a1, a2, a3,
 *                             k,
 *                             limit_min, limit_max
 *                             );
 * 
 *   CONTROL_LIB_3P3ZFloat(&data_p3z3);
 *   compare_value = (uint16_t)data_p3z3.out;
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_3P3ZFloatInit(CONTROL_LIB_3P3Z_DATA_FLOAT_t* handle_ptr,
                                 volatile float* ref_ptr, volatile float* fdbk_ptr,
                                 float b0, float b1, float b2, float b3,
                                 float a1, float a2, float a3, float k,
                                 float limit_min, float limit_max);

/*********************************************************************************************************************/

/**
 * @brief Calculates a third order control law with IIR filter with programmable output saturation.
 * @param handle_ptr CONTROL_LIB_3P3Z_DATA_FLOAT_t structure with proper coefficient values.
 *
 * \par<b>Description: </b><br>
 * The function can be used to implement control using 2 pole 2 zero filter. The computation is done in float point.
 *
 *  Y(z)   b0(z) + b1(z-1) + b2(z-2) + b3(z-3)  <br>
 *  --- = ------------------------------------  <br>
 *  X(z)     1   - a1(z-1) - a2(z-2) - a3(z-3)  <br>
 *
 *  y[n] - a1y[n-1] - a2y[n-2] - a3y[n-3] = b0x[n] + b1x[n-1] + b2x[n-2] + b3x[n-3] <br>
 *
 *  y[n] = b0x[n] + b1x[n-1] + b2x[n-2] + b3x[n-3] + a1y[n-1] + a2y[n-2] + a3y[n-3] <br>
 *
 *  where x[n] = ref - fdbk;
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   float ref       = 3247.1304f;             //reference voltage 3.3 volts in steps of ADC
 *   float vout      = 2702.5139f;             //measured feedback voltage 3 volts in steps of ADC
 *   float b0        = 1.58457f;               //coefficient filter for current input
 *   float b1        = -1.47457f;              //coefficient filter for input one previous
 *   float b2        = -1.582984f;             //coefficient filter for input two previous
 *   float b3        = 1.476156f;              //coefficient filter for input three previous
 *   float a1        = 1.529213f;              //coefficient filter for output one previous
 *   float a2        = -0.362413f;             //coefficient filter for output two previous
 *   float a3        = -0.166799f;             //coefficient filter for output three previous
 *   float limit_max = 160.0f;                 //maximum output saturation
 *   float limit_min = 0.0f;                   //output saturation min for filter implementation
 *   float k         = 0.406513f;              //DC gain
 *   CONTROL_LIB_3P3Z_DATA_FLOAT_t data_p3z3;  // control data structure
 * 
 *   CONTROL_LIB_3P3ZFloatInit(&data_p3z3,
 *                             &ref, &vout,
 *                             b0, b1, b2, b3,
 *                             a1, a2, a3,
 *                             k,
 *                             limit_min, limit_max
 *                             );
 * 
 *   CONTROL_LIB_3P3ZFloat(&data_p3z3);
 *   compare_value = (uint16_t)data_p3z3.out;
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */

void CONTROL_LIB_3P3ZFloat(CONTROL_LIB_3P3Z_DATA_FLOAT_t* handle_ptr);

/*********************************************************************************************************************/
/**
 * @brief Initializes the data structure of CONTROL_LIB_3P3ZFixedPoint() API.
 * @param handle_ptr   pointer to CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t structure
 * @param b0 coefficient filter for current input
 * @param b1 coefficient filter for input one previous
 * @param b2 coefficient filter for input two previous
 * @param b3 coefficient filter for input three previous
 * @param a1 coefficient filter for output one previous
 * @param a2 coefficient filter for output two previous
 * @param a3 coefficient filter for output three previous
 * @param limit_max maximum output saturation
 * @param limit_min minimum output saturation
 * @param k DC gain
 * @param ref_ptr pointer to reference voltage variable
 * @param fdbk_ptr pointer to feedback variable
 * @param coeff_fract_bits_b no of bits to be considered in coefficient b
 * @param xn_fract_bits no of bits to be considered in error input xn
 * @param coeff_fract_bits_a no of bits to be considered in coefficient a
 * @param yn_fract_bits no of bits to be considered in output yn
 * @param out_fract_bits no of bits to be considered in filter output
 *
 * \par<b>Description: </b><br>
 * The function an be used to initialize the data structure CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t used by CONTROL_LIB_3P3ZFixedPointInit() API.
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   volatile int16_t ref  = 3214;       //reference voltage
 *   volatile int16_t vout = 3014;       //measured feedback voltage
 *   float b0          = 0.003333492f;   //coefficient filter for current input
 *   float b1          = 4.75873E-06f;   //coefficient filter for input one previous
 *   float b2          = -0.003328733f;  //coefficient filter for input two previous
 *   float b3          = 0.0f;           //coefficient filter for input three previous
 *   float a1          = 1.865423051f;   //coefficient filter for output one previous
 *   float a2          = -0.865423051f;  //coefficient filter for output two previous
 *   float a3          = 0.0f;           //coefficient filter for output three previous
 *   float k           = 1.0f;           //DC gain
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_b        1     0            19          19
 *   //     xn             1    12             0          12
 *   //     ---------------------------------------------------
 *   //     coeff_b*xn      1   12            19          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_a        1     1            14          15
 *   //     yn             1     8             8          16
 *   //     -------------------------------------------------------
 *   //     coeff_a*yn     1     9            22          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     out            1     8             8          17
 * 
 *   int16_t bits_b    = 19;             // no of bits to be considered in coefficient b
 *   int16_t bits_xn   = 0;              // no of bits to be considered in error input xn
 *   int16_t bits_a    = 14;             // no of bits to be considered in coefficient a
 *   int16_t bits_yn   = 8;              // no of bits to be considered in output yn
 *   int16_t bits_out  = 8;              // no of bits to be considered in filter output
 *   int32_t limit_max = 350;            // output saturation max for filter implementation
 *   int32_t limit_min = 0;              // output saturation min for filter implementation
 * 
 *   CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t data_p2z2;   // control data structure
 * 
 *   CONTROL_LIB_3P3ZFixedPointInit(&data_p2z2,
 *                                  &ref, &vout,
 *                                  b0, b1, b2, b3,
 *                                  a1, a2, a3,
 *                                  k,
 *                                  bits_b, bits_xn,
 *                                  bits_a, bits_yn,
 *                                  bits_out,
 *                                  limit_min, limit_max
 *                                  );
 * 
 *   CONTROL_LIB_3P3ZFixedPoint(&data_p2z2);
 * 
 *   compare_value = (uint16_t)data_p2z2.out;
 * 
 *   while(1)
 *   {
 * 
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_3P3ZFixedPointInit(CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t* handle_ptr,
                                      volatile int16_t* ref_ptr, volatile int16_t* fdbk_ptr,
                                      float b0, float b1, float b2, float b3,
                                      float a1, float a2, float a3, float k,
                                      int16_t coeff_fract_bits_b, int16_t xn_fract_bits,
                                      int16_t coeff_fract_bits_a, int16_t yn_fract_bits,
                                      int16_t out_fract_bits,
                                      int32_t limit_min, int32_t limit_max);

/*********************************************************************************************************************/
/**
 * @brief Calculates a third order control law with IIR filter with programmable output saturation.
 * @param handle_ptr CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t structure with proper coefficient values.
 *
 * \par<b>Description: </b><br>
 * The function can be used to implement control using 3 pole 3 zero filter. The computation is done in fixed point.
 *
 *  Y(z)   b0(z) + b1(z-1) + b2(z-2) + b3(z-3)  <br>
 *  --- = ------------------------------------  <br>
 *  X(z)     1   - a1(z-1) - a2(z-2) - a3(z-3)  <br>
 *
 *  y[n] - a1y[n-1] - a2y[n-2] - a3y[n-3] = b0x[n] + b1x[n-1] + b2x[n-2] + b3x[n-3] <br>
 *
 *  y[n] = b0x[n] + b1x[n-1] + b2x[n-2] + b3x[n-3] + a1y[n-1] + a2y[n-2] + a3y[n-3]<br>
 *
 *  where x[n] = ref - fdbk;
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint16_t compare_value;
 *   volatile int16_t ref  = 3214;       //reference voltage
 *   volatile int16_t vout = 3014;       //measured feedback voltage
 *   float b0          = 0.003333492f;   //coefficient filter for current input
 *   float b1          = 4.75873E-06f;   //coefficient filter for input one previous
 *   float b2          = -0.003328733f;  //coefficient filter for input two previous
 *   float b3          = 0.0f;           //coefficient filter for input three previous
 *   float a1          = 1.865423051f;   //coefficient filter for output one previous
 *   float a2          = -0.865423051f;  //coefficient filter for output two previous
 *   float a3          = 0.0f;           //coefficient filter for output three previous
 *   float k           = 1.0f;           //DC gain
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_b        1     0            19          19
 *   //     xn             1    12             0          12
 *   //     ---------------------------------------------------
 *   //     coeff_b*xn      1   12            19          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     coeff_a        1     1            14          15
 *   //     yn             1     8             8          16
 *   //     -------------------------------------------------------
 *   //     coeff_a*yn     1     9            22          32
 * 
 *   //                  Sign   IQ int      IQ fract    Bit size
 *   //     out            1     8             8          17
 * 
 *   int16_t bits_b    = 19;             // no of bits to be considered in coefficient b
 *   int16_t bits_xn   = 0;              // no of bits to be considered in error input xn
 *   int16_t bits_a    = 14;             // no of bits to be considered in coefficient a
 *   int16_t bits_yn   = 8;              // no of bits to be considered in output yn
 *   int16_t bits_out  = 8;              // no of bits to be considered in filter output
 *   int32_t limit_max = 350;            // output saturation max for filter implementation
 *   int32_t limit_min = 0;              // output saturation min for filter implementation
 * 
 *   CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t data_p2z2;   // control data structure
 * 
 *   CONTROL_LIB_3P3ZFixedPointInit(&data_p2z2,
 *                                  &ref, &vout,
 *                                  b0, b1, b2, b3,
 *                                  a1, a2, a3,
 *                                  k,
 *                                  bits_b, bits_xn,
 *                                  bits_a, bits_yn,
 *                                  bits_out,
 *                                  limit_min, limit_max
 *                                  );
 * 
 *   CONTROL_LIB_3P3ZFixedPoint(&data_p2z2);
 * 
 *   compare_value = (uint16_t)data_p2z2.out;
 * 
 *   while(1)
 *   {
 * 
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_3P3ZFixedPoint(CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t* handle_ptr);

/**
 * @brief Calculates a square root of given input.
 * @param radicand uint32_t Input variable. Range: 0 to 0xFFFFFFFF
 *
 * \par<b>Description: </b><br>
 * The function can be used to get the square root value for a given input in unsigned integer format.
 * The computation is done in fixed point.
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t input = 4;
 *   uint32_t output;
 * 
 *   output = CONTROL_LIB_SquareRootInteger(input);
 * 
 *   while(1)
 *   {
 * 
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
__STATIC_INLINE uint32_t CONTROL_LIB_SquareRootInteger(uint32_t radicand)
{
  uint32_t result = 0;
  uint32_t auxiliar = radicand;
  uint32_t walking_one = 1uL << 30;  	 // The second MSBit is set to 1
  // "walking_one" starts at the highest power of 4 <= than the argument.
  while (walking_one > auxiliar)
  {
    walking_one >>= 2;
  }
  while (walking_one != 0)
  {
    if (auxiliar >= (result + walking_one))
    {
      auxiliar = auxiliar - (result + walking_one);
      result = result + (2 * walking_one);
    }
    result >>= 1;
    walking_one >>= 2;
  }
  return result;
}

/**
 * @brief Calculates a moving average cumulative filter output.
 * @param handle_ptr CONTROL_LIB_MOVING_AVERAGE_FIXED_POINT_t structure with proper input values.
 *
 * \par<b>Description: </b><br>
 * The function can be used to implement moving average cumulative filter. And it is  a type of finite impulse response
 * (FIR) filter. The computation is done in fixed point implementation.
 *
 *  y[n] = y[n-1] + (x[n] - y[n-1])/n <br>
 *
 *  where x[n] is input, y[n] is output and n is 2 ^ num_samples;
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   CONTROL_LIB_MOVING_AVERAGE_FIXED_POINT_t handle;
 *   uint32_t input, output;
 * 
 *   //fill the input value
 *   input = 50;
 * 
 *   handle.input_avg = input;
 *   handle.num_samples = 1; //n = 2^1
 * 
 *   CONTROL_LIB_MovingAverageCumulativeFixedPoint(&handle);
 * 
 *   //returns the filtered output
 *   output = handle.out_avg;
 * 
 *   //repeat the above steps to accumulate multiple samples and get filtered output
 * 
 *   while(1)
 *   {
 * 
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
__STATIC_INLINE void CONTROL_LIB_MovingAverageCumulativeFixedPoint(CONTROL_LIB_MOVING_AVERAGE_FIXED_POINT_t *const  handle_ptr)
{
  handle_ptr->out_avg  = handle_ptr->out_avg + ((handle_ptr->input_avg  >> handle_ptr->num_samples) - (handle_ptr->out_avg  >> handle_ptr->num_samples));
}

/*******************************************************************************************************************/
/**
 * @brief Initializes the data structure of CONTROL_LIB_PIFloat() API.
 * @param handle_ptr pointer to CONTROL_LIB_PI_DATA_FLOAT_t structure
 * @param ref_ptr Pointer to reference voltage variable
 * @param fdbk_ptr pointer to feedback variable
 * @param kp Proportional gain constant
 * @param ki Integral gain constant
 * @param limit_max maximum output limit for anti-windup scheme
 * @param limit_min minimum output limit for anti-windup scheme
 * @param out Pointer to PI output variable
 *
 * \par<b>Description: </b><br>
 * The function can be used to initialize the data structure CONTROL_LIB_PI_DATA_FLOAT_t used by
 * CONTROL_LIB_PIFloat() API.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ref       = 3247.1304f;             //reference voltage 3.3 volts in steps of ADC
 *   uint32_t vout      = 2702.5139f;             //measured feedback voltage 3 volts in steps of ADC
 *   uint32_t compare_value;                      //CCU4/8 compare value for PWM generation
 *   float kp        = 0.001f;              //Proportional gain constant
 *   float ki        = 0.01f;              //Integral gain constant
 *   float limit_max = 1023.0f;                //maximum output for anti-windup scheme
 *   float limit_min = 155.0f;                 //minimum output for anti-windup scheme
 *   CONTROL_LIB_PI_DATA_FLOAT_t handle;  //control data structure
 * 
 *   CONTROL_LIB_PIFloatInit(&handle,
 *                             &ref, &vout,
 *                             kp, ki,
 *                             limit_min, limit_max,
 *                             &compare_value
 *                             );
 * 
 *   CONTROL_LIB_PIFloat(&handle);
 * 
 *   //compare_value which holds the output
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_PIFloatInit(CONTROL_LIB_PI_DATA_FLOAT_t* handle_ptr,
                                   volatile uint32_t* ref_ptr, volatile uint32_t* fdbk_ptr,
                                   float kp, float ki,
                                   float limit_min, float limit_max,
								   volatile uint32_t* out);

/**
 * @brief Calculates a proportional integral controller output with programmable output limits for anti-windup scheme.
 * @param handle_ptr CONTROL_LIB_PI_DATA_FLOAT_t structure with proper input values.
 *
 * \par<b>Description: </b><br>
 * The function can be used to implement control loop feedback mechanism which commonly used in industrial applications.
 * A PI controller continuously calculates an error value as the difference between a reference and a feedback.
 *
 * I[k] = Ki * error + I[k-1]
 * U[k] = Kp * error + I[k]
 * if(min < U[k] < max){I[k-1] = I[k];}//Anti wind-up <br>
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ref       = 3247.1304f;             //reference voltage 3.3 volts in steps of ADC
 *   uint32_t vout      = 2702.5139f;             //measured feedback voltage 3 volts in steps of ADC
 *   uint32_t compare_value;                      //CCU4/8 compare value for PWM generation
 *   float kp        = 0.001f;              //Proportional gain constant
 *   float ki        = 0.01f;              //Integral gain constant
 *   float limit_max = 1023.0f;                //maximum output for anti-windup scheme
 *   float limit_min = 155.0f;                 //minimum output for anti-windup scheme
 *   CONTROL_LIB_PI_DATA_FLOAT_t handle;  //control data structure
 * 
 *   CONTROL_LIB_PIFloatInit(&handle,
 *                             &ref, &vout,
 *                             kp, ki,
 *                             limit_min, limit_max,
 *                             &compare_value
 *                             );
 * 
 *   CONTROL_LIB_PIFloat(&handle);
 * 
 *   //compare_value which holds the output
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
__STATIC_INLINE void CONTROL_LIB_PIFloat(CONTROL_LIB_PI_DATA_FLOAT_t* handle_ptr)
{
  /*
   * I(k) = Ki * error + I(k-1)
   * U(k) = Kp * error + I(k)
   * if(min < U(k) < max){I(k-1) = I(k);}//Anti wind-up
   */

  handle_ptr->error = (float)((int16_t)*(handle_ptr->ref_ptr) - (int16_t)*(handle_ptr->fdbk_ptr));

  handle_ptr->ik = (handle_ptr->error * handle_ptr->ki) + handle_ptr->ik_1;
  handle_ptr->uk = (handle_ptr->error * handle_ptr->kp) + handle_ptr->ik;

  if (handle_ptr->uk > handle_ptr->out_limit_max)
  {
    handle_ptr->uk = handle_ptr->out_limit_max; /*Disable anti wind up filter*/
  }
  else if (handle_ptr->uk < handle_ptr->out_limit_min)
  {
    handle_ptr->uk = handle_ptr->out_limit_min; /*Disable anti wind up filter*/
  }
  else
  {
    handle_ptr->ik_1 = handle_ptr->ik; /*Enable anti wind up filter*/
  }

  *(handle_ptr->out) = (uint32_t)handle_ptr->uk;
}

/*********************************************************************************************************************/
/**
 * @brief Initializes the data structure of CONTROL_LIB_PIFixedPoint() API.
 * @param handle_ptr pointer to CONTROL_LIB_PI_DATA_FIXED_POINT_t structure
 * @param ref_ptr Pointer to reference voltage variable
 * @param fdbk_ptr pointer to feedback variable
 * @param kp Proportional gain constant
 * @param ki Integral gain constant
 * @param fract_bits_kp no of bits to be considered in constant kp
 * @param fract_bits_ki no of bits to be considered in constant ki
 * @param fract_bits_error no of bits to be considered in error input
 * @param fract_bits_uk no of bits to be considered in transfer function output
 * @param fract_bits_out no of bits to be considered in controller final output
 * @param limit_max maximum output limit for anti-windup scheme
 * @param limit_min minimum output limit for anti-windup scheme
 * @param out Pointer to PI output variable
 *
 * \par<b>Description: </b><br>
 * The function can be used to initialize the data structure CONTROL_LIB_PI_DATA_FIXED_POINT_t used by
 * CONTROL_LIB_PIFixedPoint() API.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ref       = 3247;             //reference voltage 3.3 volts in steps of ADC
 *   uint32_t vout      = 2702;             //measured feedback voltage 3 volts in steps of ADC
 *   uint32_t compare_value;                      //CCU4/8 compare value for PWM generation
 *   float kp        = 0.931630577573f;              //Proportional gain constant
 *   float ki        = 0.850618528727f;              //Integral gain constant
 *   uint32_t kp_fract_bits = 17U;          //no of bits to be considered in kp constant
 *   uint32_t ki_fract_bits = 17U;          //no of bits to be considered in ki constant
 *   uint32_t err_fract_bits = 17U;          //no of bits to be considered in error input
 *   uint32_t uk_fract_bits = 17U;          //no of bits to be considered in transfer function output
 *   uint32_t out_fract_bits = 17U;          //no of bits to be considered in controller final output
 *   uint32_t limit_max = 500;                //maximum output for anti-windup scheme
 *   uint32_t limit_min = 0;                 //minimum output for anti-windup scheme
 *   CONTROL_LIB_PI_DATA_FIXED_POINT_t handle;  //control data structure
 * 
 *   CONTROL_LIB_PIFixedPointInit(&handle,
 *                             &ref, &vout,
 *                             kp, ki,
 *                             kp_fract_bits, ki_fract_bits, err_fract_bits,
 *                             uk_fract_bits, out_fract_bits,
 *                             limit_min, limit_max,
 *                             &compare_value
 *                             );
 * 
 *   CONTROL_LIB_PIFixedPoint(&handle);
 * 
 *   //compare_value which holds the output
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */
void CONTROL_LIB_PIFixedPointInit(CONTROL_LIB_PI_DATA_FIXED_POINT_t* handle_ptr,
                                   volatile uint32_t* ref_ptr, volatile uint32_t* fdbk_ptr,
                                   float kp, float ki,
                                   int16_t fract_bits_kp, int16_t fract_bits_ki,
                                   int16_t fract_bits_error, int16_t fract_bits_uk,
								   int16_t fract_bits_out,
                                   int32_t limit_min, int32_t limit_max,
								    volatile uint32_t* out);

/**
 * @brief Calculates a proportional integral controller output with programmable output limits for anti-windup scheme.
 * @param handle_ptr CONTROL_LIB_PI_DATA_FLOAT_t structure with proper input values.
 *
 * \par<b>Description: </b><br>
 * The function can be used to implement control loop feedback mechanism which commonly used in industrial applications.
 * A PI controller continuously calculates an error value as the difference between a reference and a feedback.
 * The computation is done in fixed point implementation.
 *
 * I[k] = Ki * error + I[k-1]
 * U[k] = Kp * error + I[k]
 * if(min < U[k] < max){I[k-1] = I[k];}//Anti wind-up <br>
 *
 * Example Usage:
 * @code
 *  #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ref       = 3247;             //reference voltage 3.3 volts in steps of ADC
 *   uint32_t vout      = 2702;             //measured feedback voltage 3 volts in steps of ADC
 *   uint32_t compare_value;                      //CCU4/8 compare value for PWM generation
 *   float kp        = 0.931630577573f;              //Proportional gain constant
 *   float ki        = 0.850618528727f;              //Integral gain constant
 *   uint32_t kp_fract_bits = 17U;          //no of bits to be considered in kp constant
 *   uint32_t ki_fract_bits = 17U;          //no of bits to be considered in ki constant
 *   uint32_t err_fract_bits = 17U;          //no of bits to be considered in error input
 *   uint32_t uk_fract_bits = 17U;          //no of bits to be considered in transfer function output
 *   uint32_t out_fract_bits = 17U;          //no of bits to be considered in controller final output
 *   uint32_t limit_max = 500;                //maximum output for anti-windup scheme
 *   uint32_t limit_min = 0;                 //minimum output for anti-windup scheme
 *   CONTROL_LIB_PI_DATA_FIXED_POINT_t handle;  //control data structure
 * 
 *   CONTROL_LIB_PIFixedPointInit(&handle,
 *                             &ref, &vout,
 *                             kp, ki,
 *                             kp_fract_bits, ki_fract_bits, err_fract_bits,
 *                             uk_fract_bits, out_fract_bits,
 *                             limit_min, limit_max,
 *                             &compare_value
 *                             );
 * 
 *   CONTROL_LIB_PIFixedPoint(&handle);
 * 
 *   //compare_value which holds the output
 * 
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 * @endcode
 *
 */__STATIC_INLINE void CONTROL_LIB_PIFixedPoint(CONTROL_LIB_PI_DATA_FIXED_POINT_t* handle_ptr)
{
  /*
   * I(k) = Ki * error + I(k-1)
   * U(k) = Kp * error + I(k)
   * if(min < U(k) < max){I(k-1) = I(k);}//Anti wind-up
   */

  int32_t ik_shifted;

  handle_ptr->error = (int16_t)*handle_ptr->ref_ptr - (int16_t)*handle_ptr->fdbk_ptr;

  handle_ptr->ik = (((int32_t) handle_ptr->error * (int32_t) handle_ptr->ki) + handle_ptr->ik_1);

  ik_shifted = handle_ptr->ik >> (uint16_t) handle_ptr->scale_i;;

  handle_ptr->uk = (((int32_t) handle_ptr->error * (int32_t) handle_ptr->kp) + ik_shifted);

  if (handle_ptr->uk > handle_ptr->out_limit_max)
  {
    handle_ptr->uk = handle_ptr->out_limit_max; /*Disable anti wind up filter*/
  }
  else if (handle_ptr->uk < handle_ptr->out_limit_min)
  {
    handle_ptr->uk = handle_ptr->out_limit_min; /*Disable anti wind up filter*/
  }
  else
  {
    handle_ptr->ik_1 = handle_ptr->ik; /*Enable anti wind up filter*/
  }

  *(handle_ptr->out) = (uint32_t)(handle_ptr->uk >> (uint16_t) handle_ptr->scale_out);
}

/**
 * @}
 */

#ifdef __cplusplus
}
#endif

#endif /* CONTROL_LIB_H_ */

/*CODE_BLOCK_END*/
