/**
 * @file buck_pcc_fix_fq.h
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * BUCK_PCC_FIX_FQ v4.1.4 - APP can be used to control different configurations of buck in peak current control mode.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-10-08:
 *     - Initial version for DAVEv4
 *
 * 2016-01-18:
 *     - APP handle structure is modified
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */

#ifndef BUCK_PCC_FIX_FQ_H_
#define BUCK_PCC_FIX_FQ_H_

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "buck_pcc_fix_fq_conf.h"
#include "CONTROL_LIB/control_lib.h"

#ifdef  BUCK_PCC_FIX_FQ_PWM_CCU8_USED
#include "PWM_CCU8/pwm_ccu8.h"
#include "COMP_REF/comp_ref.h"
#ifdef  BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED
#include "PWM_CCU4/pwm_ccu4.h"
#endif
#ifdef  BUCK_PCC_FIX_FQ_BLANKING_AND_SLOPE_USED
#include "DIGITAL_IO/digital_io.h"
#endif
#endif

#ifdef  BUCK_PCC_FIX_FQ_HRPWM_USED
#include "HRPWM/hrpwm.h"
#include "COMP_SLOPE_GEN/comp_slope_gen.h"
#endif

#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
#include "ADC_SCAN/adc_scan.h"
#endif

#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
#include "ADC_QUEUE/adc_queue.h"
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
#include "SYSTIMER/systimer.h"
#endif

/**********************************************************************************************************************
* MACROS
**********************************************************************************************************************/
#define BUCK_PCC_FIX_FQ_XMC_LIB_MAJOR_VERSION 2
#define BUCK_PCC_FIX_FQ_XMC_LIB_MINOR_VERSION 0
#define BUCK_PCC_FIX_FQ_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > BUCK_PCC_FIX_FQ_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == BUCK_PCC_FIX_FQ_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > BUCK_PCC_FIX_FQ_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == BUCK_PCC_FIX_FQ_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == BUCK_PCC_FIX_FQ_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= BUCK_PCC_FIX_FQ_XMC_LIB_PATCH_VERSION)))
#error "BUCK_PCC_FIX_FQ requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**********************************************************************************************************************
* ENUMS
**********************************************************************************************************************/
/**
 * @ingroup BUCK_PCC_FIX_FQ_enumerations
 * @{
 */

/**
 * @brief API return status
 */
typedef enum BUCK_PCC_FIX_FQ_STATUS
{
  BUCK_PCC_FIX_FQ_STATUS_SUCCESS = 0U,              /**< API is successfully executed */
  BUCK_PCC_FIX_FQ_STATUS_FAILURE = 1U,              /**< Failure in API execution */
  BUCK_PCC_FIX_FQ_STATUS_ALREADY_INITIALIZED = 2U   /**< Already Initialized */
} BUCK_PCC_FIX_FQ_STATUS_t;

/**
 * @brief The type identifies APP state
 */
typedef enum BUCK_PCC_FIX_FQ_STATE
{
  BUCK_PCC_FIX_FQ_STATE_UNINITIALIZED = 0U,         /**< Default state after power on reset. APP is in uninitialized mode. */
  BUCK_PCC_FIX_FQ_STATE_INITIALIZED,                /**< APP is in initialized mode. */
  BUCK_PCC_FIX_FQ_STATE_RUNNING,                    /**< APP is in running mode. */
  BUCK_PCC_FIX_FQ_STATE_STOPPED                     /**< APP is in stopped mode. */
} BUCK_PCC_FIX_FQ_STATE_t;

/**
 * @brief Number of phases for Interleaved BUCK
 */
typedef enum BUCK_PCC_FIX_FQ_NUM_OF_PHASES
{
  BUCK_PCC_FIX_FQ_NUM_OF_PHASES_1 = 1U, /**< One PWM is generated */
  BUCK_PCC_FIX_FQ_NUM_OF_PHASES_2,      /**< Two PWM's are generated for interleaved Buck */
  BUCK_PCC_FIX_FQ_NUM_OF_PHASES_3,      /**< Three PWM's are generated for interleaved Buck */
  BUCK_PCC_FIX_FQ_NUM_OF_PHASES_4       /**< Four PWM's are generated for interleaved Buck */
} BUCK_PCC_FIX_FQ_NUM_OF_PHASES_t;

/**
 * @brief ADC request source
 */
typedef enum BUCK_PCC_FIX_FQ_ADC_MODE
{
  BUCK_PCC_FIX_FQ_ADC_MODE_SCAN = 0U, /**< Scan request source is selected */
  BUCK_PCC_FIX_FQ_ADC_MODE_QUEUE      /**< Queue request source is selected */
} BUCK_PCC_FIX_FQ_ADC_MODE_t;

/**
 * @brief Type of filter
 */
typedef enum BUCK_PCC_FIX_FQ_FILTER
{
  BUCK_PCC_FIX_FQ_FILTER_TYPE_II  = 0U, /**< Type II filter is selected */
  BUCK_PCC_FIX_FQ_FILTER_TYPE_III /**< Type III filter is selected */
} BUCK_PCC_FIX_FQ_FILTER_t;

/**
 * @brief Control loop trigger source
 */
typedef enum BUCK_PCC_FIX_FQ_INTERRUPT
{
  BUCK_PCC_FIX_FQ_INTERRUPT_VOUT_RESULT_EVENT = 0U, /**< Completion of Vout Result Event triggers control loop */
  BUCK_PCC_FIX_FQ_INTERRUPT_REQ_SRC_EVENT           /**< End Of Request Source Event triggers control loop */
} BUCK_PCC_FIX_FQ_INTERRUPT_t;

/**
 * @brief Software timer status for SYSTIMER start and stop APIs.
 */
typedef enum BUCK_PCC_FIX_FQ_SW_TIMER_STATUS
{
  BUCK_PCC_FIX_FQ_SW_TIMER_START_SUCCESS = 0,       /**< Software timer is stopped successfully */
  BUCK_PCC_FIX_FQ_SW_TIMER_START_FAILED,            /**< Failed to stop software timer */
  BUCK_PCC_FIX_FQ_SW_TIMER_STOP_SUCCESS,            /**< Software timer is stopped successfully */
  BUCK_PCC_FIX_FQ_SW_TIMER_STOP_FAILED              /**< Failed to stop software timer */
} BUCK_PCC_FIX_FQ_SW_TIMER_STATUS_t;

/**
 * @}
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
  * @ingroup BUCK_PCC_FIX_FQ_datastructures
  * @{
  */

/**
 * ADC configurations
 */
typedef struct BUCK_PCC_FIX_FQ_ADCConfig
{
  const BUCK_PCC_FIX_FQ_ADC_MODE_t                     adc_mode;                                                /**< ADC request source */
  const XMC_VADC_RESULT_CONFIG_t                *const result_reg_handle;                                       /**< Pointer to VOUT result configuration structure*/

  const XMC_VADC_CHANNEL_CONFIG_t               *const channel_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH];     /**< Pointer to channel configuration structure*/
#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
  const ADC_SCAN_ENTRY_t                        *const scan_entry_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH];  /**< Pointer to ADC_SCAN entry handler */
#endif
#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
  const ADC_QUEUE_ENTRY_t                       *const q_entry_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH];     /**< Pointer to ADC_QUEUE entry handler */
#endif
  const uint8_t                                        result_register_num_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH];/**< Result register number configuration*/
  const uint8_t                                        channel_num_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH];        /**< Channel number configuration*/
} BUCK_PCC_FIX_FQ_ADCConfig_t;

/**
 * PWM configurations
 */
typedef struct BUCK_PCC_FIX_FQ_PWMConfig
{
  const BUCK_PCC_FIX_FQ_NUM_OF_PHASES_t                no_of_phases;         /**< No of PWM generators for interleaved operation */
  const uint16_t                                       phase_timer_val[BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES];   /**< Phase shift between interleaved phases */

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU4_USED
  const XMC_GPIO_OUTPUT_LEVEL_t                        ccu4_output_passive_level; /**< CCU4 output passive level */
#endif

#if (defined BUCK_PCC_FIX_FQ_PWM_CCU8_USED)  || (defined BUCK_PCC_FIX_FQ_HRPWM_USED)
  const XMC_GPIO_OUTPUT_LEVEL_t                        ccu8_output_passive_level; /**< CCU8 output passive level */
#endif
  const bool                                           synch_converter;      /**< Synchronous conversion selection */
} BUCK_PCC_FIX_FQ_PWMConfig_t;

/**
 * Interrupt configurations
 */
typedef struct BUCK_PCC_FIX_FQ_IntConfig
{
  const IRQn_Type                                      node;                 /**< Mapped NVIC Node */
  const uint8_t                                        priority;             /**< Node Interrupt Priority */
#if(UC_FAMILY == XMC4)
  const uint8_t                                        subpriority;          /**< Node Interrupt SubPriority */
#endif
  const XMC_VADC_SR_t                                  vout_result_ev_srline;/**< Vout Result Event's service request line */
#if(UC_SERIES == XMC14)
  const XMC_SCU_IRQCTRL_t                              irqctrl;              /**< Selects the interrupt source for a NVIC interrupt node */
#endif
} BUCK_PCC_FIX_FQ_IntConfig_t;

/**
 * Constant parameters of APP
 */
typedef struct BUCK_PCC_FIX_FQ_CONFIG
{
  const bool                                           adc_vout_enable;      /**< Selection of Vout (output voltage) measurement */
  const bool                                           adc_vin_enable;       /**< Selection of Vin (input voltage) measurement */
  const bool                                           adc_iout1_enable;     /**< Selection of Iout1 (inductor current - phase 1) measurement */
  const bool                                           adc_iout2_enable;     /**< Selection of Iout2 (inductor current - phase 2) measurement */
  const bool                                           adc_iout3_enable;     /**< Selection of Iout3 (inductor current - phase 3) measurement */
  const bool                                           adc_udef_enable;      /**< Selection of user_defined1 measurement */

  const bool                                           vout_sw_protection;   /**< Selection of software overload protection for Vout */
  const bool                                           vin_sw_protection;    /**< Selection of software overload protection for Vin */
  const bool                                           iout1_sw_protection;  /**< Selection of software overload protection for Iout1 */
  const bool                                           iout2_sw_protection;  /**< Selection of software overload protection for Iout2 */
  const bool                                           iout3_sw_protection;  /**< Selection of software overload protection for Iout3 */

#if (BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES == 4U)
  const bool                                           adc_iout4_enable;     /**< Selection of Iout4 (inductor current - phase 4) measurement */
  const bool                                           iout4_sw_protection;  /**< Selection of software overload protection for Iout4 */
#endif

  const uint8_t                                        volt_control_rate;    /**< Control ISR is executed every nth trigger */
  const BUCK_PCC_FIX_FQ_FILTER_t                       filter;               /**< Selects the type of control */
  const BUCK_PCC_FIX_FQ_INTERRUPT_t                    interrupt_event;

#if(UC_FAMILY == XMC4) /* XMC44, XMC42, XMC41 */
  const float                                          vout;                /**< Buck output reference voltage in 12 bit format */
  const float                                          vin;                 /**< Buck input voltage in 12 bit format */
  const float                                          gain_vout;           /**< Output voltage gain */
  const float                                          gain_vin;            /**< Input voltage gain */
  const float                                          gain_iout1;          /**< Iout1 current gain */
  const float                                          gain_iout2;          /**< Iout2 current gain */
  const float                                          gain_iout3;          /**< Iout3 current gain */

  const float                                          vout_high_limit;      /**< Over voltage limit for Vout */
  const float                                          vout_low_limit;       /**< Under voltage limit for Vout */
  const float                                          vin_high_limit;       /**< Over voltage limit for Vin */
  const float                                          vin_low_limit;        /**< Under voltage limit for Vin */
  const float                                          iout1_high_limit;     /**< Over current limit for Iout1 */
  const float                                          iout1_low_limit;      /**< Under current limit for Iout1 */
  const float                                          iout2_high_limit;     /**< Over current limit for Iout2 */
  const float                                          iout2_low_limit;      /**< Under current limit for Iout2 */
  const float                                          iout3_high_limit;     /**< Over current limit for Iout3 */
  const float                                          iout3_low_limit;      /**< Under current limit for Iout3 */

#if (BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES == 4U)
  const float                                          gain_iout4;           /**< Iout4 current gain */
  const float                                          iout4_high_limit;     /**< Over current limit for Iout4 */
  const float                                          iout4_low_limit;      /**< Under current limit for Iout4 */
#endif

  const uint16_t                                       dac_start_value;      /**< CSG's DAC start value */

#else /* XMC1x family */
  const uint16_t                                       vout;                 /**< Buck output reference voltage in 12 bit format */
  const uint16_t                                       vin;                  /**< Buck input voltage in 12 bit format */
  const uint32_t                                       gain_vout;            /**< Output voltage gain */
  const uint32_t                                       gain_vin;             /**< Input voltage gain */
  const uint32_t                                       gain_iout1;           /**< Iout1 current gain */
  const uint32_t                                       gain_iout2;           /**< Iout2 current gain */
  const uint32_t                                       gain_iout3;           /**< Iout3 current gain */
#if (BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES == 4U)
  const uint32_t                                       gain_iout4;           /**< Iout4 current gain */
#endif

  const uint32_t                                       vout_high_limit;      /**< Over voltage limit for Vout */
  const uint32_t                                       vout_low_limit;       /**< Under voltage limit for Vout */
  const uint32_t                                       vin_high_limit;       /**< Over voltage limit for Vin */
  const uint32_t                                       vin_low_limit;        /**< Under voltage limit for Vin */
  const uint32_t                                       iout1_high_limit;     /**< Over current limit for Iout1 */
  const uint32_t                                       iout1_low_limit;      /**< Under current limit for Iout1 */
  const uint32_t                                       iout2_high_limit;     /**< Over current limit for Iout2 */
  const uint32_t                                       iout2_low_limit;      /**< Under current limit for Iout2 */
  const uint32_t                                       iout3_high_limit;     /**< Over current limit for Iout3 */
  const uint32_t                                       iout3_low_limit;      /**< Under current limit for Iout3 */
#if (BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES == 4U)
  const uint32_t                                       iout4_high_limit;     /**< Over current limit for Iout4 */
  const uint32_t                                       iout4_low_limit;      /**< Under current limit for Iout4 */
#endif
#endif

  const bool                                           soft_start_enable;    /**< Selection of soft start feature */
  const bool                                           blanking;             /**< Selection of Blanking feature */
  const bool                                           filter_comparator;    /**< Selection of filter comparator feature */
  const bool                                           slope_compensation;   /**< Selection of slope compensation feature */

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
#if(UC_FAMILY == XMC4) /* XMC44, XMC42, XMC41 */
  const float                                          volt_step_increment;  /**< Voltage is incremented with this step value when soft start feature is selected */
#else /* XMC1x family */
  const uint32_t                                       volt_step_increment;  /**< Voltage is incremented with this step value when soft start feature is selected */
#endif

  const uint32_t                                       systick_timer_period; /**< Time taken for a soft start ramp to reach set value */
  const SYSTIMER_CALLBACK_t                            systimer_call_back;   /**< Systimer call back function for the instance */
#endif
} BUCK_PCC_FIX_FQ_CONFIG_t;

/**
 * Handler structure with pointers to dynamic and static parameters.
 */
typedef struct BUCK_PCC_FIX_FQ
{
  const BUCK_PCC_FIX_FQ_CONFIG_t                *const config;               /**< Pointer to BUCK_PCC_FIX_FQ APP configuration structure */
  const BUCK_PCC_FIX_FQ_ADCConfig_t             *const adc_config;           /**< Pointer to ADC configuration structure */
  const BUCK_PCC_FIX_FQ_PWMConfig_t             *const pwm_config;           /**< Pointer to PWM configuration structure */

#ifdef BUCK_PCC_FIX_FQ_RESULT_INT_USED
  const BUCK_PCC_FIX_FQ_IntConfig_t             *const interrupt_config;     /**< Pointer to Interrupt configuration structure */
#endif

        uint32_t                                       ccu_modules;          /**< Stores the kernel positions of the used timers */
        BUCK_PCC_FIX_FQ_STATE_t                        state;                /**< Defines the current state of the APP */
        bool                                           enable_load_protection; /**< Stores the ON / OFF state for load protection. Load protection will be turned ON once it crosses vout_low_limit mark */

#if(UC_FAMILY == XMC4) /* XMC44, XMC42, XMC41 */
        float                                          vout_reference;       /**< Buck output voltage */
        float                                          buck_vout;            /**< Buck output voltage */
        float                                          buck_vin;             /**< Buck input voltage */
        float                                          buck_iout1;           /**< Buck inductor current for phase 0 */
        float                                          buck_iout2;           /**< Buck inductor current for phase 1 */
        float                                          buck_iout3;           /**< Buck inductor current for phase 2 */
#if (BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES == 4U)
        float                                          buck_iout4;           /**< Buck inductor current for phase 3 */
#endif
        float                                          buck_udef_adc_value;  /**< The value of user defined measurement 1 is stored in ISR execution */

        float                                          vout_avg;             /**< Stores the approximate rolling average for Vout*/
        float                                          vin_avg;              /**< Stores the approximate rolling average for Vin*/
        float                                          iout1_avg;            /**< Stores the approximate rolling average for Iout1*/
        float                                          iout2_avg;            /**< Stores the approximate rolling average for Iout2*/
        float                                          iout3_avg;            /**< Stores the approximate rolling average for Iout3*/
        float                                          iout4_avg;            /**< Stores the approximate rolling average for Iout4*/

#ifdef BUCK_PCC_FIX_FQ_PI_FILTER_USED
        CONTROL_LIB_PI_DATA_FLOAT_t             *const pi;                   /**< Pointer to CONTROL_LIB APP PI filter coefficients handler*/
#endif
#ifdef BUCK_PCC_FIX_FQ_TYPE_II_FILTER_USED
        CONTROL_LIB_2P2Z_DATA_FLOAT_t           *const typeII;               /**< Pointer to CONTROL_LIB APP type 2 filter coefficients handler*/
#endif
#ifdef BUCK_PCC_FIX_FQ_TYPE_III_FILTER_USED
        CONTROL_LIB_3P3Z_DATA_FLOAT_t           *const typeIII;              /**< Pointer to CONTROL_LIB APP type 3 filter coefficients handler*/
#endif

#else /* XMC1x family */
        uint16_t                                       vout_reference;       /**< Buck reference voltage */
        uint32_t                                       buck_vout;            /**< Buck output voltage */
        uint32_t                                       buck_vin;             /**< Buck input voltage */
        uint32_t                                       buck_iout1;           /**< Buck inductor current for phase 0 */
        uint32_t                                       buck_iout2;           /**< Buck inductor current for phase 1 */
        uint32_t                                       buck_iout3;           /**< Buck inductor current for phase 2 */
#if (BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES == 4U)
        uint32_t                                       buck_iout4;           /**< Buck inductor current for phase 3 */
#endif
        uint32_t                                       buck_udef_adc_value;  /**< The value of user defined measurement 1 is stored in ISR execution */

        uint32_t                                       vout_avg;             /**< Stores the approximate rolling average for Vout measured by ADC*/
        uint32_t                                       vin_avg;              /**< Stores the approximate rolling average for Vin measured by ADC*/
        uint32_t                                       iout1_avg;            /**< Stores the approximate rolling average for Iout1 measured by ADC*/
        uint32_t                                       iout2_avg;            /**< Stores the approximate rolling average for Iout2 measured by ADC*/
        uint32_t                                       iout3_avg;            /**< Stores the approximate rolling average for Iout3 measured by ADC*/
        uint32_t                                       iout4_avg;            /**< Stores the approximate rolling average for Iout4 measured by ADC*/

#ifdef BUCK_PCC_FIX_FQ_PI_FILTER_USED
        CONTROL_LIB_PI_DATA_FIXED_POINT_t       *const pi;                   /**< Pointer to CONTROL_LIB APP PI filter coefficients handler*/
#endif
#ifdef BUCK_PCC_FIX_FQ_TYPE_II_FILTER_USED
        CONTROL_LIB_2P2Z_DATA_FIXED_POINT_t     *const typeII;               /**< Pointer to CONTROL_LIB APP type 2 filter coefficients handler*/
#endif
#ifdef BUCK_PCC_FIX_FQ_TYPE_III_FILTER_USED
        CONTROL_LIB_3P3Z_DATA_FIXED_POINT_t     *const typeIII;              /**< Pointer to CONTROL_LIB APP type 3 filter coefficients handler*/
#endif

#endif

        XMC_VADC_GROUP_t                        *const group_ptr_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH];            /**< Pointer to group pointer structure*/
#ifdef BUCK_PCC_FIX_FQ_ADC_SCAN_USED
        ADC_SCAN_t                              *const adc_scan_app_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH];  /**< Pointer to ADC_SCAN APP handler */
#endif
#ifdef BUCK_PCC_FIX_FQ_ADC_QUEUE_USED
        ADC_QUEUE_t                             *const adc_queue_app_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_ADC_CH]; /**< Pointer to ADC_QUEUE APP handler */
#endif

#ifdef BUCK_PCC_FIX_FQ_PWM_CCU8_USED
        PWM_CCU8_t                              *const pwm_ccu8_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES];  /**< Pointer to PWM_CCU8 APP handler */
        COMP_REF_t                              *const comp_ref_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES];  /**< Pointer to COMP_REF APP handler */
#ifdef BUCK_PCC_FIX_FQ_BLANKING_OR_SLOPE_USED
        PWM_CCU4_t                              *const pwm_ccu4_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES];  /**< Pointer to PWM_CCU4 APP handler */
#endif
#ifdef BUCK_PCC_FIX_FQ_BLANKING_AND_SLOPE_USED
        const DIGITAL_IO_t                      *const digital_io_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES];/**< Pointer to DIGITAL_IO APP handler */
#endif
#endif

#ifdef BUCK_PCC_FIX_FQ_HRPWM_USED
        HRPWM_t                                 *const hrpwm_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES];     /**< Pointer to HRPWM APP handler */
        COMP_SLOPE_GEN_t                        *const csg_handle_array[BUCK_PCC_FIX_FQ_NUM_OF_PWM_PHASES];       /**< Pointer to COMP_SLOPE_GEN APP handler */
#endif

#ifdef BUCK_PCC_FIX_FQ_SOFT_START_USED
        bool                                           soft_start_complete;                                       /**< Flag to check the completion of soft start */
        uint32_t                                       software_timer_id;                                         /**< ID of the software timer created by SYSTIMER_CreateTimer() */
        BUCK_PCC_FIX_FQ_SW_TIMER_STATUS_t              software_timer_status;                                     /**< Software timer status for SYSTIMER_StopTimer() API */
        SYSTIMER_t                              *const systimer_handle;                                           /**< Reference to SYSTIMER APP handle */
#endif
} BUCK_PCC_FIX_FQ_t;

/**
 * @}
 */
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/* Support for C++ */
#ifdef __cplusplus
extern "C" {
#endif

/**
 * @ingroup BUCK_PCC_FIX_FQ_apidoc
 * @{
 */

/**
 * @brief Initializes BUCK_PCC_FIX_FQ APP parameters and lower level APP's
 * @param handle_ptr Pointer to an instance of BUCK_PCC_FIX_FQ APP
 * @return BUCK_PCC_FIX_FQ_STATUS_t
 * BUCK_PCC_FIX_FQ_STATUS_SUCCESS - for successful API execution
 * BUCK_PCC_FIX_FQ_STATUS_FAILURE - for failure in API execution
 *
 * \par<b>Description:</b><br>
 * For sampling and converting Buck output voltage to digital, ADC_SCAN or ADC_QUEUE APP can be selected.
 * The API initializes the PWM APP's and ADC APP's.
 * If control loop is selected to execute after Vout Result Event then NVIC node is initialized.
 *
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *
 *   status = DAVE_Init();    // BUCK_PCC_FIX_FQ_Init() is called from DAVE_Init()
 *
 *   if (status != DAVE_STATUS_SUCCESS)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   while(1)
 *   {
 *   }
 *
 *   return 1;
 * }
 * @endcode <BR> </p>
 */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_Init(BUCK_PCC_FIX_FQ_t *handle_ptr);

/**
 * @brief Prepares the timers ready for PWM generation on a external signal event
 * @param handle_ptr Pointer to an instance of BUCK_PCC_FIX_FQ APP
 * @return BUCK_PCC_FIX_FQ_STATUS_t
 * BUCK_PCC_FIX_FQ_STATUS_SUCCESS - for successful API execution
 * BUCK_PCC_FIX_FQ_STATUS_FAILURE - for failure in API execution
 *
 * \par<b>Description:</b><br>
 * Maximum of four PWM generators could be used for interleaved Buck.
 * The API synchronously starts the all the timers required for PWM generation.
 *
 * \par<b>Note:</b><br>
 * If an external timer (User manual connection) is used to trigger ADC, BUCK_PCC_FIX_FQ_Start() should be called first
 * and then external PWM should be started. For this case it is advised to set the initial slope to a very low value in BUCK_PCC_FIX_FQ APP.
 *
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   BUCK_PCC_FIX_FQ_STATUS_t buck_api_status;
 *
 *   status = DAVE_Init();    // BUCK_PCC_FIX_FQ_Init() is called from DAVE_Init()
 *
 *   if(status != DAVE_STATUS_SUCCESS)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   buck_api_status = BUCK_PCC_FIX_FQ_Start(&BUCK_PCC_FIX_FQ_0);
 *
 *   while(1)
 *   {
 *     if (buck_api_status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
 *     {
 *       //API validation is success
 *       //user code
 *     }
 *   }
 *
 *   return 1;
 * }
 * @endcode <BR> </p>
 */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_Start(BUCK_PCC_FIX_FQ_t *handle_ptr);

/**
 * @brief Stops PWM generation by timers, disables ADC interrupt and clears compensator variables.
 * @param handle_ptr Pointer to an instance of BUCK_PCC_FIX_FQ APP
 * @return BUCK_PCC_FIX_FQ_STATUS_t
 * BUCK_PCC_FIX_FQ_STATUS_SUCCESS - for successful API execution
 * BUCK_PCC_FIX_FQ_STATUS_FAILURE - for failure in API execution
 *
 * \par<b>Description:</b><br>
 * Maximum of 3 PWM generators could be used for interleaved Buck.
 * The API stops the all the timers that are used in PWM generation.
 *
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   BUCK_PCC_FIX_FQ_STATUS_t buck_api_status;
 *
 *   float max_buck_vout = 5.0f;
 *
 *   status = DAVE_Init();    // BUCK_PCC_FIX_FQ_Init() is called from DAVE_Init()
 *
 *   if(status != DAVE_STATUS_SUCCESS)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   buck_api_status = BUCK_PCC_FIX_FQ_Start(&BUCK_PCC_FIX_FQ_0);
 *
 *   while(1)
 *   {
 *     if (buck_api_status == BUCK_PCC_FIX_FQ_STATUS_SUCCESS)
 *     {
 *       if (BUCK_PCC_FIX_FQ_0.buck_vout > max_buck_vout)
 *       {
 *         BUCK_PCC_FIX_FQ_Stop(&BUCK_PCC_FIX_FQ_0); // Stop buck when output is beyond max_buck_vout
 *       }
 *     }
 *   }
 *
 *   return 1;
 * }
 * @endcode <BR> </p>
 */
BUCK_PCC_FIX_FQ_STATUS_t BUCK_PCC_FIX_FQ_Stop(BUCK_PCC_FIX_FQ_t *handle_ptr);

/**
 * @brief Retrieves BUCK_PCC_FIX_FQ APP version
 * @return DAVE_APP_VERSION_t
 *
 * \par<b>Description:</b><br>
 * APP returns a version number (major, minor and patch number).
 * Applications may then audit such a version number to determine compatibility.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t version;
 *
 *   status = DAVE_Init(); // BUCK_PCC_FIX_FQ_Init() is called from DAVE_Init()
 *
 *   if(status != DAVE_STATUS_SUCCESS)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   version = BUCK_PCC_FIX_FQ_GetAppVersion();
 *
 *   if (version.major != 4U)
 *   {
 *     // Probably, not the right version.
 *   }
 *
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode <BR> </p>
 */
DAVE_APP_VERSION_t BUCK_PCC_FIX_FQ_GetAppVersion(void);

/**
 * @}
 */

/* Include APP extern declaration file */
#include "buck_pcc_fix_fq_extern.h"

#ifdef __cplusplus
}
#endif

#endif /* BUCK_PCC_FIX_FQ_H_ */
