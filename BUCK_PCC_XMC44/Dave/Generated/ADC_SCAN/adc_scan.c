/**
 * @file adc_scan.c
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ADC_SCAN v4.0.20 - Provides configurations for scan request source of VADC
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version for DAVEv4.<BR>
 *
 * 2015-04-27:
 *     - Updated the ADC_SCAN_Init() API for consistency.<BR>
 *
 * 2015-06-20:
 *     - Updated the copyright section.<BR>
 *
 * 2015-07-09:
 *     - Documentation updated.<BR>
 *
 * 2015-07-31:
 *     - Updated the APP to support new devices.<BR>
 *
 * 2015-10-01:
 *     - Iclass signal added to the APP.<BR>
 *
 * 2015-10-08:
 *     - Added support for XMC4700/XMC4800 devices.<BR>
 *
 * 2015-12-15:
 *          - Added support for XMC4300 devices.<BR>
 *          - Updated the APP to optimize the request source callback.<BR>
 *          - APIs touched are ADC_SCAN_InsertScanEntry(), ADC_SCAN_ResetListContents(),
 *            ADC_SCAN_ReqSrcEventHandler().<BR>
 *
 * 2016-01-19:
 *          - Added new APIs ADC_SCAN_EnableArbitration() and ADC_SCAN_DisableArbitration().<BR>
 *
 * 2016-04-03:
 *          - Total conversion time now includes post calibration time as well for XMC1x.<BR>
 *
 * 2016-08-18:
 *     - Minimum sample time at low frequencies changed to incorporate Errata ADC_AI.H006 and ADC_AI.H007.
 *
 * 2021-01-08:
 *     - Added ADC_SCAN_ResetListContentsEx()
 *     - Changed ADC_SCAN_ChannelEventHandler() and ADC_SCAN_ReqSrcEventHandler() to assert and check if callback function pointer is NULL prior invoking
 * 
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

/** Inclusion of header file */
#include "adc_scan.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define ADC_SCAN_INVALID_CHANNEL ((uint8_t)0xff)

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/
/**
 * @ingroup ADC_SCAN_datastructures
 * @{
 */
/**
 * @brief A 2 dimensional Array which contains all the ADC_SCAN entries. The list
 * contains entries which can be indexed using channel numbers and its group number.
 */
ADC_SCAN_ENTRY_t *adc_scan_list_ptrs[ADC_SCAN_NUM_GROUPS];

static ADC_SCAN_EVENT_CALLBACK adc_scan_callback_list[ADC_SCAN_NUM_GROUPS][ADC_SCAN_NUM_CHANNELS];
/**
 * @}
 */

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
/** This function populates the ADC_SCAN list of pointers and called from ADC_SCAN_Init().
 * ADC_SCAN_ResetListContents() is in turn called from the API.
 * This API will just initialize the data structure adc_scan_list_ptrs with the appropriate pointers.*/
void ADC_SCAN_lInitializeListToDefaults(uint8_t instance_num);

/* Declaration for the memcpy library function*/
void *memcpy(void *str1, const void *str2, size_t n);


/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/

/*This function returns the version of the ADC_SCAN APP*/
DAVE_APP_VERSION_t ADC_SCAN_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = (uint8_t) ADC_SCAN_MAJOR_VERSION;
  version.minor = (uint8_t) ADC_SCAN_MINOR_VERSION;
  version.patch = (uint8_t) ADC_SCAN_PATCH_VERSION;

  return version;
}
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* This function initialization the APP */
ADC_SCAN_STATUS_t ADC_SCAN_Init(ADC_SCAN_t *const handle_ptr)
{
  ADC_SCAN_STATUS_t status;

  XMC_ASSERT("ADC_SCAN_Init:Invalid handle_ptr", (handle_ptr != NULL));

  if (ADC_SCAN_UNINITIALIZED == handle_ptr->init_status)
  {
    /*Initialization of APP 'ADCGroup'*/
    status = (ADC_SCAN_STATUS_t) GLOBAL_ADC_Init(handle_ptr->global_handle);
  
    XMC_VADC_GROUP_InputClassInit(handle_ptr->group_handle, handle_ptr->iclass_config_handle,
                                  XMC_VADC_GROUP_CONV_STD, (uint32_t)handle_ptr->iclass_num);


    /*Initialization of scan request source*/
    XMC_VADC_GROUP_ScanInit(handle_ptr->group_handle, handle_ptr->scan_config_handle);

    /* Configure the gating mode for Scan*/
    XMC_VADC_GROUP_ScanSetGatingMode(handle_ptr->group_handle, handle_ptr->gating_mode);

    /* Clear the internal data structure of scan APP */
    ADC_SCAN_lInitializeListToDefaults(handle_ptr->instance_number);

    /*Interrupt Configuration*/
    if ((bool)true == handle_ptr->rs_intr_handle->interrupt_enable)
    {
#if (UC_FAMILY == XMC1)
      NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle->node_id, handle_ptr->rs_intr_handle->priority);
#else
      NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle->node_id,
                        NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                        handle_ptr->rs_intr_handle->priority,handle_ptr->rs_intr_handle->sub_priority));
#endif
#ifdef ADC_SCAN_NON_DEFAULT_IRQ_SOURCE_SELECTED
  XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle->node_id,
                              ((handle_ptr->rs_intr_handle->node_id << 8) | handle_ptr->rs_intr_handle->irqctrl));
#endif

      /* Connect RS Events to NVIC nodes */
      XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(handle_ptr->group_handle, handle_ptr->srv_req_node);

      /* Enable Interrupt */
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->rs_intr_handle->node_id);
    }
    handle_ptr->init_status = status;
  }
  return (handle_ptr->init_status);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* API to reset (De-Initialize) contents of all Scan entries */
void ADC_SCAN_ResetListContents(uint8_t instance_num)
{
  XMC_ASSERT("ADC_SCAN_ResetListContents:Wrong Instance number",(instance_num < ADC_SCAN_NUM_APPINSTANCES));

  memset(adc_scan_list_ptrs[instance_num], ADC_SCAN_INVALID_CHANNEL ,(sizeof(ADC_SCAN_ENTRY_t)* ADC_SCAN_NUM_CHANNELS));

  memset(adc_scan_callback_list[instance_num], (uint32_t)0 ,(sizeof(ADC_SCAN_EVENT_CALLBACK) * ADC_SCAN_NUM_CHANNELS));
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
void ADC_SCAN_ResetListContentsEx(ADC_SCAN_t *const handle_ptr)
{
  ADC_SCAN_ResetListContents(handle_ptr->instance_number);
  handle_ptr->number_valid_callback = 0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* API to insert one single Channel */
void ADC_SCAN_InsertScanEntry(ADC_SCAN_t *const handle_ptr,const ADC_SCAN_ENTRY_t *entry)
{
  ADC_SCAN_ENTRY_t *node;
  ADC_SCAN_EVENT_CALLBACK *callback_node,entry_callback;
  int8_t i;
  bool insert_yes;

  XMC_ASSERT("ADC_SCAN_InsertScanEntry:Invalid handle_ptr", (handle_ptr != NULL));
  XMC_ASSERT("ADC_SCAN_InsertScanEntry:Invalid scan entry", (entry != NULL));

  /* Insert this entry into a list which is arranged on the basis of channel numbers */
  node = adc_scan_list_ptrs[handle_ptr->instance_number];
  node = node + entry->channel_number;
  memcpy((void*)node,(void*) entry,sizeof(ADC_SCAN_ENTRY_t));

  entry_callback = entry->adc_event_callback;
  callback_node = adc_scan_callback_list[handle_ptr->instance_number];
  insert_yes = (bool)true;
  if(NULL != entry_callback)
  {
    for(i = (int8_t)handle_ptr->number_valid_callback; i >= (int32_t)0;i--)
    {
      if(*(callback_node + i) == entry_callback)
      {
        insert_yes = false;
        break;
      }
    }

    if(insert_yes != false)
    {
      adc_scan_callback_list[handle_ptr->instance_number][handle_ptr->number_valid_callback++] = entry_callback;
    }
  }


}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* API to Program the scan HW on the controller */
void ADC_SCAN_AllEntriesInserted(ADC_SCAN_t *handle_ptr)
{
  uint32_t index;
  ADC_SCAN_ENTRY_t *node;
  ADC_SCAN_ENTRY_t *start_node;

  XMC_ASSERT("ADC_SCAN_AllEntriesInserted:Invalid handle_ptr", (handle_ptr != NULL));

  start_node = adc_scan_list_ptrs[handle_ptr->instance_number];
  
  for (index = 0U; index < ADC_SCAN_NUM_CHANNELS; index++)
  {
    node = start_node + index;
    if (((ADC_SCAN_ENTRY_t*)NULL != node) && (ADC_SCAN_INVALID_CHANNEL != node->channel_number))
    {
      XMC_VADC_GROUP_ScanAddChannelToSequence(handle_ptr->group_handle, (uint32_t)node->channel_number);
    }
  }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*Interrupt handler for Channel Event*/
void ADC_SCAN_ChannelEventHandler(ADC_SCAN_t *const handle_ptr)
{
  uint32_t ceflag;
  uint32_t ch_index;
  ADC_SCAN_ENTRY_t *node;

  XMC_ASSERT("ADC_SCAN_ChannelEventHandler:Invalid handle_ptr", (handle_ptr != NULL));

  ceflag = handle_ptr->group_handle->CEFLAG;

  for (ch_index = 0U; ch_index < ADC_SCAN_NUM_CHANNELS; ch_index++)
  {
    if ((uint32_t)(ceflag >> ch_index) & 1U)
    {
      break;
    }
  }

  if (ADC_SCAN_NUM_CHANNELS != ch_index )
  {
    /* Clear the event and exit the ISR */
    XMC_VADC_GROUP_ChannelClearEvent(handle_ptr->group_handle,ch_index);

    /* Get the list entry corresponding to this channel */
    node = adc_scan_list_ptrs[handle_ptr->instance_number];
    node = node + ch_index;
    
    /* Find out if application has requested for channel event notification for the channel in question */
    if (node->ch_event_notification != (bool)false)
    {
      ADC_SCAN_EVENT_CALLBACK channel_event_cb = node->adc_event_callback;
      XMC_ASSERT("ADC_SCAN_ChannelEventHandler:Invalid callback function pointer", (channel_event_cb != NULL));
      channel_event_cb();
    }
  }
} 

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*Interrupt handler for Request Source Event*/
void ADC_SCAN_ReqSrcEventHandler(ADC_SCAN_t *const handle_ptr)
{
  int32_t ch_index;
  ADC_SCAN_EVENT_CALLBACK *callback_node;

  XMC_ASSERT("ADC_SCAN_ReqSrcEventHandler:Invalid handle_ptr", (handle_ptr != NULL));
  
  XMC_VADC_GROUP_ScanClearReqSrcEvent(handle_ptr->group_handle);
  
  callback_node = adc_scan_callback_list[handle_ptr->instance_number];
  /* Iterate over all the valid entries and locate entries that requested a request source notification*/
  for ( ch_index = (int32_t)handle_ptr->number_valid_callback - (int32_t)1; ch_index >= (int32_t)0; ch_index--)
  {
    ADC_SCAN_EVENT_CALLBACK reqsrc_event_cb = *(callback_node + ch_index);
    XMC_ASSERT("ADC_SCAN_ReqSrcEventHandler:Invalid callback function pointer", (reqsrc_event_cb != NULL));
    reqsrc_event_cb();
  }
}
/*CODE BLOCK END*/
