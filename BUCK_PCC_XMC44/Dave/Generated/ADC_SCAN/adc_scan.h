/**
 * @file adc_scan.h
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ADC_SCAN v4.0.20 - Provides configurations for scan request source of VADC
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version for DAVEv4.<BR>
 *
 * 2015-04-27:
 *     - Updated the ADC_SCAN_Init() API for consistency.<BR>
 *
 * 2015-06-20:
 *     - Updated the copyright section.<BR>
 *
 * 2015-07-09:
 *     - Documentation updated.<BR>
 *
 * 2015-07-31:
 *     - Updated the APP to support new devices.<BR>
 *
 * 2015-10-01:
 *     - Iclass signal added to the APP.<BR>
 *
 * 2015-10-08:
 *     - Added support for XMC4700/XMC4800 devices.<BR>
 *
 * 2015-12-15:
 *          - Added support for XMC4300 devices.<BR>
 *          - Updated the APP to optimize the request source callback.<BR>
 *          - APIs touched are ADC_SCAN_InsertScanEntry(), ADC_SCAN_ResetListContents(),
 *            ADC_SCAN_ReqSrcEventHandler().<BR>>
 *
 * 2016-01-19:
 *          - Added new APIs ADC_SCAN_EnableArbitration() and ADC_SCAN_DisableArbitration().<BR>
 *
 * 2016-04-03:
 *          - Total conversion time now includes post calibration time as well for XMC1x.<BR>
 *
 * 2016-08-18:
 *     - Minimum sample time at low frequencies changed to incorporate Errata ADC_AI.H006 and ADC_AI.H007.
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *     - Added ADC_SCAN_ResetListContentsEx().
 *
 * @endcond
 *
 */

/*CODE_BLOCK_BEGIN*/
#ifndef ADC_SCAN_H
#define ADC_SCAN_H

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include "GLOBAL_ADC/global_adc.h"
#include "adc_scan_conf.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define ADC_SCAN_XMC_LIB_MAJOR_VERSION 2
#define ADC_SCAN_XMC_LIB_MINOR_VERSION 0
#define ADC_SCAN_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > ADC_SCAN_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == ADC_SCAN_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > ADC_SCAN_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == ADC_SCAN_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == ADC_SCAN_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= ADC_SCAN_XMC_LIB_PATCH_VERSION)))
#error "ADC_SCAN requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**
 * @ingroup ADC_SCAN_constants
 * @{
 */
#define ADC_SCAN_NUM_CHANNELS XMC_VADC_NUM_CHANNELS_PER_GROUP /**< This Macro gives the number of adc channels per group*/

#define ADC_SCAN_NUM_GROUPS	XMC_VADC_MAXIMUM_NUM_GROUPS /**< This Macro gives the number of groups
                                                             present for the specific device*/

/**
 * @}
 */
 /**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup ADC_SCAN_enumerations
 * @{
 */
/**@brief Return value of an API  */
typedef enum ADC_SCAN_STATUS
{
  ADC_SCAN_SUCCESS = 0, /**< APP is Initialized*/
  ADC_SCAN_FAILURE, 		  /**< Initialization failed*/
  ADC_SCAN_UNINITIALIZED   /**< APP is Uninitialized*/
} ADC_SCAN_STATUS_t;
/**
 * @}
 */

/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * @ingroup ADC_SCAN_datastructures
 * @{
 */

typedef  void (*ADC_SCAN_EVENT_CALLBACK)(void);

/**
 * @brief Structure holding information on a new scan entry.
 */
typedef struct ADC_SCAN_ENTRY
{
  uint8_t channel_number; 	  /**<This indicates the channel number that must be converted. */

  bool ch_event_notification; /**< This flag indicates that the channel event interrupt is required.*/

  bool rs_event_notification; /**< This flag indicates that the request source event interrupt is required.*/

  ADC_SCAN_EVENT_CALLBACK adc_event_callback;/**<The call back function when a
                                                request source event of a channel event is requested. */
} ADC_SCAN_ENTRY_t;

/**
 * @brief NVIC Configuration structure for scan request source interrupt.
 */
typedef struct ADC_SCAN_ISRHandle_t
{
  uint32_t node_id;		 /**< This indicates the NVIC Node number.*/

  uint32_t priority;	 /**< This indicates the NVIC priority.*/
#if(UC_FAMILY == XMC4)
  uint32_t sub_priority; /**< This indicates the NVIC sub priority in XMC4x Devices.*/
#endif
  bool interrupt_enable; /**< This flag indicates if a Interrupt has been requested.*/
#ifdef ADC_SCAN_NON_DEFAULT_IRQ_SOURCE_SELECTED
  uint8_t irqctrl; 	     /**< This indicates the service request source selected for the consumed NVIC node.*/
#endif
} ADC_SCAN_ISR_t;

/**
 * @brief Configuration Data structure of ADC_SCAN APP.
 */
typedef struct ADC_SCAN_Handle
{
  const XMC_VADC_GROUP_CLASS_t iclass_config_handle;	 /**< Holds the ICLASS Configurations*/

  const XMC_VADC_SCAN_CONFIG_t *const scan_config_handle;/**< Holds the LLD SCAN Structure*/

  GLOBAL_ADC_t* const global_handle;					 /**< Holds the Global Pointer of the Group*/

  XMC_VADC_GROUP_t *const group_handle;					 /**< Holds the group Pointer of the Group*/

  XMC_VADC_GATEMODE_t gating_mode;                      /**< Gating mode configuration needed for Scan request source*/

  const ADC_SCAN_ISR_t* const rs_intr_handle;			 /**< Holds the ISR Handle*/

  const XMC_VADC_SR_t srv_req_node;						 /**< Source event interrupt node pointer*/

  ADC_SCAN_STATUS_t init_status;						 /**< This holds the state of the ADC_SCAN APP Instance*/

  const uint8_t instance_number;						 /**< Holds the instance number*/

  const uint8_t iclass_num;								 /**< Holds the ICLASS ID either ICLASS-0 or ICLASS-1*/

  const uint8_t group_index; 							 /**< Represents group index number of scan instance*/

  uint8_t number_valid_callback;            /**< Index for valid request source callback functions */
} ADC_SCAN_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @ingroup ADC_SCAN_apidoc
 * @{
 */

/**
 * @brief Get ADC_SCAN APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void) 
 * {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize ADC_SCAN APP:
 *   // ADC_SCAN_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = ADC_SCAN_GetAppVersion();
 *   if (version.major != 1U) {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode
 */
DAVE_APP_VERSION_t ADC_SCAN_GetAppVersion(void);

/**
 * @brief Initializes the ADC scan request source.
 * parameters. <BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return ADC_SCAN_STATUS_t status of the initialization.
 *
 * \par<b>Description:</b><br>
 * Initializes the ADC scan request source.
 * Invokes various VADC LLD API to initialize the VADC scan request source. This would invoke
 * The GLBOAL_ADC_Init(), if interrupt is consumed for a specific instance it would also invoke
 * CPU_CTRL_XMCx_Init (x = 4 or 1). It also invokes XMC_VADC_GROUP_ScanInit() XMC_VADC_GROUP_ScanSetGatingMode()
 * XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode() to configure the scan source.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ADC_SCAN_STATUS_t ADC_SCAN_Init(ADC_SCAN_t *const handle_ptr);

/**
 * @brief Resets the APP data structure which holds the inserted channels.
 * @param instance_num This is the instance number of the ADC_SCAN APP which has to be reset.<BR>
 *
 * @return None <BR>
 * @deprecated Use instead ADC_QUEUE_ResetListContentsEx()
 *
 * \par<b>Description:</b><br>
 * Resets the APP data structure which holds the inserted channels.
 * The ADC_SCAN APP holds an internal data structure (::adc_scan_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_scan_list_ptrs) is sorted in ascending order of channel
 * number. When the Reset List Contents API is invoked it would clear all the previous
 * contents of this data structure. This resets the data structure such that channel_number is set as
 * INVALID_CHANNEL and all its other fields are 0. ADC_SCAN_lInitializeListToDefaults() would invoke this
 * API at ADC_SCAN_Init().
 *
 * \par<b>Note:</b><br>
 * Invoking this API will not effect any channel(s) which have already been pushed to the channel selection register
 * in the hardware.
 *
 * @code
 * #include "DAVE.h"
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = false,
 *   .adc_event_callback    = NULL
 * };
 *
 * ADC_SCAN_ENTRY_t ch_entry1 =
 * {
 *   .channel_number        = 2U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = false,
 *   .adc_event_callback    = NULL
 * };
 *
 * ADC_SCAN_ENTRY_t ch_entry2 =
 * {
 *   .channel_number        = 3U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = false,
 *   .adc_event_callback    = NULL
 * };
 *
 * int main(void)
 * {
 *
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry1);
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry2);
 *   // 3 entries present in the data structure.
 *   ADC_SCAN_ResetListContents(ADC_SCAN_0.instance_number);
 *   //0 Entries present in the data structure because of the reset.
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ADC_SCAN_ResetListContents(uint8_t instance_num);

/**
 * @brief Resets the APP data structure which holds the inserted channels.
 * @param handle_ptr pointer (ADC_SCAN_t) to the instance variable and the handle pointer.<BR>
 *
 * @return None <BR>
 * @deprecated Use instead ADC_QUEUE_ResetListContentsEx()
 *
 * \par<b>Description:</b><br>
 * Resets the APP data structure which holds the inserted channels.
 * The ADC_SCAN APP holds an internal data structure (::adc_scan_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_scan_list_ptrs) is sorted in ascending order of channel
 * number. When the Reset List Contents API is invoked it would clear all the previous
 * contents of this data structure. This resets the data structure such that channel_number is set as
 * INVALID_CHANNEL and all its other fields are 0. ADC_SCAN_lInitializeListToDefaults() would invoke this
 * API at ADC_SCAN_Init().
 *
 * \par<b>Note:</b><br>
 * Invoking this API will not effect any channel(s) which have already been pushed to the channel selection register
 * in the hardware.
 *
 * @code
 * #include "DAVE.h"
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = false,
 *   .adc_event_callback    = NULL
 * };
 *
 * ADC_SCAN_ENTRY_t ch_entry1 =
 * {
 *   .channel_number        = 2U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = false,
 *   .adc_event_callback    = NULL
 * };
 *
 * ADC_SCAN_ENTRY_t ch_entry2 =
 * {
 *   .channel_number        = 3U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = false,
 *   .adc_event_callback    = NULL
 * };
 *
 * int main(void)
 * {
 *
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry1);
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry2);
 *   // 3 entries present in the data structure.
 *   ADC_SCAN_ResetListContents(ADC_SCAN_0.instance_number);
 *   //0 Entries present in the data structure because of the reset.
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ADC_SCAN_ResetListContentsEx(ADC_SCAN_t *const handle_ptr);

/**
 * @brief  Inserts an scan entry into the local data structure.<BR>
 * @param handle_ptr pointer (ADC_SCAN_t) to the instance variable and the handle pointer.<BR>
 * @param entry This holds the configuration of one entry into scan sequence
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Inserts an scan entry into the local data structure.
 * The ADC_SCAN APP holds an internal data structure (::adc_scan_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_scan_list_ptrs) is sorted in ascending order of channel
 * number. When an insert is called the scan entry would be copied into this data structure.
 * The insert option would populate the data structure in ascending order of channel number.
 *
 * \par<b>Note:</b><br>
 * Invoking this API will not add a new channel into the scan channel selection register of the hardware. The operation
 * of adding all the required channel into the hardware would be done using the method ADC_SCAN_AllEntriesInserted().
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
 * #include "DAVE.h"
 *
 * void adc_callback(void);
 * XMC_VADC_RESULT_SIZE_t result[3];
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = true,
 *   .adc_event_callback    = (adc_callback)
 * };
 *
 * static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
 * {
 *   .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
 *   .lower_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .upper_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
 *   .sync_conversion  		    = (uint32_t) 0,                            // Sync feature disabled
 *   .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
 *   .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
 *   .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
 *   .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
 *   .broken_wire_detect		    = (uint32_t) 0,    		                 // No Broken wire detection
 *   .bfl                        = (uint32_t) 0,                            //No Boundary flag
 *   .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
 *                                                // by background request source
 *   .alias_channel              = (int8_t) -1                              // Alias feature not selected
 * };
 *
 * XMC_VADC_RESULT_CONFIG_t res_handle =
 * {
 *   .data_reduction_control   = (uint8_t) 0,  // No Accumulation
 *   .post_processing_mode     = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
 *   .wait_for_read_mode  	  = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
 *   .part_of_fifo       	  = (uint32_t) 0,  // FIFO has been disabled
 *   .event_gen_enable   	  = (uint32_t) 0   // result event generation disabled
 * };
 *
 * void adc_callback(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry0.channel_number);
 *   result[0] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 *
 * int main(void)
 * {
 *
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   ADC_SCAN_AllEntriesInserted(&ADC_SCAN_0);
 *   XMC_VADC_GROUP_ScanTriggerConversion(ADC_SCAN_0.group_handle);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ADC_SCAN_InsertScanEntry(ADC_SCAN_t *const handle_ptr, const ADC_SCAN_ENTRY_t *entry);

/**
 * @brief Inserts all scan entries into ADC scan channel selection register.<BR>
 * @param handle_ptr pointer (ADC_SCAN_t) to the instance variable <BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Inserts all scan entries into ADC scan channel selection register(programs the hardware).
 * The ADC_SCAN APP holds an internal data structure (::adc_scan_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_scan_list_ptrs) is sorted in ascending order of channel
 * number. When this API is invoked all the scan entries that have been inserted
 * into the data structure will be programmed into the hardware.All valid channels would be selected in the
 * scan channel selection register.
 *
 * \par<b>Note:</b><br>
 * The number of channels that can be inserted are limited to 8(Total number of available channels).
 *
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
 * #include "DAVE.h"
 *
 * void adc_callback(void);
 * void adc_callback2(void);
 * void adc_callback3(void);
 * XMC_VADC_RESULT_SIZE_t result[3];
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = true,
 *   .adc_event_callback    = (adc_callback)
 * };
 *
 * ADC_SCAN_ENTRY_t ch_entry1 =
 * {
 *   .channel_number        = 2U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = true,
 *   .adc_event_callback    = (adc_callback2)
 * };
 *
 * ADC_SCAN_ENTRY_t ch_entry2 =
 * {
 *   .channel_number        = 3U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = true,
 *   .adc_event_callback    = (adc_callback3)
 * };
 *
 * static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
 * {
 *   .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
 *   .lower_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .upper_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
 *   .sync_conversion  		    = (uint32_t) 0,                            // Sync feature disabled
 *   .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
 *   .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
 *   .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
 *   .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
 *   .broken_wire_detect		    = (uint32_t) 0,    		                 // No Broken wire detection
 *   .bfl                        = (uint32_t) 0,                            //No Boundary flag
 *   .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
 *                                                // by background request source
 *   .alias_channel              = (int8_t) -1                              // Alias feature not selected
 * };
 *
 * XMC_VADC_RESULT_CONFIG_t res_handle =
 * {
 *   .data_reduction_control   = (uint8_t) 0,  // No Accumulation
 *   .post_processing_mode     = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
 *   .wait_for_read_mode  	  = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
 *   .part_of_fifo       	  = (uint32_t) 0,  // FIFO has been disabled
 *   .event_gen_enable   	  = (uint32_t) 0   // result event generation disabled
 * };
 *
 * void adc_callback(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry0.channel_number);
 *   result[0] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 *
 * void adc_callback2(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry1.channel_number);
 *   result[1] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 * 
 * void adc_callback3(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry2.channel_number);
 *   result[2] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 *
 * int main(void)
 * {
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   ch_handle.result_reg_number = ch_entry0.channel_number;
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry1);
 *   ch_handle.result_reg_number = ch_entry1.channel_number;
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry1.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry2);
 *   ch_handle.result_reg_number = ch_entry2.channel_number;
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry2.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   ADC_SCAN_AllEntriesInserted(&ADC_SCAN_0);
 *   XMC_VADC_GROUP_ScanTriggerConversion(ADC_SCAN_0.group_handle);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ADC_SCAN_AllEntriesInserted(ADC_SCAN_t *const handle_ptr);

/**
 * @brief Channel event handler for the scan channels.<BR>
 * @param handle_ptr pointer (ADC_SCAN_t) to the instance variable <BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Channel event handler for the scan channels.
 * The ADC_SCAN APP holds an internal data structure (::adc_scan_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_scan_list_ptrs) is sorted in ascending order of channel
 * number. In each entry it is possible to mention if channel event notification
 * is required. This API will read ::ADC_SCAN_ENTRY_t::ch_event_notification field of all the scan entries,
 * if a notification is needed then a specific callback is invoked. This callback function is mentioned in the
 * scan entry field ::ADC_SCAN_ENTRY_t::adc_event_callback for that channel.
 *
 * \par<b>Note:</b><br>
 * Channel event is not configured by this API. Channel event needs to be configured using a VADC LLD API.
 * If both channel event and request source event needs to be enabled, the field ::ADC_SCAN_ENTRY_t::adc_event_callback
 * callback function would be invoked from both the handlers(channel event(ADC_SCAN_ChannelEventHandler())
 * and request source event(ADC_SCAN_ReqSrcEventHandler())).
 *
 * @code
 * #include "DAVE.h"
 * void adc_callback(void);
 * XMC_VADC_RESULT_SIZE_t result[3];
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = true,
 *   .rs_event_notification = false,
 *   .adc_event_callback    = (adc_callback)
 * };
 *
 * static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
 * {
 *   .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
 *   .lower_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .upper_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_ALWAYS, //Channel Event disabled
 *   .sync_conversion  		    = (uint32_t) 0,                            // Sync feature disabled
 *   .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
 *   .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
 *   .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
 *   .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
 *   .broken_wire_detect		    = (uint32_t) 0,    		                 // No Broken wire detection
 *   .bfl                        = (uint32_t) 0,                            //No Boundary flag
 *   .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
 *                                                // by background request source
 *   .alias_channel              = (int8_t) -1                              // Alias feature not selected
 * };
 *
 * XMC_VADC_RESULT_CONFIG_t res_handle =
 * {
 *   .data_reduction_control   = (uint8_t)  0,  // No Accumulation
 *   .post_processing_mode     = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
 *   .wait_for_read_mode  	  = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
 *   .part_of_fifo       	  = (uint32_t) 0,  // FIFO has been disabled
 *   .event_gen_enable   	  = (uint32_t) 0   // result event generation disabled
 * };
 *
 * void VADC0_G0_1_IRQHandler(void)
 * {
 *   ADC_SCAN_ChannelEventHandler(&ADC_SCAN_0);
 * }
 *
 * void adc_callback(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry0.channel_number);
 *   result[0] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 *
 * int main(void)
 * {
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   ch_handle.result_reg_number = ch_entry0.channel_number;
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   // Set interrupt node for the channel events
 *   XMC_VADC_GROUP_ChannelSetEventInterruptNode(ADC_SCAN_0.group_handle, ch_entry0.channel_number,
 *                                               XMC_VADC_SR_GROUP_SR1);
 *   // Enable the NVIC node for the channel event
 *   NVIC_EnableIRQ(VADC0_G0_1_IRQn);
 *   ADC_SCAN_AllEntriesInserted(&ADC_SCAN_0);
 *   XMC_VADC_GROUP_ScanTriggerConversion(ADC_SCAN_0.group_handle);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ADC_SCAN_ChannelEventHandler(ADC_SCAN_t *const handle_ptr);

/**
 * @brief Scan Request source interrupt handler.<BR>
 * @param handle_ptr pointer (ADC_SCAN_t) to the instance variable <BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Scan Request source interrupt handler.
 * The ADC_SCAN APP holds an internal data structure (::adc_scan_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_scan_list_ptrs) is sorted in ascending order of channel
 * number. In each entry it is possible to mention if request source event notification
 * is required. This API will read ::ADC_SCAN_ENTRY_t::rs_event_notification field of all the scan entries,
 * if a notification is needed then a specific callback is invoked. This callback function is mentioned in the
 * scan entry field ::ADC_SCAN_ENTRY_t::adc_event_callback for that channel.
 *
 * \par<b>Note:</b><br>
 * Scan request source event is not configured by this API. request source event would be configured by the APP
 * using VADC LLD APIs. If both channel event and request source event needs to be enabled, the field
 * ::ADC_SCAN_ENTRY_t::adc_event_callback callback function would be invoked from both the handlers(channel
 * event(ADC_SCAN_ChannelEventHandler()) and request source event(ADC_SCAN_ReqSrcEventHandler())).
 *
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
 * #include "DAVE.h"
 * void adc_callback(void);
 * XMC_VADC_RESULT_SIZE_t result[3];
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = true,
 *   .adc_event_callback    = (adc_callback)
 * };
 *
 * static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
 * {
 *   .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
 *   .lower_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .upper_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
 *   .sync_conversion  		    = (uint32_t) 0,                            // Sync feature disabled
 *   .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
 *   .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
 *   .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
 *   .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
 *   .broken_wire_detect		    = (uint32_t) 0,    		                 // No Broken wire detection
 *   .bfl                        = (uint32_t) 0,                            //No Boundary flag
 *   .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
 *                                                // by background request source
 *   .alias_channel              = (int8_t) -1                              // Alias feature not selected
 * };
 *
 * XMC_VADC_RESULT_CONFIG_t res_handle =
 * {
 *   .data_reduction_control   = (uint8_t) 0,  // No Accumulation
 *   .post_processing_mode     = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
 *   .wait_for_read_mode  	  = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
 *   .part_of_fifo       	  = (uint32_t) 0,  // FIFO has been disabled
 *   .event_gen_enable   	  = (uint32_t) 0   // result event generation disabled
 * };
 *
 * void VADC0_G0_1_IRQHandler(void)
 * {
 *   ADC_SCAN_ReqSrcEventHandler(&ADC_SCAN_0);
 * }
 *
 * void adc_callback(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry0.channel_number);
 *   result[0] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 *
 * int main(void)
 * {
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   ch_handle.result_reg_number = ch_entry0.channel_number;
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   // Set the interrupt node for the scan request source events
 *   XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(ADC_SCAN_0.group_handle,XMC_VADC_SR_GROUP_SR1);
 *
 *   // Enable the NVIC node connected to the scan request source event
 *   NVIC_EnableIRQ(VADC0_G0_1_IRQn);
 *   ADC_SCAN_AllEntriesInserted(&ADC_SCAN_0);
 *   XMC_VADC_GROUP_ScanTriggerConversion(ADC_SCAN_0.group_handle);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ADC_SCAN_ReqSrcEventHandler(ADC_SCAN_t *const handle_ptr);

/**
 * @brief  Starts the scan request source arbitration.<BR>
 * @param handle_ptr pointer (ADC_SCAN_t) to the instance variable and the handle pointer.<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Starts the VADC arbiter for the scan request source.<BR>
 * After this API is invoked the ADC is ready for accepting conversion requests. When invoked this API
 * would write to GxARBPR.ASEN1 bit to enable the arbiter.
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
 * #include "DAVE.h"
 *
 * void adc_callback(void);
 * XMC_VADC_RESULT_SIZE_t result[3];
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = true,
 *   .adc_event_callback    = (adc_callback)
 * };
 *
 * static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
 * {
 *   .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
 *   .lower_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .upper_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
 *   .sync_conversion  		    = (uint32_t) 0,                            // Sync feature disabled
 *   .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
 *   .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
 *   .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
 *   .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
 *   .broken_wire_detect		    = (uint32_t) 0,    		                 // No Broken wire detection
 *   .bfl                        = (uint32_t) 0,                            //No Boundary flag
 *   .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
 *                                                // by background request source
 *   .alias_channel              = (int8_t) -1                              // Alias feature not selected
 * };
 *
 * XMC_VADC_RESULT_CONFIG_t res_handle =
 * {
 *   .data_reduction_control   = (uint8_t) 0,  // No Accumulation
 *   .post_processing_mode     = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
 *   .wait_for_read_mode  	  = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
 *   .part_of_fifo       	  = (uint32_t) 0,  // FIFO has been disabled
 *   .event_gen_enable   	  = (uint32_t) 0   // result event generation disabled
 * };
 *
 * void adc_callback(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry0.channel_number);
 *   result[0] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 *
 * int main(void)
 * {
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *   ADC_SCAN_DisableArbitration(&ADC_SCAN_0);
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   ADC_SCAN_AllEntriesInserted(&ADC_SCAN_0);
 *   ADC_SCAN_EnableArbitration(&ADC_SCAN_0);
 *   XMC_VADC_GROUP_ScanTriggerConversion(ADC_SCAN_0.group_handle);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE void ADC_SCAN_EnableArbitration(ADC_SCAN_t *const handle_ptr)
{
  XMC_ASSERT("ADC_SCAN_EnableArbitration:Invalid handle_ptr", (handle_ptr != NULL));

  XMC_VADC_GROUP_ScanEnableArbitrationSlot(handle_ptr->group_handle);
}

/**
 * @brief  Stops the scan request source arbitration.<BR>
 * @param handle_ptr pointer (ADC_SCAN_t) to the instance variable and the handle pointer.<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Stops the VADC arbiter for the scan request source.<BR>
 * After this API is invoked the ADC is ready for accepting conversion requests. When invoked this API
 * would write to GxARBPR.ASEN1 bit to disable the arbiter.
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
 * #include "DAVE.h"
 *
 * void adc_callback(void);
 * XMC_VADC_RESULT_SIZE_t result[3];
 *
 * ADC_SCAN_ENTRY_t ch_entry0 =
 * {
 *   .channel_number        = 1U,
 *   .ch_event_notification = false,
 *   .rs_event_notification = true,
 *   .adc_event_callback    = (adc_callback)
 * };
 *
 * static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
 * {
 *   .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
 *   .lower_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .upper_boundary_select 	    = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
 *   .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
 *   .sync_conversion  		    = (uint32_t) 0,                            // Sync feature disabled
 *   .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
 *   .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
 *   .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
 *   .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
 *   .broken_wire_detect		    = (uint32_t) 0,    		                 // No Broken wire detection
 *   .bfl                        = (uint32_t) 0,                            //No Boundary flag
 *   .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
 *                                                // by background request source
 *   .alias_channel              = (int8_t) -1                              // Alias feature not selected
 * };
 *
 * XMC_VADC_RESULT_CONFIG_t res_handle =
 * {
 *   .data_reduction_control   = (uint8_t) 0,  // No Accumulation
 *   .post_processing_mode     = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
 *   .wait_for_read_mode  	  = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
 *   .part_of_fifo       	  = (uint32_t) 0,  // FIFO has been disabled
 *   .event_gen_enable   	  = (uint32_t) 0   // result event generation disabled
 * };
 *
 * void adc_callback(void)
 * {
 *   uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_SCAN_0.group_handle,ch_entry0.channel_number);
 *   result[0] = XMC_VADC_GROUP_GetResult(ADC_SCAN_0.group_handle,result_reg);
 * }
 *
 * int main(void)
 * {
 *   DAVE_Init(); //ADC_SCAN_Init is called within DAVE_Init
 *   ADC_SCAN_DisableArbitration(&ADC_SCAN_0);
 *   ADC_SCAN_InsertScanEntry(&ADC_SCAN_0,&ch_entry0);
 *   // initialize CHANNEL
 *   XMC_VADC_GROUP_ChannelInit(ADC_SCAN_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
 *   // initialize RESULT
 *   XMC_VADC_GROUP_ResultInit(ADC_SCAN_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
 *   // initialize pin here if needed
 *
 *   ADC_SCAN_AllEntriesInserted(&ADC_SCAN_0);
 *   ADC_SCAN_EnableArbitration(&ADC_SCAN_0);
 *   XMC_VADC_GROUP_ScanTriggerConversion(ADC_SCAN_0.group_handle);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE void ADC_SCAN_DisableArbitration(ADC_SCAN_t *const handle_ptr)
{
  XMC_ASSERT("ADC_SCAN_DisableArbitration:Invalid handle_ptr", (handle_ptr != NULL));

  XMC_VADC_GROUP_ScanDisableArbitrationSlot(handle_ptr->group_handle);
}


/**
 * @}
 */
#include "adc_scan_extern.h"
#ifdef __cplusplus
}
#endif
 
#endif /* ADC_SCAN_H */
