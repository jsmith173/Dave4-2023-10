/**
 * @file hrpwm.h
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * HRPWM v4.1.22 - HRPWM APP using one slice of CCU8 and HRC, with external events, dead time and high resolution
 *                 positioning support, to generate up to 2 PWM outputs.
 *
 * Copyright (c) 2015 - 2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-14:
 *     - Initial version for DAVEv4
 *
 * 2015-05-20:
 *     - HRPWM_AcknowledgeInterrupt() api is renamed as HRPWM_ClearEvent().
 *     - Logic for LLD version check is added.
 *
 * 2015-06-19:
 *     - Logic for LLD version check is removed.
 *     - LLD package version check is added.
 *
 * 2015-06-20:
 *     - Copyright information updated.
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */

#ifndef HRPWM_H_
#define HRPWM_H_

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "xmc_gpio.h"
#include "hrpwm_conf.h"

/**********************************************************************************************************************
* MACROS
**********************************************************************************************************************/
#define HRPWM_XMC_LIB_MAJOR_VERSION 2
#define HRPWM_XMC_LIB_MINOR_VERSION 0
#define HRPWM_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > HRPWM_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == HRPWM_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > HRPWM_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == HRPWM_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == HRPWM_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= HRPWM_XMC_LIB_PATCH_VERSION)))
#error "HRPWM requires XMC Peripheral Library v2.0.0 or higher"
#endif

#define HRPWM_MAX_TIMER_COUNT  (65535U)

/**********************************************************************************************************************
* ENUMS
**********************************************************************************************************************/
 /**
  * @ingroup HRPWM_enumerations
  * @{
  */

/**
 *   @brief The type identifies the APP status.
 */
typedef enum HRPWM_STATUS
{
 /**
 * STATUS SUCCESS
 */
  HRPWM_STATUS_SUCCESS = 0,
  /**
  * STATUS FAILURE
  */
  HRPWM_STATUS_FAILURE,
  /**
  * STATUS ALREADY INITIALIZED
  */
  HRPWM_STATUS_ALREADY_INITIALIZED
} HRPWM_STATUS_t;

/**
 * @brief The type identifies APP state.
 */
typedef enum HRPWM_STATE
{
  /**
   * default state after power on reset
   * HRPWM APP is in uninitialized mode. The corresponding CCU8 timer and HRC module is not configured.
   * PWM pulses is not generated.
   */
  HRPWM_STATE_UNINITIALIZED,

  /**
   * HRPWM APP is in initialized mode. The corresponding CCU8 timer and HRC module is configured.
   * The corresponding CCU8 timer is not started(not running).
   * However the output PWM pulses may still be generates based on signal connection of SET_0, CLEAR_0, SET_1, CLEAR_1.
   */
  HRPWM_STATE_INITIALIZED,

  /**
   * HRPWM APP is in running mode. The corresponding CCU8 timer is running.
   * Trigger signal for any of the configured Interrupt or service request in the CCU8 timer is triggered.
   * However the output PWM pulses is generates based on signal connection of SET_0, CLEAR_0, SET_1, CLEAR_1.
   */
  HRPWM_STATE_RUNNING,

  /**
   * HRPWM APP is in stopped mode. The corresponding CCU8 timer is stopped.
   * Trigger signal for any of the configured Interrupt or service request in the CCU8 timer is not triggered.
   * However the output PWM pulses may still be generates based on signal connection of SET_0, CLEAR_0, SET_1, CLEAR_1.
   */
  HRPWM_STATE_STOPPED

} HRPWM_STATE_t;


/**
 * @}
 */

/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
  * @ingroup HRPWM_datastructures
  * @{
  */
/**
 * @brief Configuration parameters of the HRPWM APP
 */
typedef struct HRPWM_ConfigType
{
    const    bool                               start_control;            /**<Enables starting of timer after initialization*/
    const    uint16_t                           period_value;             /**<Period register value. Determines the frequency*/
    const    uint16_t                           compare1_value;           /**<Channel 1 compare register value. Determines the duty cycle*/
    const    uint16_t                           compare2_value;           /**<Channel 2 compare register value. Determines the duty cycle*/

    const    bool                               int_per_match;            /**<Enables event service request generation when timer value equals to period register */
    const    bool                               int_cmp1_match_up;        /**<Enables event service request generation when timer is counting up and equals to channel 1 compare register*/
    const    bool                               int_cmp1_match_down;      /**<Enables event service request generation when timer is counting down and equals to channel 1 compare register*/
    const    bool                               int_cmp2_match_up;        /**<Enables event service request generation when timer is counting up and equals to channel 2 compare register*/
    const    bool                               int_cmp2_match_down;      /**<Enables event service request generation when timer is counting down and equals to channel 2 compare register*/
    const    bool                               int_one_match_down;       /**<Enables event service request generation when timer is counting down and equals 1*/
    const    bool                               int_e0;                   /**<Enables event service request generation by external event 0 signal based on the trigger edge selection */
    const    bool                               int_e1;                   /**<Enables event service request generation by external event 1 signal based on the trigger edge selection */
    const    bool                               int_e2;                   /**<Enables event service request generation by external event 2 signal based on the trigger edge selection */

    const    XMC_CCU8_SLICE_SR_ID_t             sr_per_match;             /**<Service request node to which  period match event is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_cmp1_match_up;         /**<Service request node to which  channel 1 compare match while timer counting up event is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_cmp1_match_down;       /**<Service request node to which  channel 1 compare match while timer counting down event is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_cmp2_match_up;         /**<Service request node to which  channel 2 compare match while timer counting up event is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_cmp2_match_down;       /**<Service request node to which  channel 2 compare match while timer counting down event is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_one_match_down;        /**<Service request node to which  timer one match event is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_e0;                    /**<Service request node to which  event 0 is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_e1;                    /**<Service request node to which  event 1 is forwarded*/
    const    XMC_CCU8_SLICE_SR_ID_t             sr_e2;                    /**<Service request node to which  event 2 is forwarded*/

    const    XMC_CCU8_SLICE_EVENT_CONFIG_t *const     event0_config_ptr;  /**<Points to the variable containing event 0 configuration*/
    const    XMC_CCU8_SLICE_EVENT_CONFIG_t *const     event1_config_ptr;  /**<Points to the variable containing event 1 configuration*/
    const    XMC_CCU8_SLICE_EVENT_CONFIG_t *const     event2_config_ptr;  /**<Points to the variable containing event 2 configuration*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_start_event;    /**<Defines to which event external start signal is connected*/
    const    XMC_CCU8_SLICE_START_MODE_t              ext_start_mode;     /**<Defines mode of starting the timer*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_stop_event;     /**<Defines to which event external stop signal is connected*/
    const    XMC_CCU8_SLICE_END_MODE_t                ext_stop_mode;      /**<Defines mode of stopping the timer*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_count_dir_event;/**<Defines to which event external count direction signal is connected*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_gate_event;     /**<Defines to which event external gating signal is connected*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_count_event;    /**<Defines to which event external count signal is connected*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_load_event;     /**<Defines to which event external load signal is connected*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_mod_event;      /**<Defines to which event external modulation signal is connected*/
    const    XMC_CCU8_SLICE_MODULATION_MODE_t         ext_mod_mode;       /**<Defines mode of external modulation*/
    const    bool                                     ext_mod_sync;       /**<Defines mode of synchronization for external modulation*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_override_edge_event;  /**<Defines to which event external edge override signal is connected*/

    const    XMC_CCU8_SLICE_EVENT_t                   ext_override_level_event; /**<Defines to which event external level override signal is connected*/

    const    bool                                     ext_trap_enable;          /**<Enables the trap*/
    const    XMC_CCU8_SLICE_EVENT_t                   ext_trap_event;           /**<Defines to which event external trap signal is connected*/
    const    bool                                     ext_trap_sync;            /**<Defines mode of synchronization*/
    const    XMC_CCU8_SLICE_TRAP_EXIT_MODE_t          ext_trap_exit;            /**<Defines mode of exiting trap state*/

    const    XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t *const dt_config_ptr;            /**<Points to the variable containing dead time configuration*/

    const    XMC_CCU8_SLICE_COMPARE_CONFIG_t   *const ccu8_cc8_slice_timer_ptr; /**<Points to the variable CCU8 timer initialization*/

    const    bool                                     hrpwm_hr_path_enable;     /**<Defines if high resolution path requires enabling  */
    const    bool                                     hrpwm_lr_path_enable;     /**<Defines if low resolution path requires enabling  */
    const    uint32_t                                 hrpwm_hr_path_enable_mask;/**<Mask for enabling high resolution path*/
    const    uint32_t                                 hrpwm_lr_path_enable_mask;/**<Mask for enabling low resolution path*/
    const    XMC_HRPWM_HRC_CONFIG_t     *const        hrc_channel_config_ptr;   /**<Points to the variable containing HRC configuration*/
    const    XMC_HRPWM_HRC_SRC_CONFIG_t *const        hrc_src_config0_ptr;      /**<Points to the variable containing HRC source 0 configuration*/
    const    XMC_HRPWM_HRC_SRC_CONFIG_t *const        hrc_src_config1_ptr;      /**<Points to the variable containing HRC source 1 configuration*/
    const    uint32_t                                 dt_hrpwm_rise;            /**<Dead time rising edge*/
    const    uint32_t                                 dt_hrpwm_fall;            /**<Dead time falling edge*/
    const    uint32_t                                 hr_cr1;                   /**<High resolution positioning rising edge*/
    const    uint32_t                                 hr_cr2;                   /**<High resolution positioning falling edge*/

    const    bool                             gpio_hr_out0_enable;       /**<Enables GPIO initialization for high resolution direct output*/
             XMC_GPIO_PORT_t   *const         gpio_hr_out0_ptr;          /**<Points to PORT BASE address*/
    const    uint8_t                          gpio_hr_out0_pin;          /**<Pin number in the selected PORT*/
    const    XMC_GPIO_CONFIG_t *const         gpio_hr_out0_config_ptr;   /**<Points to the variable containing GPIO configuration*/

    const    bool                             gpio_hr_out1_enable;       /**<Enables GPIO initialization for high resolution inverted output*/
             XMC_GPIO_PORT_t   *const         gpio_hr_out1_ptr;          /**<Points to PORT BASE address*/
    const    uint8_t                          gpio_hr_out1_pin;          /**<Pin number in the selected PORT*/
    const    XMC_GPIO_CONFIG_t *const         gpio_hr_out1_config_ptr;   /**<Points to the variable containing GPIO configuration*/

             GLOBAL_CCU8_t     *const         global_ccu8_handle;        /**<Points to the variable containing GPIO configuration*/
             GLOBAL_HRPWM_t    *const         global_hrpwm_handle;       /**<Points to GLOBAL_CCU8 APP handle*/

} HRPWM_CONFIG_t;

/**
 * @brief Initialization parameters of the HRPWM APP
 */
typedef struct HRPWM_HandleType
{
  const HRPWM_CONFIG_t         *const  config_ptr;                  /**<Points to the variable containing PWM_CCU8 APP configuration*/
        XMC_CCU8_MODULE_t      *const  ccu8_module_ptr;             /**<Points to CCU8 global register base address*/
        XMC_CCU8_SLICE_t       *const  ccu8_slice_ptr;              /**<Points to CCU8 slice register base address*/

  const uint8_t                        kernel_number;               /**<CCU8 Kernel number*/
  const uint8_t                        slice_number;                /**<CCU8 slice number*/
  const uint32_t                       shadow_txfr_msk;             /**<Mask for enabling shadow transfer of period and compare registers*/
  const uint32_t                       dither_shadow_txfr_msk;      /**<Mask for enabling shadow transfer of dither registers*/
  const uint32_t                       prescaler_shadow_txfr_msk;   /**<Mask for enabling shadow transfer of floating prescaler registers*/

        XMC_HRPWM_t            *const  hrc_module_ptr;              /**<Points to HRPWM global register base address*/
        XMC_HRPWM_HRC_t        *const  hrc_slice_ptr;               /**<Points to HRC slice register base address*/
  const uint32_t                       hr_shadow_transfer_msk;      /**<Mask for enabling shadow transfer of hrc registers*/
  const uint32_t                       hr_dt_transfer_msk;          /**<Mask for enabling shadow transfer of dead time registers*/
  const uint32_t                       hr_cr_max;                   /**<Defines the maximum value of high resolution positioning based on operating clock*/

  HRPWM_STATE_t                        state;                       /**<Defines the current state of the HRPWM APP*/
  float                                frequency_tclk;              /**<Defines the operating frequency of the CCU8 slice in Hz*/
  float                                frequency_module;            /**<Defines the operating frequency of the HRC slice in Hz*/
  float                                high_res_const;              /**<Defines the constant for calculating high resolution positioning*/
  float                                sym_duty1;                   /**<Defines the channel 1 duty cycle in symmetric mode*/
  float                                sym_duty2;                   /**<Defines the channel 2 duty cycle in symmetric mode*/
  float                                asym_duty;                   /**<Defines the shift in asymmetric mode*/
  float                                asym_shift;                  /**<Defines the duty cycle in asymmetric mode*/

} HRPWM_t;

/**
 * @}
 */

/**
 * @ingroup HRPWM_apidoc
 * @{
 */

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/* Support for C++ */
#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Retrieves the version of the HRPWM APP.
 * @param None
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a specific version of the APP.
 *
 *Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void)
 * {
 *   DAVE_APP_VERSION_t version;
 *   version = HRPWM_GetAppVersion();
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
DAVE_APP_VERSION_t HRPWM_GetAppVersion(void);


/**
 * @brief Initializes the HRPWM APP.
 * @param  handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Configures the CCU8 and HRC slice registers with the selected HRPWM APP parameters. The slice is configured in PWM generation mode.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_Init(); //HRPWM_Init() is called by DAVE_Init().
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_Init(HRPWM_t* handle_ptr);

/**
 * @brief Start the selected CCU8 and HRC slice.
 * @param  handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Starts the selected CCU8 and HRC slice for PWM generation. Returns HRPWM_STATUS_SUCCESS if the HRPEM APP state
 * is in "HRPWM_STATE_INITIALIZED" or "HRPWM_STATE_STOPPED" else returns HRPWM_STATUS_FAILURE.
 * <br>HRPWM_Start() is needed to be called if "Start during initialization" is unchecked to start PWM generation,
 * else its called by DAVE_Init();
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_Init();
 *   //This API needs to be called if "Start during initialization" is unchecked
 *   HRPWM_Start(&HRPWM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_Start(HRPWM_t* handle_ptr);

/**
 * @brief Stop the selected CCU8 and HRC slice.
 * @param  handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Stops the selected CCU8 slice form PWM generation. Returns HRPWM_STATUS_SUCCESS if the HRPWM APP state
 * is not "HRPWM_STATE_UNINITIALIZED" else returns HRPWM_STATUS_FAILURE.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_Init();
 *   HRPWM_Stop(&HRPWM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_Stop(HRPWM_t* handle_ptr);

/**
 * @brief Returns the CCU8 timer value.
 * @param  handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @return uint32_t
 *
 * \par<b>Description: </b><br>
 * Returns the timer value if the APP is initialized.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t timer ;
 *   DAVE_Init();
 *   timer = HRPWM_GetTimerValue(&HRPWM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE uint32_t HRPWM_GetTimerValue(HRPWM_t* handle_ptr)
{
  uint32_t timer_value;
  XMC_ASSERT("HRPWM_GetTimerValue:handle_ptr NULL", (handle_ptr != NULL));
  timer_value = (uint32_t) XMC_CCU8_SLICE_GetTimerValue(handle_ptr->ccu8_slice_ptr);
  XMC_DEBUG("HRPWM_GetTimerValue:timer value");
  return (timer_value);
}/* end of HRPWM_GetTimerValue() api */

/**
 * @brief Returns the CCU8 timer status.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @return bool
 *
 * \par<b>Description: </b><br>
 * Returns true is the timer is running else returns false.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   bool status;
 *   DAVE_Init();
 *   status = HRPWM_GetTimerStatus(&HRPWM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE bool HRPWM_GetTimerStatus(HRPWM_t* handle_ptr)
{
  bool status_timer;
  XMC_ASSERT("HRPWM_GetTimerStatus:handle_ptr NULL", (handle_ptr != NULL));
  status_timer = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
  return (status_timer);
} /* end of HRPWM_GetStatus() api */

/**
 * @brief Sets the CCU8 period register
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param period period register value
 * @return HRPWM_STATUS_t\n
 *
 * \par<b>Description: </b><br>
 * Sets the CCU8 period register if the APP is not in uninitialized state.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   status = HRPWM_SetPeriod(&HRPWM_0, 1200);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE HRPWM_STATUS_t HRPWM_SetPeriod(HRPWM_t* handle_ptr, uint16_t period)
{
  HRPWM_STATUS_t status = HRPWM_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_SetPeriod:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t) period);
    XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
    status = HRPWM_STATUS_SUCCESS;
  }
  return (status);
} /* end of HRPWM_SetPeriod() api */

/**
 * @brief Sets the CCU8 channel 1 compare register
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param compare_value compare register value
 * @return HRPWM_STATUS_t\n
 *
 * \par<b>Description: </b><br>
 * Sets the CCU8 channel 1 compare register if the APP is not in uninitialized state.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   status = HRPWM_SetCCU8CompareCh1(&HRPWM_0, 600);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE HRPWM_STATUS_t HRPWM_SetCCU8CompareCh1(HRPWM_t* handle_ptr, uint16_t compare_value)
{
  HRPWM_STATUS_t status = HRPWM_STATUS_FAILURE;
  XMC_ASSERT("HRPWM_SetCCU8CompareCh1:handle_ptr NULL", (handle_ptr != NULL));
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                        (uint16_t) compare_value);
    XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
    status = HRPWM_STATUS_SUCCESS;
  }
  return (status);
} /* end of HRPWM_SetCCU8CompareCh1() api */

/**
 * @brief Sets the CCU8 channel 2 compare register
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param compare_value compare register value
 * @return HRPWM_STATUS_t\n
 *
 * \par<b>Description: </b><br>
 * Sets the CCU8 channel 2 compare register if the APP is not in uninitialized state.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   status = HRPWM_SetCCU8CompareCh2(&HRPWM_0, 800);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE HRPWM_STATUS_t HRPWM_SetCCU8CompareCh2(HRPWM_t* handle_ptr, uint16_t compare_value)
{
  HRPWM_STATUS_t status = HRPWM_STATUS_FAILURE;
  if (HRPWM_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_ASSERT("HRPWM_SetCCU8CompareCh2:handle_ptr NULL", (handle_ptr != NULL));
    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                        (uint16_t) compare_value);
    XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
    status = HRPWM_STATUS_SUCCESS;
  }
  return (status);
} /* end of HRPWM_SetCCU8CompareCh2() api */

/**
 * @brief Sets the PWM frequency in symmetric mode.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param pwm_freq_hz value in Hz (uint32_t)
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Sets the PWM frequency when APP is operating in symmetric mode. The APP should not be in "HRPWM_STATE_UNINITIALIZED" state.
 * Returns HRPWM_STATUS_SUCCESS if frequency update is success.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   status = HRPWM_SetFreqSymmetric(&HRPWM_0, 100000);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_SetFreqSymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz);

/**
 * @brief Sets the frequency duty cycle in symmetric mode.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param pwm_freq_hz value in Hz (uint32_t)
 * @param duty_ch1 channel 1 duty
 * @param duty_ch2 channel 2 duty
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Sets the PWM frequency and duty when APP is operating in symmetric mode. The APP should not be in "HRPWM_STATE_UNINITIALIZED" state.
 * Duty is in float %. <br>The condition [duty < 100%] should be met.<br>
 * Returns HRPWM_STATUS_SUCCESS if operation update is success.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   // Sets freq = 100000, channel 1 duty = 50%, channel 2 duty = 60%
 *   status = HRPWM_SetFreqAndDutyCycleSymmetric(&HRPWM_0, 100000, 50.0f,60.0f);
 *   while(1);
 *    return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_SetFreqAndDutyCycleSymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz, float duty_ch1, float duty_ch2);

/**
 * @brief Sets the duty cycle in symmetric mode.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param channel number XMC_CCU8_SLICE_COMPARE_CHANNEL_t
 * @param duty_cycle channel duty cycle  uint32_t
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Sets the PWM duty when APP is operating in symmetric mode. The APP should not be in "HRPWM_STATE_UNINITIALIZED" state.
 * Select the channel for updating the duty. Duty is in float %.<br> The condition [duty < 100%] should be met.<br>
 * Returns HRPWM_STATUS_SUCCESS if operation update is success.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   // sets the channel duty to 40%.
 *   status = HRPWM_SetDutyCycleSymmetric(&HRPWM_0, XMC_CCU8_SLICE_COMPARE_CHANNEL_1, 40.0f);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_SetDutyCycleSymmetric(HRPWM_t* handle_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_t channel, float duty_cycle);

/**
 * @brief Sets the PWM frequency in asymmetric mode.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param pwm_freq_hz value in Hz (uint32_t)
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Sets the PWM frequency when APP is operating in asymmetric mode. The APP should not be in "HRPWM_STATE_UNINITIALIZED" state.
 * Shift and duty is in float %.<br>
 * The condition [shift + duty < 100%] should be met when APP operating in <b>edge aligned</b> mode.<br>
 * The condition [shift < 50%] and [50% < shift + duty 100%] should be met when APP operating in <b>center aligned</b> mode.<br>
 * Returns HRPWM_STATUS_SUCCESS if operation update is success.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   status = HRPWM_SetFreqAsymmetric(&HRPWM_0, 100000);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_SetFreqAsymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz);

/**
 * @brief Sets the shift and duty cycle in asymmetric mode.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param shift required shift
 * @param duty_cycle required duty
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Sets the PWM shift and duty when APP is operating in asymmetric mode. The APP should not be in "HRPWM_STATE_UNINITIALIZED" state.
 * Shift and duty is in float %. <br>
 * The condition [shift + duty < 100%] should be met when APP operating in <b>edge aligned</b> mode.<br>
 * The condition [shift < 50%] and [50% < shift + duty 100%] should be met when APP operating in <b>center aligned</b> mode.<br>
 * Returns HRPWM_STATUS_SUCCESS if operation is success.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   status = HRPWM_SetDutyCycleAsymmetric(&HRPWM_0, 30.0f, 40.0f);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_SetDutyCycleAsymmetric(HRPWM_t* handle_ptr, float shift, float duty_cycle);

/**
 * @brief Sets the frequency, shift and duty cycle in asymmetric mode.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param pwm_freq_hz required frequency.
 * @param shift required shift
 * @param duty_cycle required duty
 * @return HRPWM_STATUS_t
 *
 * \par<b>Description: </b><br>
 * Sets the PWM frequency, shift and duty when APP is operating in asymmetric mode. The APP should not be in "HRPWM_STATE_UNINITIALIZED" state.
 * Shift and duty is in float %. <br>
 * The condition [shift + duty] < 100% should be met when APP operating in <b>edge aligned</b> mode.<br>
 * The condition [shift < 50%] and [50% < shift + duty 100%] should be met when APP operating in <b>center aligned</b> mode.<br>
 * Returns HRPWM_STATUS_SUCCESS if operation is success.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   HRPWM_STATUS_t status;
 *   DAVE_Init();
 *   status = HRPWM_SetFreqAndDutyCycleAsymmetric(&HRPWM_0, 100000, 3000, 5000);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
HRPWM_STATUS_t HRPWM_SetFreqAndDutyCycleAsymmetric(HRPWM_t* handle_ptr, uint32_t pwm_freq_hz, float shift, float duty_cycle);

/**
 * @brief Clears the trap event.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @return void
 *
 * \par<b>Description: </b><br>
 * Clears the trap event provided the trap condition no longer exists.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_Init();
 *   HRPWM_ClearTrap(&HRPWM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE void HRPWM_ClearTrap(HRPWM_t* handle_ptr)
{
  XMC_ASSERT("HRPWM_ClearTrap:handle_ptr NULL", (handle_ptr != NULL));
  XMC_CCU8_SLICE_ClearEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2);
  XMC_DEBUG("HRPWM_ClearTrap:trap event cleared");
}/* end of HRPWM_ClearTrap() api */

/**
 * @brief Updates the HRC dead time registers.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param rise_value dead time rise value
 * @param fall_value dead time fall value
 * @return void
 *
 * \par<b>Description: </b><br>
 * Updates the HRC dead time registers of selected channel. The actual dead time applied is dependent on CCU8/HRC module frequency.
 * <br>dead time register value = required dead time / frequency_module;
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_Init();
 *   HRPWM_SetDeadTime(&HRPWM_0, 300U, 300U);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE void HRPWM_SetDeadTime(HRPWM_t* handle_ptr, uint16_t rise_value, uint16_t fall_value)
{
  XMC_ASSERT("HRPWM_SetDeadTime:handle_ptr NULL", (handle_ptr != NULL));

  XMC_HRPWM_HRC_SetDeadTimeRising(handle_ptr->hrc_slice_ptr, (uint16_t) rise_value);
  XMC_HRPWM_HRC_SetDeadTimeFalling(handle_ptr->hrc_slice_ptr, (uint16_t) fall_value);
  XMC_HRPWM_EnableHighResolutionShadowTransfer(handle_ptr->hrc_module_ptr, handle_ptr->hr_dt_transfer_msk);

  XMC_DEBUG("HRPWM_SetDeadTime:dead time set");
}/* end of HRPWM_SetDeadTime() api */

/**
 * @brief Returns the CCU8 interrupt status.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param pwm_interrupt interrupt ID
 * @return bool
 *
 * \par<b>Description: </b><br>
 * Returns true if the interrupt flag is set, else returns false.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   bool status;
 *   DAVE_Init();
 *   // Returns period match interrupt status.
 *   status = HRPWM_GetInterruptStatus(&HRPWM_0,XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 *   // Returns channel 1 compare match interrupt status.
 *   status = HRPWM_GetInterruptStatus(&HRPWM_0,XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE bool HRPWM_GetInterruptStatus(HRPWM_t* handle_ptr, XMC_CCU8_SLICE_IRQ_ID_t pwm_interrupt)
{
  bool status = (bool) false;
  XMC_ASSERT("HRPWM_GetInterruptStatus:handle_ptr NULL", (handle_ptr != NULL));
  status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_slice_ptr, pwm_interrupt);
  return (status);
} /* end of HRPWM_GetInterruptStatus() api */

/**
 * @brief Acknowledges the CCU8 interrupt.
 * @param handle_ptr Pointer to HRPWM_t structure containing APP parameters.
 * @param pwm_interrupt interrupt ID
 * @return
 *
 * \par<b>Description: </b><br>
 * Clears the interrupt status flag, provided the interrupt condition no longer exists.
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_Init();
 *   HRPWM_ClearEvent(&HRPWM_0,XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 *   HRPWM_ClearEvent(&HRPWM_0,XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
__STATIC_INLINE void HRPWM_ClearEvent(HRPWM_t* handle_ptr, XMC_CCU8_SLICE_IRQ_ID_t pwm_interrupt)
{
  XMC_ASSERT("HRPWM_ClearEvent:handle_ptr NULL", (handle_ptr != NULL));
  XMC_CCU8_SLICE_ClearEvent(handle_ptr->ccu8_slice_ptr, pwm_interrupt);
  XMC_DEBUG("HRPWM_ClearEvent:Acknowledge Interrupt");
} /* end of HRPWM_ClearEvent() api */

#include "hrpwm_extern.h"

/**
 * @}
 */
#ifdef __cplusplus
}
#endif

#endif /* HRPWM_H_ */

